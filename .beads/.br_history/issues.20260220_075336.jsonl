{"id":"bd-10a","title":"Add donor-extraction scope document with explicit V8/QuickJS exclusions","description":"Implements PLAN 10.1 fourth TODO: define semantic donor extraction scope and explicit exclusions, including prohibition on transplanting V8/QuickJS architecture/runtime internals while allowing behavior-level semantic harvesting. Include acceptance criteria and review gates.","status":"in_progress","priority":1,"issue_type":"task","assignee":"StormyPond","created_at":"2026-02-20T07:24:56.303039948Z","created_by":"StormyPond","updated_at":"2026-02-20T07:52:26.641892286Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["architecture","documentation","donor-spec","governance","plan","section-10-1"]}
{"id":"bd-117","title":"[10.11] Add deterministic fallback protocol when anti-entropy reconciliation cannot peel/resolve.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add deterministic fallback protocol when anti-entropy reconciliation cannot peel/resolve.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:37.768994935Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:26.688288654Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-11ni","title":"[11] Define deterministic fallback-trigger conditions and safe-mode entry","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: fallback trigger\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Fallback trigger conditions are formally specified with deterministic predicates.\\n2. Safe-mode transition is exercised by unit tests and end-to-end replay scenarios with structured logs.\\n3. Documentation includes operator-visible trigger semantics and rollback linkage.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:16.714171974Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:26.734124217Z","closed_at":"2026-02-20T07:38:23.098483379Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-11ni","depends_on_id":"bd-von8","type":"blocks","created_at":"2026-02-20T07:38:26.271271018Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-11p","title":"[10.7] Integrate `test262` ES2020 normative profile as a release blocker with explicit waiver file and zero silent failures policy.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Integrate `test262` ES2020 normative profile as a release blocker with explicit waiver file and zero silent failures policy.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.184167072Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:26.780483415Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"]}
{"id":"bd-11ua","title":"[13] PLAS produces signed `capability_witness` artifacts for >= 90% of targeted extension cohorts in production lanes","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: PLAS produces signed `capability_witness` artifacts for >= 90% of targeted extension cohorts in production lanes\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:24.766230125Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:26.827487144Z","closed_at":"2026-02-20T07:39:58.284248144Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-11z7","title":"[10.13] Add compile-time lint/CI guard rejecting ambient authority in extension-host control paths.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add compile-time lint/CI guard rejecting ambient authority in extension-host control paths.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:43.934720672Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:26.873892628Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-121","title":"[10.11] Build deterministic lab runtime harness with schedule replay, virtual time, and cancellation injection.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Build deterministic lab runtime harness with schedule replay, virtual time, and cancellation injection.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.501148876Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:26.919899260Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-127","title":"[10.11] Add bounded masking helper for tiny atomic publication steps only; block long-operation masking by policy.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add bounded masking helper for tiny atomic publication steps only; block long-operation masking by policy.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:33.901233114Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:26.969113506Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-12m","title":"[10.6] Performance Program - Comprehensive Execution Epic","description":"## Plan Reference\nSection 10.6: Performance Program\n\n## Overview\nThis epic covers the systematic performance engineering program: benchmark suite design, denominator math, profiling infrastructure, optimization workflow, and security-proof-guided specialization benchmarks.\n\n## Child Beads\n- bd-2ql: Define and publish Extension-Heavy Benchmark Suite v1.0 (foundational)\n- bd-2n9: Implement benchmark denominator calculator (weighted geometric mean)\n- bd-1nn: Add flamegraph pipeline and artifact storage\n- bd-js4: Add opportunity matrix scoring to optimization workflow\n- bd-2l6: Enforce one-lever-per-change performance policy\n- bd-3qv: Add constrained-vs-ambient benchmark lanes (PLAS/IFC specialization uplift)\n\n## Dependency Chain\nbd-2ql (benchmark suite) → bd-2n9 (denominator) → bd-1nn (flamegraphs) → bd-js4 (opportunity matrix) → bd-2l6 (one-lever policy)\nbd-2ql → bd-3qv (constrained vs ambient, also depends on 10.15 PLAS/IFC)\n\n## Key Requirements\n- >= 3x weighted geometric mean vs both Node and Bun (Phase C exit gate)\n- Profile-first discipline: baseline → profile → prove → implement → verify\n- One optimization lever per commit with score >= 2.0\n- Behavior-equivalence requirements for all benchmark comparisons","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.562536505Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:56.019728261Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-6"],"dependencies":[{"issue_id":"bd-12m","depends_on_id":"bd-1nn","type":"parent-child","created_at":"2026-02-20T07:52:45.139545949Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-12m","depends_on_id":"bd-1yq","type":"blocks","created_at":"2026-02-20T07:32:55.957795889Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-12m","depends_on_id":"bd-2l6","type":"parent-child","created_at":"2026-02-20T07:52:48.413583884Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-12m","depends_on_id":"bd-2n9","type":"parent-child","created_at":"2026-02-20T07:52:48.713280628Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-12m","depends_on_id":"bd-2ql","type":"parent-child","created_at":"2026-02-20T07:52:49.031875601Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-12m","depends_on_id":"bd-3qv","type":"parent-child","created_at":"2026-02-20T07:52:53.542309252Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-12m","depends_on_id":"bd-js4","type":"parent-child","created_at":"2026-02-20T07:52:56.019650066Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-12m","depends_on_id":"bd-ntq","type":"blocks","created_at":"2026-02-20T07:32:55.871267855Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-12n5","title":"[10.15] Publish governance scorecards covering attested-receipt coverage, privacy-budget health, moonshot-governor decisions, and cross-repo conformance stability.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Publish governance scorecards covering attested-receipt coverage, privacy-budget health, moonshot-governor decisions, and cross-repo conformance stability.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:49.637142682Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.019321824Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-12p","title":"[10.12] Add incident replay artifact bundle format and verifier CLI for external audit.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Add incident replay artifact bundle format and verifier CLI for external audit.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.330652847Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.070255953Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-133a","title":"[10.15] Add frankensqlite-backed specialization index enabling deterministic audit queries from security proof -> optimization receipt -> benchmark outcome.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankensqlite-backed specialization index enabling deterministic audit queries from security proof -> optimization receipt -> benchmark outcome.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:53.380938673Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.120907166Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-13a5","title":"Define and enforce evidence-and-decision contract template for all subsystem proposals","description":"## Plan Reference\nSection 11: Evidence And Decision Contracts (Mandatory)\n\n## What\nCreate a mandatory contract template that every major subsystem proposal must satisfy before merge. The template enforces artifact-backed discipline across the entire program.\n\n## Required Template Fields\nEvery proposal must include ALL of the following:\n1. **Change summary**: What is being proposed and why\n2. **Hotspot/threat evidence**: Profile data, threat model, or risk assessment justifying the change\n3. **EV score and tier**: Expected value assessment using the program's EV >= 2.0 threshold from alien-graveyard methodology (Section 5.3)\n4. **Expected-loss model**: Explicit loss matrix for the action space, following alien-artifact-coding discipline (Section 5.2)\n5. **Fallback trigger**: Conditions under which the change auto-reverts or degrades to safe mode\n6. **Rollout wedge**: Staged deployment strategy (shadow -> canary -> ramp -> default per Section 8.8)\n7. **Rollback command**: Exact command(s) to revert the change\n8. **Benchmark and correctness artifacts**: Before/after performance data, golden output checksums, test results\n\n## Enforcement Rule\n'No contract, no merge.' This is a hard gate, not a guideline.\n\n## Rationale\nFrom the plan's ambition-first doctrine: every claim must ship with proof artifacts. This contract template ensures that principle is operationalized at the PR level, preventing unfounded changes from entering the codebase.\n\n## Testing Requirements\n- Unit test: validate that a contract struct with any missing field fails validation\n- Unit test: validate that a complete contract struct passes validation\n- Integration test: CI gate that rejects PRs touching runtime code without a linked contract artifact\n- Test that contract schema is versioned and backward-compatible\n\n## Implementation Notes\n- Implement as a Rust struct with serde support in a shared governance module\n- Consider a CLI subcommand (frankenctl contract validate) for pre-commit checking\n- Store validated contracts alongside code changes in a canonical location\n- Reference: The extreme-software-optimization methodology (Section 5.1) mandates baseline/profile/prove/implement/verify for every optimization - this contract template is the enforcement mechanism\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:38:55.368693030Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:29.887993451Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["documentation","evidence","governance"]}
{"id":"bd-1401","title":"[14] Adversarial resilience (campaign success-rate suppression vs baseline engines).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Adversarial resilience (campaign success-rate suppression vs baseline engines).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:33.792382432Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.173003310Z","closed_at":"2026-02-20T07:41:19.377640744Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-14da","title":"[14] Compute per-case speedup `r_i = throughput_franken_engine_i / throughput_B_i`.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Compute per-case speedup `r_i = throughput_franken_engine_i / throughput_B_i`.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:30.438475371Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.220209075Z","closed_at":"2026-02-20T07:41:20.824984602Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-1525","title":"[13] manual policy-authoring time for onboarded extensions is reduced by >= 70% while maintaining security gate compliance","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: manual policy-authoring time for onboarded extensions is reduced by >= 70% while maintaining security gate compliance\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:25.232809293Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.291185615Z","closed_at":"2026-02-20T07:39:58.086563560Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-15g2","title":"[10.15] Add governance audit ledger capturing all automatic and human override promote/hold/kill decisions with signed rationale.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add governance audit ledger capturing all automatic and human override promote/hold/kill decisions with signed rationale.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:48.647418079Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.345020728Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-15vm","title":"[12] Reduce operational complexity via evidence-ledger tooling and deterministic fallback mode","description":"Plan Reference: section 12 (Risk Register).\nObjective: Operational complexity:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:18.176437649Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.395759974Z","closed_at":"2026-02-20T07:39:04.733555437Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"]}
{"id":"bd-161","title":"[10.2] Define proof-to-specialization linkage in IR contracts (`proof_input_ids`, `optimization_class`, `validity_epoch`, `rollback_token`) for IR3/IR4 artifacts.","description":"## Plan Reference\nSection 10.2, item 6. Cross-refs: 9I.8 (Security-Proof-Guided Specialization), 9F.1 (Verified Adaptive Compiler), 10.12 (proof schema for optimizer), 10.15 (specialization receipt schema).\n\n## What\nDefine the linkage between security proofs and optimizer specializations in IR3/IR4 artifacts. This enables security proofs to serve as optimizer inputs, so tighter verified constraints yield faster executable paths.\n\n## Detailed Requirements\n- IR3 artifacts must carry: proof_input_ids (which proofs justify this specialization), optimization_class (superinstruction, trace specialization, layout specialization, devirtualized hostcall fast paths), validity_epoch (when this specialization expires), rollback_token (how to revert to unspecialized path)\n- IR4 witness artifacts must record: which specializations were active during execution, what proofs were consumed, performance delta observed\n- Specializations must be invalidated deterministically on policy/proof epoch changes (per 9I.8)\n- Automatic fallback to unspecialized baseline paths when proofs expire or are invalidated\n\n## Rationale\nSection 9I.8: 'Make security proofs first-class optimizer inputs so tighter verified constraints yield faster executable paths instead of being treated as overhead.' This creates a structural flywheel: better security → better proofs → faster code → more security investment justified. This is described as 'a structural flywheel unavailable to generic runtimes without proof-bearing security planes.'\n\n## Testing Requirements\n- Unit tests: IR3 artifacts with proof linkage serialize/deserialize correctly\n- Unit tests: specialization invalidation on epoch change triggers rollback\n- Unit tests: fallback path produces semantically identical results to specialized path\n- Specialization-conformance suite (10.7): proof-specialized and unspecialized execution remain semantically equivalent\n\n## Dependencies\n- Blocked by: IR contract (bd-1wa), IFC flow-lattice (bd-1fm)\n- Blocks: optimizer activation (10.12), specialization receipt schema (10.15), specialization-conformance suite (10.7)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.063014834Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.442801944Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"]}
{"id":"bd-16n","title":"[10.10] Add optional threshold-signing workflow for emergency revocation and key rotation operations.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Add optional threshold-signing workflow for emergency revocation and key rotation operations.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.817987466Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.490155254Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-16u","title":"[10.10] Define trust-zone taxonomy and capability ceilings with deterministic inheritance semantics.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Define trust-zone taxonomy and capability ceilings with deterministic inheritance semantics.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.812601797Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.536911081Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-16up","title":"[16] Reference proofs or proof sketches for key policy and protocol safety claims.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: Reference proofs or proof sketches for key policy and protocol safety claims.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:36.451806803Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.583603340Z","closed_at":"2026-02-20T07:46:50.921665748Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"]}
{"id":"bd-16x","title":"[10.4] Implement module cache invalidation strategy.","description":"## Plan Reference\nSection 10.4, item 2. Cross-refs: 9A.5 (supply-chain trust), 9A.10 (provenance + revocation), 10.10 (revocation).\n\n## What\nImplement module cache invalidation strategy that correctly handles trust revocation, code updates, and policy changes without stale or compromised code remaining in the cache.\n\n## Detailed Requirements\n- Cache invalidation on code update: when module source changes, cached compiled form is invalidated\n- Cache invalidation on trust revocation: when a module's trust is revoked (10.10 revocation fabric), cached code must be immediately invalidated and re-resolution must fail or use safe fallback\n- Cache invalidation on policy change: when capability policy changes, cached modules with stale policy assumptions must be re-validated\n- Deterministic invalidation: cache state transitions must be reproducible for replay\n- No stale code: there must be no window where revoked code continues executing from cache\n- Cache coherence: distributed runtime instances must converge on cache state\n\n## Rationale\nModule caching is essential for performance, but stale caches are a security risk. The plan's supply-chain trust fabric (9A.5) and revocation fabric (9A.10) require that trust revocation propagates to all cached code. If compromised module code remains cached after revocation, the revocation is ineffective. Deterministic invalidation is required for replay (9A.3).\n\n## Testing Requirements\n- Unit tests: cache hit for unchanged module, cache miss after source change\n- Unit tests: cache invalidation on trust revocation event\n- Unit tests: cache invalidation on policy change affecting module capabilities\n- Unit tests: no stale code accessible after invalidation\n- Integration tests: end-to-end revocation → cache invalidation → re-resolution flow\n- Determinism tests: same invalidation sequence produces same cache state\n\n## Implementation Notes\n- Cache key should include: module specifier + source hash + policy version + trust state\n- Consider content-addressed cache entries for efficient invalidation\n- Revocation integration requires subscription to revocation events from 10.10\n- Cache coherence for distributed scenarios is covered by anti-entropy (10.11)\n\n## Dependencies\n- Blocked by: module resolver (bd-tgv), revocation fabric (10.10)\n- Blocks: compatibility mode matrix (bd-3vp), production deployment reliability","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:23.634424Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.633227560Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-4"]}
{"id":"bd-17v2","title":"[10.15] Add mandatory receipt + replay linkage for every escrow, deny, or emergency grant decision.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add mandatory receipt + replay linkage for every escrow, deny, or emergency grant decision.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:50.968457919Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.680486945Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-181","title":"[10.9] Release gate: GA default lanes are fully native (`0` mandatory delegate cells), with complete signed replacement lineage for all formerly delegated core slots (implementation ownership: `10.15` + `10.2` + `10.7`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: GA default lanes are fully native (`0` mandatory delegate cells), with complete signed replacement lineage for all formerly delegated core slots (implementation ownership: `10.15` + `10.2` + `10.7`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.575933913Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.727248933Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"]}
{"id":"bd-18fu","title":"[11] Require hotspot and threat-evidence bundle per subsystem proposal","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: hotspot/threat evidence\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:16.065176532Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.773241118Z","closed_at":"2026-02-20T07:38:23.401865613Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"]}
{"id":"bd-18m","title":"[10.11] Implement lease-backed remote liveness tracking with explicit timeout/escalation paths.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement lease-backed remote liveness tracking with explicit timeout/escalation paths.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.549170870Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.819293004Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-1999","title":"[10.15] Make matrix+fault conformance lab pass a release blocker for shared-boundary changes, complementing the baseline compatibility gates in `10.14`.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Make matrix+fault conformance lab pass a release blocker for shared-boundary changes, complementing the baseline compatibility gates in `10.14`.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:49.471732515Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.865906405Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-19l0","title":"Define Extension-Heavy Benchmark Suite v1.0 specification and workload matrix","description":"## Plan Reference\nSection 14.1: Extension-Heavy Benchmark Suite v1.0 (Normative)\nSection 7.4-7.5: Benchmark Denominator Contract and Fairness Rules\nSection 9D: Extreme-Software-Optimization Enhancement Map\n\n## What\nDefine and publish the complete benchmark specification that will be used to validate the >= 3x throughput claim (a hard program success criterion from Section 3).\n\n## Suite Structure\nFive benchmark families, each REQUIRED:\n1. **boot-storm**: Extension cold-start and initialization under load\n2. **capability-churn**: Rapid capability grant/revoke cycles\n3. **mixed-cpu-io-agent-mesh**: Combined CPU and I/O workloads simulating agent mesh behavior\n4. **reload-revoke-churn**: Extension hot-reload and revocation under continuous traffic\n5. **adversarial-noise-under-load**: Normal workload with injected adversarial extension behavior\n\nEach family requires three scale profiles: S, M, L with fixed extension counts, event rates, dependency graph sizes, and policy complexity tiers.\n\n## Per-Case Publication Requirements\nEach benchmark case must publish: throughput, p50/p95/p99 latency, allocation/peak memory, correctness digest, and security-event envelope.\n\n## Behavior-Equivalence Requirements (Hard Gates)\n- Equivalent external outputs (canonical digest comparison)\n- Equivalent side-effect trace class (fs/network/process/policy actions normalized by contract schema)\n- Equivalent error-class semantics for negative/exceptional cases\n- No work dropping, relaxed durability, or disabled policy checks to inflate throughput\n\n## Scoring Formula (Binding)\nPrimary score is weighted geometric mean: score(engine, baseline) = exp(sum_i w_i * ln(throughput_engine_i / throughput_baseline_i)), with sum_i w_i = 1\nClaim acceptance requires BOTH: score vs Node >= 3.0 AND score vs Bun >= 3.0\n\n## Fairness Rules (Binding)\n- Baselines pinned to declared versions (Node LTS, Bun stable) with full CLI/env manifests\n- Identical hardware/OS envelopes, warmed/cold cache protocols, fixed dataset seeds\n- Report median + dispersion over repeated runs; publish raw per-run artifacts\n- Result ledgers stored via frankensqlite; operator consoles via frankentui\n- Every claim must include verifier scripts for third-party reruns\n\n## Required Metric Families\n1. Throughput/latency (p50, p95, p99) under extension-heavy workloads\n2. Containment quality (time-to-detect, time-to-contain, FP/FN envelopes)\n3. Replay correctness (determinism pass rate, artifact completeness)\n4. Revocation/quarantine propagation (freshness lag, convergence SLO attainment)\n5. Adversarial resilience (campaign success-rate suppression vs baselines)\n6. Information-flow security (unauthorized flow block rate, declassification envelopes)\n7. Security-proof specialization uplift (proof-specialized vs ambient-authority delta)\n\n## Testing Requirements\n- Unit tests for scoring formula implementation (golden test vectors for weighted geometric mean)\n- Unit tests for behavior-equivalence checker (known-equivalent and known-divergent cases)\n- Integration test running mini S-profile benchmark end-to-end\n- E2E test: full suite run produces valid result artifacts with all required fields\n\n## Rationale\nFrom Section 3: the >= 3x claim is the disruptive floor. From Section 14: FrankenEngine will define and own the reference benchmark standard. This bead defines the scoreboard that competitors must follow.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:41:53.952557303Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:30.822927445Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["benchmark","performance","specification"]}
{"id":"bd-1ad6","title":"[10.14] Define a `franken_engine` TUI adapter boundary for incident replay views, policy explanation cards, and control dashboards backed by `frankentui` components.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Define a `franken_engine` TUI adapter boundary for incident replay views, policy explanation cards, and control dashboards backed by `frankentui` components.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:44.898570137Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.911707324Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-1ai","title":"[10.10] Implement revocation freshness policy with explicit degraded-mode behavior and audit emission.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement revocation freshness policy with explicit degraded-mode behavior and audit emission.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.663094452Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:27.958007222Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-1b2","title":"[10.10] Implement signature preimage contract using unsigned-view encoding and deterministic field ordering.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement signature preimage contract using unsigned-view encoding and deterministic field ordering.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.556632523Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.004957701Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-1bi","title":"[10.10] Implement session-authenticated extension hostcall channel with per-message MAC.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement session-authenticated extension hostcall channel with per-message MAC.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.957371725Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.050842586Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-1bl","title":"[10.11] Implement obligation-tracked channels for safety-critical two-phase internal protocols.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement obligation-tracked channels for safety-critical two-phase internal protocols.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.047346797Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.098538284Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-1blo","title":"[12] Counter heuristic-security false confidence with Bayesian + sequential testing + calibration audits","description":"Plan Reference: section 12 (Risk Register).\nObjective: False confidence from heuristic security:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:17.760799368Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.145841240Z","closed_at":"2026-02-20T07:39:04.932159503Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"]}
{"id":"bd-1bzp","title":"[10.12] Define and publish category benchmark specification with reproducible harness and transparent scoring methodology.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Define and publish category benchmark specification with reproducible harness and transparent scoring methodology.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:41.181176444Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.192490438Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-1c7","title":"[10.10] Define `PolicyCheckpoint` object with `prev_checkpoint`, `checkpoint_seq`, `epoch_id`, policy heads, and quorum signatures.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Define `PolicyCheckpoint` object with `prev_checkpoint`, `checkpoint_seq`, `epoch_id`, policy heads, and quorum signatures.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.838779423Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.239312579Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-1coe","title":"[10.14] Add benchmark gates confirming sibling-repo integrations do not regress critical p95/p99 control-plane SLOs.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add benchmark gates confirming sibling-repo integrations do not regress critical p95/p99 control-plane SLOs.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:46.678758372Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.286014195Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-1cu","title":"[10.0] Top-10 #6: Shadow-run + differential executor onboarding mode (strategy: `9A.6`; deep semantics: `9F.6`; execution owners: `10.7`, `10.12`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #6: Shadow-run + differential executor onboarding mode (strategy: `9A.6`; deep semantics: `9F.6`; execution owners: `10.7`, `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:19.897460064Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.332315065Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"]}
{"id":"bd-1ddd","title":"[10.12] Build operator safety copilot surfaces with recommended actions, confidence bands, and deterministic rollback commands.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Build operator safety copilot surfaces with recommended actions, confidence bands, and deterministic rollback commands.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:41.025696575Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.383910245Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-1dp","title":"[10.10] Implement owner-signed key attestation objects with expiry and nonce freshness requirements.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement owner-signed key attestation objects with expiry and nonce freshness requirements.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.678161144Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.430090019Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-1dxl","title":"[14] Containment quality (time-to-detect, time-to-contain, false-positive/false-negative envelopes).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Containment quality (time-to-detect, time-to-contain, false-positive/false-negative envelopes).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:33.082574256Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.476923962Z","closed_at":"2026-02-20T07:41:19.674683569Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-1edh","title":"[10.14] Add conformance tests proving deterministic replay/index behavior across `frankensqlite`-backed stores.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add conformance tests proving deterministic replay/index behavior across `frankensqlite`-backed stores.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:46.025767468Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.526442535Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-1elf","title":"[13] 100% of activated proof-specializations carry signed receipts linking security-proof inputs to transformation and rollback artifacts","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: 100% of activated proof-specializations carry signed receipts linking security-proof inputs to transformation and rollback artifacts\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:26.875627360Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.573816313Z","closed_at":"2026-02-20T07:39:57.393735513Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-1f45","title":"[13] at least 3 beyond-parity capabilities are in production with operator-facing evidence and documentation","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: at least 3 beyond-parity capabilities are in production with operator-facing evidence and documentation\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:22.599223591Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.620211488Z","closed_at":"2026-02-20T07:39:59.286557726Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-1fa","title":"[10.0] Top-10 #8: Deterministic per-extension resource budget subsystem (strategy: `9A.8`; deep semantics: `9F.10`; execution owners: `10.11`, `10.12`, `10.13`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #8: Deterministic per-extension resource budget subsystem (strategy: `9A.8`; deep semantics: `9F.10`; execution owners: `10.11`, `10.12`, `10.13`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:20.147994640Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.670640407Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"]}
{"id":"bd-1fm","title":"[10.2] Define IFC flow-lattice semantics (`label classes`, `clearance classes`, `declassification obligations`) in `IR2`.","description":"## Plan Reference\nSection 10.2, item 4. Cross-refs: 9I.7 (Runtime IFC + Deterministic Exfiltration Prevention), 9F.4 (Capability-Typed TS Execution), 10.15 (IFC artifacts and flow-label inference).\n\n## What\nDefine Information Flow Control (IFC) flow-lattice semantics within IR2 (CapabilityIR). This enables the runtime to constrain how data moves between sensitive sources and external sinks, blocking exfiltration by construction.\n\n## Detailed Requirements\n- Define label classes: categories of sensitive data (credentials, config secrets, key material, privileged environment state, policy-protected host artifacts)\n- Define clearance classes: authorized data destinations (network egress, subprocess/IPC, export/persistence channels)\n- Define declassification obligations: explicit paths for authorized cross-label data flow\n- Flow lattice must be composable: labels combine via join/meet operations\n- Labels must be representable in IR2 nodes alongside capability annotations\n- Flow-lattice semantics must support both static analysis (compile-time) and dynamic enforcement (runtime)\n- Must integrate with PLAS (9I.5) for automatic flow envelope synthesis\n\n## Rationale\nSection 9I.7 states: 'Capability gating alone cannot express source-to-sink data constraints. IFC closes this structural gap and enables a stronger category claim: deterministic exfiltration resistance with machine-verifiable provenance.' This is a category-defining feature: extensions that legitimately need both fs.read and net.connect can still be prevented from exfiltrating sensitive data unless an explicitly audited declassification path exists.\n\n## Testing Requirements\n- Unit tests: label join/meet operations produce correct lattice results\n- Unit tests: verify label assignment to IR2 nodes\n- Unit tests: verify declassification obligation representation\n- Property tests: lattice operations satisfy algebraic properties (associativity, commutativity, idempotency)\n- Conformance: IFC corpus tests from Section 10.7 (dual-capability benign, exfil-attempt, declassification-exception workloads)\n\n## Implementation Notes\n- Define label types as enum with lattice trait implementation\n- Labels attach to IR2 nodes as metadata, not as separate pass\n- Clearance checks are defined here but enforced in the flow-check pass (bd-3jg) and at runtime (10.5)\n- Must be extensible for new label categories without breaking existing flows\n\n## Dependencies\n- Blocked by: IR contract (bd-1wa) for IR2 type design\n- Blocks: flow-check pass (bd-3jg), PLAS flow envelope synthesis (10.15), runtime flow-label propagation (10.5)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.803200833Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.716705708Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"]}
{"id":"bd-1fu7","title":"[10.15] Implement portfolio governor scoring engine and stage-gate automation for moonshot lifecycle transitions.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement portfolio governor scoring engine and stage-gate automation for moonshot lifecycle transitions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:48.484503060Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.762296755Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-1fx","title":"[10.10] Implement same-sequence divergent-checkpoint fork detection and incident pathway.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement same-sequence divergent-checkpoint fork detection and incident pathway.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.116455726Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.807615265Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-1g5c","title":"[10.15] Add slot-level promotion gate runner (equivalence, capability-preservation, performance threshold, adversarial survival) with deterministic pass/fail artifact bundles.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add slot-level promotion gate runner (equivalence, capability-preservation, performance threshold, adversarial survival) with deterministic pass/fail artifact bundles.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:54.232937676Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.853316738Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-1gcu","title":"[10.15] Add deterministic fallback policy: when attestation validation fails or expires, high-impact autonomous actions degrade to conservative safe mode.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add deterministic fallback policy: when attestation validation fails or expires, high-impact autonomous actions degrade to conservative safe mode.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.492074612Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.898908106Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-1h7n","title":"[13] franken_node composes those lanes for practical runtime usage","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: franken_node composes those lanes for practical runtime usage\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:19.216302677Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:28.977606059Z","closed_at":"2026-02-20T07:40:00.916776963Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-1hh4","title":"[10.15] Add frankensqlite-backed provenance index supporting deterministic source-to-sink lineage queries and replay joins.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankensqlite-backed provenance index supporting deterministic source-to-sink lineage queries and replay joins.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:53.723022386Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.023127256Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-1hu","title":"[10.5] Port extension lifecycle manager into compile-active modules.","description":"## Plan Reference\nSection 10.5, item 2 (Port extension lifecycle manager into compile-active modules). Cross-refs: 9A.8 (resource budgets per extension), 9G.2 (cancellation as protocol, not afterthought), 9A.1 (capability-typed execution model).\n\n## What\nImplement a deterministic extension lifecycle state machine that governs every extension from load through termination. The lifecycle states are: `Unloaded -> Validating -> Loading -> Starting -> Running -> Suspending -> Suspended -> Resuming -> Terminating -> Terminated -> Quarantined`. Each transition is guarded by explicit preconditions (validated manifest, resource budget allocated, capability set confirmed). The lifecycle manager is a compile-active module, meaning its state machine transitions and guard predicates are expressed in the type system where possible, preventing invalid transitions at compile time.\n\n## Detailed Requirements\n- Define `ExtensionState` enum with all lifecycle states listed above.\n- Define `LifecycleTransition` enum representing valid transitions (e.g., `Start`, `Suspend`, `Resume`, `Terminate`, `Quarantine`).\n- Implement `ExtensionLifecycleManager` struct that holds current state, validated manifest reference, resource budget handle, and a transition log.\n- Each transition method must: (a) verify precondition (current state allows transition), (b) execute transition logic, (c) emit structured lifecycle event to telemetry, (d) update state atomically.\n- Invalid transitions must return `LifecycleError` with deterministic error messages including `extension_id`, `current_state`, `attempted_transition`.\n- Implement cancellation protocol per 9G.2: `Terminate` must be a cooperative protocol with a timeout fallback to forced termination. The extension gets a `cancel_token` and has a configurable grace period (default 5s, max 30s) before forced kill.\n- Resource budget enforcement per 9A.8: each lifecycle transition checks remaining budget (CPU time, memory, hostcall count). Budget exhaustion triggers automatic `Suspend` or `Terminate` depending on policy.\n- The lifecycle manager must be `Send + Sync` for use across async task boundaries.\n- All state transitions must be logged with monotonic timestamps for replay.\n\n## Rationale\nExtensions are untrusted code running inside the engine. Without a rigorous lifecycle manager, extensions could enter inconsistent states, leak resources, or evade termination. The compile-active approach ensures that the type system prevents coding errors in lifecycle management itself. The cancellation protocol (9G.2) ensures that termination is never silent or abrupt without giving the extension a chance to clean up, while the timeout fallback ensures the runtime cannot be held hostage.\n\n## Testing Requirements\n- **Unit tests**: Test every valid state transition. Test every invalid transition is rejected with correct error. Test cancellation with cooperative shutdown. Test cancellation with timeout-forced shutdown. Test budget exhaustion triggers correct containment.\n- **State machine exhaustiveness**: Property test that from every reachable state, only documented transitions are possible.\n- **Integration tests**: Full lifecycle of a mock extension: load -> validate -> start -> run -> suspend -> resume -> terminate. Verify telemetry events emitted at each transition.\n- **Concurrency tests**: Multiple extensions running concurrently with independent lifecycle managers, verifying no cross-contamination.\n- **Determinism tests**: Replay a recorded transition sequence and verify identical state sequence and telemetry output.\n\n## Implementation Notes\n- Consider using a typestate pattern in Rust (`ExtensionLifecycle<Running>`, `ExtensionLifecycle<Suspended>`) for compile-time transition safety, with a dynamic fallback for runtime-driven transitions.\n- The transition log should be an append-only `Vec<LifecycleEvent>` with each event containing `(monotonic_timestamp, from_state, to_state, trigger, decision_id)`.\n- Integrate with the telemetry recorder (bd-5pk) for structured event emission.\n- Resource budget handles should be opaque tokens obtained from the resource subsystem (10.4 module surface).\n\n## Dependencies\n- **Blocked by**: bd-xq7 (manifest validation - lifecycle manager requires a validated manifest to proceed past `Validating` state).\n- **Blocks**: bd-5pk (telemetry needs lifecycle events), bd-2gl (containment actions are lifecycle transitions), bd-375 (delegate cells use the same lifecycle manager).\n- **Parent**: bd-1yq (10.5 epic).","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.021147784Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.079081025Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"]}
{"id":"bd-1hw","title":"[10.5] Implement runtime flow-label propagation at dynamic hostcall boundaries and enforce sink-clearance checks.","description":"## Plan Reference\nSection 10.5, item 9 (Implement runtime flow-label propagation at dynamic hostcall boundaries). Cross-refs: 9I.7 (IFC + Deterministic Exfiltration Prevention), 10.2 (IFC flow-lattice in VM core), 9A.7 (capability lattice integrates with flow labels).\n\n## What\nImplement Information Flow Control (IFC) enforcement at runtime hostcall boundaries for dynamic paths that could not be verified statically. Every value crossing a hostcall boundary carries a flow label indicating its secrecy and integrity classification. The runtime propagation layer checks that the flow label of data being sent to a sink (e.g., network egress, file write, IPC channel) is compatible with the sink's clearance level. If the flow label exceeds the sink's clearance, the hostcall is blocked and the violation is recorded as evidence for the Guardplane. This is the runtime complement to the static IFC analysis in 10.2.\n\n## Detailed Requirements\n- Define `FlowLabel` struct: `{ secrecy: SecrecyLevel, integrity: IntegrityLevel }` where `SecrecyLevel` and `IntegrityLevel` are elements of a configurable lattice (partial order).\n- Define `SecrecyLevel` enum with at least: `Public`, `Internal`, `Confidential`, `Secret`, `TopSecret` (configurable/extensible).\n- Define `IntegrityLevel` enum with at least: `Untrusted`, `Validated`, `Verified`, `Trusted` (configurable/extensible).\n- Implement `FlowLabelLattice` that defines the partial order: `can_flow(from: &FlowLabel, to: &FlowLabel) -> bool` returns true iff `from.secrecy <= to.secrecy` AND `from.integrity >= to.integrity` (standard Bell-LaPadula + Biba).\n- Implement `SinkClearance` struct: `{ max_secrecy: SecrecyLevel, min_integrity: IntegrityLevel }` defining what data a sink is authorized to receive.\n- Implement runtime flow-label propagation at hostcall dispatch:\n  - Every hostcall argument carries a `FlowLabel` (attached via a `Labeled<T>` wrapper or context parameter).\n  - Before executing a sink-type hostcall (FsWrite, NetworkSend, IpcSend), the dispatcher checks `can_flow(argument_label, sink_clearance)`.\n  - If the check fails: block the hostcall, return `HostcallResult::Denied { reason: FlowViolation }`, emit a `FlowViolationEvent` to telemetry, and provide the violation as evidence to the Guardplane.\n  - If the check passes: execute the hostcall normally, propagate the label to the output.\n- Label join semantics for operations that combine multiple labeled values: `join(a, b) = FlowLabel { secrecy: max(a.secrecy, b.secrecy), integrity: min(a.integrity, b.integrity) }`.\n- Flow labels must be immutable once assigned (no downgrading without explicit declassification through bd-3jy).\n- Labels must be propagated through IPC channels: when an extension sends data to another extension via IPC, the receiving extension inherits the label.\n- Performance: flow-label checking must add < 500ns overhead per hostcall.\n\n## Rationale\nStatic IFC analysis (10.2) can verify many flow constraints at compile time, but dynamic hostcall paths -- especially those involving runtime-computed capabilities, user-provided data, or IPC between extensions -- cannot be fully analyzed statically. Runtime flow-label propagation closes this gap by enforcing IFC invariants at every hostcall boundary. Per 9I.7, the engine must prevent deterministic exfiltration: a compromised extension must not be able to send secret data to an unauthorized sink. The runtime layer is the last line of defense before data actually leaves the extension boundary.\n\n## Testing Requirements\n- **Unit tests**: `can_flow` with all lattice level combinations (authorized and unauthorized). Label join produces correct result. `Labeled<T>` wrapper preserves the label through operations.\n- **Hostcall dispatch tests**: A hostcall with a `Secret`-labeled argument to a `Public`-clearance network sink is blocked. A hostcall with a `Public`-labeled argument to a `Secret`-clearance sink is allowed. Verify telemetry records the violation/pass.\n- **IPC propagation tests**: Extension A sends `Confidential` data to Extension B via IPC; Extension B's subsequent hostcalls carry the `Confidential` label. Extension B attempts to send that data to a `Public` sink; verify it is blocked.\n- **Performance tests**: Benchmark flow-label checking overhead; assert < 500ns per hostcall.\n- **Integration tests**: Full pipeline: extension makes hostcalls with various labels, some pass, some are blocked. Verify Guardplane receives flow violations as evidence and adjusts posterior accordingly.\n- **Edge case tests**: Default label for unlabeled data (should be maximally restrictive: `TopSecret`/`Untrusted`). Label for system-generated data (should be `Public`/`Trusted`).\n\n## Implementation Notes\n- The `Labeled<T>` wrapper should be zero-cost when the label is statically known (use generics with const labels where possible).\n- Flow-label checking is a simple comparison in the partial order; implement as integer comparison on the ordinal values for performance.\n- The lattice configuration should be loadable from a policy file to support custom secrecy/integrity levels per deployment.\n- Integration point: the telemetry recorder (bd-5pk) already has a `flow_label` field in `HostcallTelemetryRecord`; this bead populates that field.\n- The IPC label propagation requires cooperation with the IPC subsystem (10.4 module surface); define a trait interface that the IPC layer implements.\n\n## Dependencies\n- **Blocked by**: bd-5pk (telemetry records flow violations), 10.2 (IFC flow-lattice defines the lattice structure; this bead uses it at runtime).\n- **Blocks**: bd-3jy (declassification is the controlled way to change flow labels), bd-375 (delegate cells must have flow-label enforcement).\n- **Parent**: bd-1yq (10.5 epic).","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.948569696Z","created_by":"ubuntu","updated_at":"2026-02-20T07:53:00.082359631Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"]}
{"id":"bd-1i2","title":"[10.11] Define canonical runtime capability profiles (`FullCaps`, `EngineCoreCaps`, `PolicyCaps`, `RemoteCaps`, `ComputeOnlyCaps`) and enforce them at API boundaries.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Define canonical runtime capability profiles (`FullCaps`, `EngineCoreCaps`, `PolicyCaps`, `RemoteCaps`, `ComputeOnlyCaps`) and enforce them at API boundaries.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:33.274990242Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.275266068Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-1if","title":"[10.11] Implement saga orchestrator for multi-step publish/evict/quarantine workflows with deterministic compensation.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement saga orchestrator for multi-step publish/evict/quarantine workflows with deterministic compensation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.695088308Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.324806030Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-1ilz","title":"[10.15] Add frankensqlite-backed lineage/evidence index for replacement receipts and deterministic replay joins.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankensqlite-backed lineage/evidence index for replacement receipts and deterministic replay joins.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:54.922121006Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.366218074Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-1jak","title":"[15] Ecosystem Capture Strategy - Comprehensive Execution Epic","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nPurpose: Operationalize this section's governance/validation/adoption requirements into enforceable engineering work.\nQuality requirements for all children:\n- explicit acceptance criteria and failure semantics\n- unit-test and e2e/integration verification expectations\n- detailed structured logging and reproducibility artifacts where applicable\n- traceability back to category-level goals (security, performance, explainability, adoption)","status":"closed","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:15.651360044Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:56.223095292Z","closed_at":"2026-02-20T07:45:28.073792137Z","close_reason":"Replaced by consolidated ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-15"],"dependencies":[{"issue_id":"bd-1jak","depends_on_id":"bd-1tsf","type":"blocks","created_at":"2026-02-20T07:34:38.106582763Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1jak","depends_on_id":"bd-1wqa","type":"parent-child","created_at":"2026-02-20T07:52:46.028067023Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1jak","depends_on_id":"bd-21ds","type":"blocks","created_at":"2026-02-20T07:34:38.692410684Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1jak","depends_on_id":"bd-2r0c","type":"parent-child","created_at":"2026-02-20T07:52:49.152308098Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1jak","depends_on_id":"bd-2wft","type":"parent-child","created_at":"2026-02-20T07:52:50.025196896Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1jak","depends_on_id":"bd-2x4b","type":"parent-child","created_at":"2026-02-20T07:52:50.144785140Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1jak","depends_on_id":"bd-395m","type":"blocks","created_at":"2026-02-20T07:34:38.595172120Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1jak","depends_on_id":"bd-3j5s","type":"parent-child","created_at":"2026-02-20T07:52:52.479836766Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1jak","depends_on_id":"bd-3qhv","type":"parent-child","created_at":"2026-02-20T07:52:53.420387481Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1jak","depends_on_id":"bd-iqrn","type":"parent-child","created_at":"2026-02-20T07:52:55.859741531Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1jak","depends_on_id":"bd-mrf8","type":"parent-child","created_at":"2026-02-20T07:52:56.223008560Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1jqt","title":"[10.15] Add frankentui operator surfaces for proof-specialization lineage (`proof ids`, `activated specializations`, `invalidations`, `fallback events`).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankentui operator surfaces for proof-specialization lineage (`proof ids`, `activated specializations`, `invalidations`, `fallback events`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:53.209298162Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.448922639Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-1k5f","title":"[13] proof-carrying optimization path is enabled by default for at least one high-impact optimization family","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: proof-carrying optimization path is enabled by default for at least one high-impact optimization family\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:23.232379459Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.490629983Z","closed_at":"2026-02-20T07:39:58.984722894Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-1k7","title":"[10.2] Implement closure and lexical scope model.","description":"## Plan Reference\nSection 10.2, item 11. Cross-refs: 9I.7 (IFC flow-label propagation through scope chains), 9F.4 (Capability-Typed TS Execution), Phase A exit gate.\n\n## What\nImplement the closure and lexical scope model for ES2020, including lexical scoping, closures, block scope (let/const), hoisting, the scope chain, and the interaction between scope semantics and IFC flow analysis.\n\n## Detailed Requirements\n- Lexical scoping: function scope, block scope (let/const/class), global scope, module scope\n- Closures: functions capture their enclosing lexical environment by reference; captured variables remain live as long as the closure exists\n- Block scoping: let and const declarations are block-scoped with temporal dead zone (TDZ) enforcement\n- Hoisting: var declarations hoisted to function scope, function declarations hoisted to function scope with initialization, let/const/class enter TDZ\n- Scope chain: variable lookup traverses enclosing scopes in lexical order\n- with statement: creates a dynamic scope entry (rare but must be supported for full ES2020)\n- eval: direct eval runs in the calling scope, indirect eval runs in global scope\n- arguments object: mapped arguments for sloppy-mode functions, unmapped for strict mode\n- IFC integration: scope chain traversal must propagate IFC flow labels - when a closure captures a variable labeled with a sensitivity class, the label flows with the captured reference (per 9I.7)\n\n## Rationale\nClosures and lexical scope are foundational to JavaScript semantics. Nearly every non-trivial extension uses closures. Block scoping with TDZ is critical for correctness with modern JS patterns (let/const). The IFC connection is architecturally important: data sensitivity labels must flow through scope chains. If a closure captures a variable carrying a 'credentials' label, any function that invokes that closure and reads the captured value must inherit the label. Without this, IFC flow analysis has a scope-chain-shaped hole that attackers could exploit.\n\n## Testing Requirements\n- Unit tests: lexical scoping - variable shadowing across nested functions\n- Unit tests: closure captures - verify captured variables reflect mutations in enclosing scope\n- Unit tests: block scope - let/const TDZ throws ReferenceError before declaration\n- Unit tests: hoisting - var vs let/const vs function declaration behavior\n- Unit tests: scope chain traversal across multiple nesting levels\n- Unit tests: eval in direct and indirect modes\n- Unit tests: arguments object (mapped vs unmapped)\n- Unit tests: IFC label propagation through closure captures\n- Conformance: test262 language/statements/let, language/statements/const, language/expressions/function, language/statements/with\n- Edge cases: closure over loop variables (let in for-loop), mutual recursion through closures, deeply nested closures\n\n## Implementation Notes\n- Environment records should be arena-allocated (per 9B.1 recommendation)\n- Consider environment record types: declarative, object (for with), function, global, module\n- Closure representation: function code reference + captured environment chain\n- TDZ enforcement: mark bindings as uninitialized until declaration is evaluated\n- IFC label propagation: environment records carry label metadata that joins on capture\n\n## Dependencies\n- Blocked by: baseline interpreter skeleton (bd-2f8), ES2020 object semantics (bd-1m9) for scope objects\n- Blocks: Phase A exit gate conformance, IFC flow-check accuracy (bd-3jg) for scope-aware flow analysis","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.711931209Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.532439427Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"]}
{"id":"bd-1kd2","title":"[13] control-plane identifiers and capability context are canonicalized through asupersync-derived types (no competing local forks)","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: control-plane identifiers and capability context are canonicalized through asupersync-derived types (no competing local forks)\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:21.084427599Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.576623233Z","closed_at":"2026-02-20T07:40:00.000271547Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-1kdc","title":"[10.15] Implement deterministic shadow ablation engine that tests capability subtraction candidates against correctness and risk invariants.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement deterministic shadow ablation engine that tests capability subtraction candidates against correctness and risk invariants.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:50.135558141Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.617819866Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-1ko5","title":"[13] 100% of capability escrow/emergency-grant decisions emit receipt-linked replay artifacts with explicit expiry and operator rationale","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: 100% of capability escrow/emergency-grant decisions emit receipt-linked replay artifacts with explicit expiry and operator rationale\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:25.695732732Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.658806728Z","closed_at":"2026-02-20T07:39:57.888748945Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-1kzo","title":"[10.15] Add compiler policy that only proof-grounded specializations may bypass capability/flow dynamic checks in marked regions.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add compiler policy that only proof-grounded specializations may bypass capability/flow dynamic checks in marked regions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:53.032092674Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.699746732Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-1lp","title":"[10.10] Implement append-only hash-linked audit chain with `correlation_id` and optional full trace context.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement append-only hash-linked audit chain with `correlation_id` and optional full trace context.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.404729302Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.740728775Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-1m9","title":"[10.2] Implement complete ES2020 object/prototype semantics (no permanent subset scope).","description":"## Plan Reference\nSection 10.2, item 10. Cross-refs: 9A.1 (TS-first authoring with native execution), 9F.4 (Capability-Typed TS Execution Contract), Phase A exit gate (native execution lanes pass baseline conformance), Section 2 (no permanent subset scope).\n\n## What\nImplement complete ES2020 object and prototype semantics including the full object model with prototypes, property descriptors, Proxy, Reflect, and all associated internal methods. The plan explicitly requires 'no permanent subset scope' - every ES2020 object-model feature must be implemented, not approximated.\n\n## Detailed Requirements\n- Full prototype chain: Object.create, Object.getPrototypeOf, Object.setPrototypeOf, prototype-based inheritance\n- Property descriptors: Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptor, accessor properties (get/set), configurable/enumerable/writable attributes\n- Proxy and Reflect: all 13 Proxy trap handlers (get, set, has, deleteProperty, ownKeys, apply, construct, getPrototypeOf, setPrototypeOf, isExtensible, preventExtensions, defineProperty, getOwnPropertyDescriptor) with full invariant checking per ES2020 spec\n- Internal methods: [[Get]], [[Set]], [[HasProperty]], [[Delete]], [[OwnPropertyKeys]], [[Call]], [[Construct]] with correct ordinary and exotic object behavior\n- Object.keys, Object.values, Object.entries, Object.assign, Object.freeze, Object.seal, Object.is\n- Symbol-keyed properties and well-known symbols (Symbol.iterator, Symbol.toPrimitive, Symbol.hasInstance, etc.)\n- for...in enumeration order per ES2020 spec\n- No permanent subset scope: every feature must be implemented or explicitly tracked as in-progress with a convergence date, never silently omitted\n\n## Rationale\nThe plan (Section 2) states there is 'no permanent subset scope' for ES2020 semantics. This is a hard requirement because extensions in the VS Code ecosystem depend on the full ES2020 object model. Proxy and Reflect are particularly critical because many popular extension frameworks (Vue, MobX) use them extensively. Incomplete object semantics would cause silent behavioral divergence that is extremely difficult to diagnose and would undermine trust in the runtime. The Phase A exit gate requires baseline conformance, which means full object semantics must be correct before any optimization work begins.\n\n## Testing Requirements\n- Unit tests: prototype chain traversal, property lookup, property descriptor operations\n- Unit tests: Proxy trap invocation for all 13 handlers with correct argument passing\n- Unit tests: Proxy invariant checking (e.g., non-configurable property cannot be reported as non-existent)\n- Unit tests: Reflect methods mirror corresponding Object operations\n- Unit tests: Symbol-keyed property access and well-known symbol behavior\n- Conformance: test262 built-ins/Object, built-ins/Proxy, built-ins/Reflect, built-ins/Symbol test suites\n- Edge cases: Proxy wrapping Proxy, revocable Proxy, frozen objects through Proxy, exotic objects (arrays, strings, arguments)\n- Determinism: object operations produce identical results across both execution lanes\n\n## Implementation Notes\n- Implement in crates/franken-engine as core object model module\n- Object representation should support efficient property lookup (hidden class / shape transition approach)\n- Proxy implementation must be correct-first, optimize-later - Proxy invariant checking is subtle and spec-critical\n- Property descriptor storage should distinguish data vs accessor descriptors efficiently\n- Symbol registry for well-known symbols should be initialized at engine startup\n- This module is exercised by virtually all other ES2020 features, so correctness here is load-bearing\n\n## Dependencies\n- Blocked by: baseline interpreter skeleton (bd-2f8) for execution context\n- Blocks: Phase A exit gate conformance, closure/scope model (bd-1k7) for scope objects, Promise semantics (bd-o8v) for thenable resolution","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.582533523Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.781727148Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"]}
{"id":"bd-1md2","title":"[12] Prevent unsound specialization from stale proofs via epoch validity and fail-closed invalidation","description":"Plan Reference: section 12 (Risk Register).\nObjective: Stale/invalid security proofs causing unsound specialization:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:18.794629093Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.822621828Z","closed_at":"2026-02-20T07:39:04.430895137Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"]}
{"id":"bd-1n78","title":"[10.15] Define advanced conformance-lab contract catalog (semantic version classes, failure taxonomy, replay obligations) extending `10.14` baseline boundary tests.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define advanced conformance-lab contract catalog (semantic version classes, failure taxonomy, replay obligations) extending `10.14` baseline boundary tests.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:48.809108898Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.864460196Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-1nh","title":"[10.12] Build deterministic causal replay engine with counterfactual branching over policy/action parameters.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Build deterministic causal replay engine with counterfactual branching over policy/action parameters.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.177747192Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.905430447Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-1nn","title":"[10.6] Add flamegraph pipeline and artifact storage.","description":"## Plan Reference\nSection 10.6, item 3. Cross-refs: 9D (extreme-software-optimization - profile top-5 hotspots), 9F.14 (Autopilot Performance Scientist).\n\n## What\nAdd a flamegraph pipeline that captures, stores, and makes accessible CPU/allocation flamegraphs for benchmark runs and production profiles.\n\n## Detailed Requirements\n- Automated flamegraph generation for benchmark suite runs\n- Artifact storage: flamegraphs stored as reproducible artifacts with metadata (workload, config, commit, timestamp)\n- Both CPU flamegraphs (hotspot identification) and allocation flamegraphs (allocation-heavy path identification)\n- Diff flamegraphs: compare before/after optimization to visualize impact\n- Integration with evidence graph: flamegraph artifacts linked to benchmark runs and optimization decisions\n- Storage via frankensqlite (per 10.14) for structured retrieval\n\n## Rationale\nThe plan's extreme-software-optimization discipline (9D) requires: 'Baseline first, profile top-5 hotspots before changes.' Flamegraphs are the standard tool for hotspot identification. Without automated capture and storage, profiling becomes ad-hoc and optimization decisions lose evidence backing. The Autopilot Performance Scientist (9F.14) needs flamegraph data as input for VOI-based experiment selection.\n\n## Testing Requirements\n- Integration test: run benchmark, verify flamegraph artifact is generated\n- Test: flamegraph artifact contains valid SVG/folded-stack data\n- Test: diff flamegraph between two runs shows expected changes\n- Test: flamegraph metadata is complete and queryable\n\n## Dependencies\n- Blocked by: benchmark suite (bd-2ql)\n- Blocks: opportunity matrix scoring (bd-js4), one-lever policy (bd-2l6)","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:25.482572624Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.946239758Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-6"]}
{"id":"bd-1npj","title":"[14] A public `>= 3x` claim is valid only if:","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: A public `>= 3x` claim is valid only if:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:30.918588910Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:29.987748111Z","closed_at":"2026-02-20T07:41:20.617789294Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-1o2","title":"[10.12] Implement security-proof ingestion path for optimizer hypotheses (PLAS witnesses, IFC flow proofs, replay sequence motifs).","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement security-proof ingestion path for optimizer hypotheses (PLAS witnesses, IFC flow proofs, replay sequence motifs).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:38.537631360Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.028150024Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-1o7u","title":"[10.13] Integrate `frankenlab` scenarios for extension lifecycle and containment paths (startup, normal shutdown, forced cancel, quarantine, revocation, degraded mode).","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Integrate `frankenlab` scenarios for extension lifecycle and containment paths (startup, normal shutdown, forced cancel, quarantine, revocation, degraded mode).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:43.435115096Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.069324355Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-1of","title":"[10.0] Top 10 Initiative Tracking (Canonical Implementation Index) - Comprehensive Execution Epic","description":"## Plan Reference\nSection 10.0: Top 10 Initiative Tracking (Canonical Implementation Index)\n\n## Overview\nThis epic is the strategic index mapping the 10 adopted initiatives (9A) to their execution tracks. It is a governance/tracking artifact, not an implementation track itself. Each Top-10 initiative has a canonical owner section and execution owners in 10.x tracks.\n\n## Canonical Anti-Drift Contract (from plan)\n- 9A is the strategic Top-10 index (program intent and ordering)\n- 9F and 9I hold deep capability semantics and moonshot-level rationale\n- 10.x sections are the executable ownership surface for implementation\n- Precedence: 10.x execution contracts > 9F/9I capability semantics > 9A strategic framing\n- Any new capability must be added once as canonical owner, then referenced by mappings; no parallel implementation obligations\n\n## Child Beads (Initiative Tracking)\n- bd-20c: #1 TS-first capability-typed IR execution → 10.2, 10.5, 10.12\n- bd-3uk: #2 Probabilistic Guardplane → 10.5, 10.11, 10.12\n- bd-1to: #3 Deterministic evidence graph + replay → 10.5, 10.11, 10.12, 10.13\n- bd-3g4: #4 Alien-performance profile discipline → 10.6, 10.12\n- bd-3hj: #5 Supply-chain trust fabric → 10.10, 10.12, 10.13\n- bd-1cu: #6 Shadow-run + differential executor → 10.7, 10.12\n- bd-ttd: #7 Capability lattice + typed policy DSL → 10.5, 10.10, 10.12, 10.13\n- bd-1fa: #8 Deterministic resource budgets → 10.11, 10.12, 10.13\n- bd-3zj: #9 Adversarial security corpus + fuzzing → 10.7, 10.12\n- bd-3mx: #10 Provenance + revocation fabric → 10.10, 10.11, 10.12, 10.13\n\n## Recommended Staged Order\n1. TS-first IR execution, 2. Probabilistic Guardplane, 3. Evidence graph + replay, 4. Shadow-run + differential, 5. Resource budgets, 6. Capability lattice, 7. Adversarial corpus, 8. Supply-chain trust, 9. Provenance + revocation, 10. Alien-performance (continuous)","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.172859330Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:56.670297960Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-0"],"dependencies":[{"issue_id":"bd-1of","depends_on_id":"bd-1cu","type":"parent-child","created_at":"2026-02-20T07:52:43.719825917Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1of","depends_on_id":"bd-1fa","type":"parent-child","created_at":"2026-02-20T07:52:43.999300364Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1of","depends_on_id":"bd-1to","type":"parent-child","created_at":"2026-02-20T07:52:45.740945513Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1of","depends_on_id":"bd-20c","type":"parent-child","created_at":"2026-02-20T07:52:46.436874636Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1of","depends_on_id":"bd-3g4","type":"parent-child","created_at":"2026-02-20T07:52:52.203046989Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1of","depends_on_id":"bd-3hj","type":"parent-child","created_at":"2026-02-20T07:52:52.362000284Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1of","depends_on_id":"bd-3mx","type":"parent-child","created_at":"2026-02-20T07:52:52.916796195Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1of","depends_on_id":"bd-3uk","type":"parent-child","created_at":"2026-02-20T07:52:54.143835532Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1of","depends_on_id":"bd-3vh","type":"blocks","created_at":"2026-02-20T07:32:55.259844237Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1of","depends_on_id":"bd-3zj","type":"parent-child","created_at":"2026-02-20T07:52:54.422009367Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1of","depends_on_id":"bd-ttd","type":"parent-child","created_at":"2026-02-20T07:52:56.670223281Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1ovk","title":"[10.15] Define IFC artifacts (`flow_policy`, `flow_proof`, `declassification_receipt`, `confinement_claim`) with deterministic encoding and signature requirements.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define IFC artifacts (`flow_policy`, `flow_proof`, `declassification_receipt`, `confinement_claim`) with deterministic encoding and signature requirements.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:52.166154216Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.152021826Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-1p4","title":"[10.10] Add activation/update/rollback contract: sandbox setup, ephemeral secret injection, staged rollout, crash-loop auto-rollback, known-good pinning.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Add activation/update/rollback contract: sandbox setup, ephemeral secret injection, staged rollout, crash-loop auto-rollback, known-good pinning.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.979638185Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.193141756Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-1pqn","title":"[14] Each case must publish: throughput, `p50/p95/p99` latency, allocation/peak memory, correctness digest, and security-event envelope.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Each case must publish: throughput, `p50/p95/p99` latency, allocation/peak memory, correctness digest, and security-event envelope.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:29.214797229Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.234232622Z","closed_at":"2026-02-20T07:41:21.324671499Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-1ps3","title":"[10.14] Inventory every current/planned local persistence need (replay index, evidence index, benchmark ledger, policy artifact cache) and map each to a `frankensqlite` integration point.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Inventory every current/planned local persistence need (replay index, evidence index, benchmark ledger, policy artifact cache) and map each to a `frankensqlite` integration point.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:45.381757842Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.275033998Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-1qgn","title":"[10.14] Add CI/policy guard preventing new local interactive TUI frameworks in `franken_engine` without explicit ADR exception.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add CI/policy guard preventing new local interactive TUI frameworks in `franken_engine` without explicit ADR exception.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:45.058058734Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.315732352Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-1qj6","title":"[13] GA default lanes run with zero mandatory delegate cells for core runtime slots","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: GA default lanes run with zero mandatory delegate cells for core runtime slots\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:27.343725828Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.356649985Z","closed_at":"2026-02-20T07:39:57.192430577Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-1r25","title":"[10.15] Extend receipt schema to include attestation bindings (`quote_digest`, `measurement_id`, `attested_signer_key_id`, `nonce`, `validity_window`).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Extend receipt schema to include attestation bindings (`quote_digest`, `measurement_id`, `attested_signer_key_id`, `nonce`, `validity_window`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.170176448Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.397620907Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-1rdj","title":"[10.13] Add benchmark split showing control-plane overhead remains bounded while VM hot-loop performance remains decoupled.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add benchmark split showing control-plane overhead remains bounded while VM hot-loop performance remains decoupled.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:44.251207526Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.438684743Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-1rju","title":"[13] privacy-preserving fleet learning operates continuously with zero budget-overrun incidents and measurable calibration/drift-improvement over local-only baselines","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: privacy-preserving fleet learning operates continuously with zero budget-overrun incidents and measurable calibration/drift-improvement over local-only baselines\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:24.095118828Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.483645416Z","closed_at":"2026-02-20T07:39:58.585156720Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-1si","title":"[10.11] Implement `PolicyController` service for non-correctness knobs with explicit action sets and loss matrices.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement `PolicyController` service for non-correctness knobs with explicit action sets and loss matrices.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.080674328Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.524540587Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-1to","title":"[10.0] Top-10 #3: Deterministic evidence graph + replay tooling (strategy: `9A.3`; deep semantics: `9F.3`; execution owners: `10.5`, `10.11`, `10.12`, `10.13`).","description":"## Plan Reference\nSection 10.0 item 3. Strategy: 9A.3. Deep semantics: 9F.3 (Deterministic Time-Travel + Counterfactual Replay). Enhancement maps: 9B.3 (hindsight logging, deterministic simulation), 9C.3 (Bayes-factor decomposition, counterfactual action report), 9D.3 (replay throughput profiling).\n\n## What\nStrategic tracking bead for Initiative #3: Deterministic evidence graph + replay for all security/performance decisions. Every meaningful decision is recorded as linked artifacts with deterministic replay support.\n\n## Execution Owners\n- **10.5** (Extension Host): forensic replay tooling, decision receipt emission\n- **10.11** (Runtime Systems): evidence-ledger schema, deterministic ordering/stability, decision marker stream, lab runtime harness\n- **10.12** (Frontier Programs): causal replay engine with counterfactual branching, incident replay artifact bundle\n- **10.13** (Asupersync Integration): Cx threading, evidence replay checks, frankenlab scenarios\n\n## Strategic Rationale (from 9A.3)\n'Strong guarantees require explainability and post-incident forensics; otherwise both security and optimization claims are fragile.'\n\n## Key Deliverables\n- Every decision recorded as: claim → evidence → policy → action with trace_id, policy_id, decision_id\n- Deterministic replay: identical re-execution from fixed artifacts\n- Counterfactual branching: simulate alternate decisions from same evidence\n- Bayes-factor decomposition showing which evidence terms moved decisions","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:19.488373355Z","created_by":"ubuntu","updated_at":"2026-02-20T07:53:26.672314235Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"]}
{"id":"bd-1tsf","title":"[MASTER] Execute PLAN 10.x end-to-end with full dependency graph","description":"Master orchestration epic for the full program-level TODO decomposition.\nThis bead represents complete execution of sections 10.0-10.15 with explicit dependency graphing, quality gates, and verification obligations.\nProgram invariants:\n- Preserve ambition-first doctrine and category-defining capability goals.\n- No scope collapse, no hidden compatibility shims, no proof-free claims.\n- Every stream must include unit tests, e2e/integration tests, and high-fidelity logging.\n- Every high-impact capability must carry reproducible/evidence-backed outputs.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":2,"issue_type":"epic","created_at":"2026-02-20T07:32:58.319192260Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:57.251142719Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["master","plan","section-10"],"dependencies":[{"issue_id":"bd-1tsf","depends_on_id":"bd-1of","type":"parent-child","created_at":"2026-02-20T07:52:45.297020570Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-1xm","type":"parent-child","created_at":"2026-02-20T07:52:46.069582209Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-1yq","type":"parent-child","created_at":"2026-02-20T07:52:46.229906078Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:52:47.936124621Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-2mf","type":"parent-child","created_at":"2026-02-20T07:52:48.551326813Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:52:49.191973248Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-32r","type":"parent-child","created_at":"2026-02-20T07:52:50.857762408Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-02-20T07:52:51.386858019Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-3ch","type":"parent-child","created_at":"2026-02-20T07:52:51.824763049Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:52:53.074950983Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:52:53.341741746Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:52:54.223445664Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-3vk","type":"parent-child","created_at":"2026-02-20T07:52:54.262939224Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:52:56.303992150Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tsf","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:52:57.251096102Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1tw4","title":"[13] cross-repo conformance lab pass rate is a hard release gate for shared-boundary changes, with deterministic repro artifacts for every failure class","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: cross-repo conformance lab pass rate is a hard release gate for shared-boundary changes, with deterministic repro artifacts for every failure class\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:24.533929503Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.647633048Z","closed_at":"2026-02-20T07:39:58.383051082Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-1ukb","title":"[10.13] Integrate region-per-extension/session execution cells with quiescent close guarantees using primitives owned by `10.11`.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Integrate region-per-extension/session execution cells with quiescent close guarantees using primitives owned by `10.11`.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:42.479483918Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.688640759Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-1v5","title":"[10.11] Implement epoch transition barrier across core services to prevent mixed-epoch critical operations.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement epoch transition barrier across core services to prevent mixed-epoch critical operations.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.963158175Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.729251931Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-1v90","title":"[10.15] Extend PLAS synthesis to emit minimal flow envelopes in addition to capability envelopes.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Extend PLAS synthesis to emit minimal flow envelopes in addition to capability envelopes.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:52.675050458Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.770136913Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-1wa","title":"[10.2] Define multi-level IR contract (`IR0`/`IR1`/`IR2`/`IR3`/`IR4`) including canonical serialization/hash invariants.","description":"## Plan Reference\nSection 10.2, item 2. Cross-refs: 9A.1, 9B.1 (typestate/session types/algebraic effects), 9C.1 (proof-carrying compilation), 9F.4 (capability-typed TS execution), 9I.7 (IFC flow labels in IR2), 9I.8 (proof-to-specialization linkage in IR3/IR4).\n\n## What\nDefine the complete multi-level Intermediate Representation contract spanning five levels:\n- **IR0 (SyntaxIR)**: Direct AST output from parser, structurally canonical\n- **IR1 (SpecIR)**: Spec-level semantic representation, scope/binding resolved\n- **IR2 (CapabilityIR)**: Annotated with capability intent, effect boundaries, and IFC flow labels\n- **IR3 (ExecIR)**: Execution-ready form with proof-to-specialization linkage\n- **IR4 (WitnessIR)**: Post-execution witness artifacts for replay and audit\n\nEach level must define canonical serialization format and hash computation for deterministic replay and evidence linkage.\n\n## Detailed Requirements\n- Each IR level must have a defined Rust type hierarchy with serde support\n- Canonical serialization: deterministic byte output for identical semantic content (field ordering, normalization rules)\n- Hash invariants: content-addressed hashing at each level for evidence graph linkage\n- IR2 must carry: capability annotations per Section 9F.4, IFC flow labels per Section 9I.7 (label classes, clearance classes, declassification obligations)\n- IR3 must carry: proof-to-specialization linkage per Section 9I.8 (proof_input_ids, optimization_class, validity_epoch, rollback_token)\n- IR4 must carry: execution witness data for replay determinism and forensic audit\n- Version schema for IR formats to support migration (per Section 9E.10)\n\n## Rationale\nThe IR stack is the architectural spine of FrankenEngine. The plan explicitly requires that capability intent, effect boundaries, and host interaction metadata flow through compilation (9A.1). The proof-carrying compilation contract (9C.1) requires each lowering stage to emit invariants and machine-checkable witnesses. Without canonical serialization/hash invariants, evidence graph linkage (9A.3) and deterministic replay (9F.3) are impossible.\n\n## Testing Requirements\n- Unit tests: construct IR at each level, verify canonical serialization produces deterministic bytes\n- Unit tests: verify hash computation is stable across identical IR instances\n- Unit tests: verify IR2 capability annotations are preserved through serialization round-trip\n- Unit tests: verify IR3 proof linkage fields are present and correctly typed\n- Property tests: IR serialization round-trip preserves all semantic content\n- Migration tests: versioned IR can be deserialized by both current and next version\n\n## Implementation Notes\n- Define in crates/franken-engine as core IR types module\n- Use serde with deterministic field ordering (BTreeMap not HashMap for any map fields)\n- Consider content-addressed storage design from the start\n- IR0→IR1→IR2→IR3 forms a lowering pipeline; IR4 is emitted post-execution\n- Each level should have a From/TryFrom relationship to the next lower level\n\n## Dependencies\n- Blocked by: parser trait (bd-crp) for IR0 design\n- Blocks: lowering pipelines (bd-ug9), IFC flow-lattice (bd-1fm), proof-to-specialization linkage (bd-161), flow-check pass (bd-3jg)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.542756438Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.811701180Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"]}
{"id":"bd-1wqa","title":"[15] Partner program for early lighthouse adopters who validate category-shift outcomes in production.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Partner program for early lighthouse adopters who validate category-shift outcomes in production.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:35.214302597Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.856268871Z","closed_at":"2026-02-20T07:45:44.082252545Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"]}
{"id":"bd-1xm","title":"[10.9] Moonshot Disruption Track - Comprehensive Execution Epic","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.753842457Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:56.870395100Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-9"],"dependencies":[{"issue_id":"bd-1xm","depends_on_id":"bd-12m","type":"blocks","created_at":"2026-02-20T07:32:56.483603902Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-181","type":"parent-child","created_at":"2026-02-20T07:52:43.186494998Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-1ze","type":"parent-child","created_at":"2026-02-20T07:52:46.310988932Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-2n3","type":"parent-child","created_at":"2026-02-20T07:52:48.630294618Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-2r6","type":"blocks","created_at":"2026-02-20T07:32:56.660166432Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-2rx","type":"parent-child","created_at":"2026-02-20T07:52:49.310701471Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-383","type":"blocks","created_at":"2026-02-20T07:32:56.573703198Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-3q9","type":"blocks","created_at":"2026-02-20T07:32:56.746329536Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-3rd","type":"parent-child","created_at":"2026-02-20T07:52:53.582071583Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-6pk","type":"parent-child","created_at":"2026-02-20T07:52:54.701992863Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-dkh","type":"parent-child","created_at":"2026-02-20T07:52:55.436807947Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-eke","type":"parent-child","created_at":"2026-02-20T07:52:55.519009775Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-f7n","type":"parent-child","created_at":"2026-02-20T07:52:55.669707965Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-uwc","type":"parent-child","created_at":"2026-02-20T07:52:56.870320220Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1xva","title":"[14] Maintain a neutral verifier mode so third parties can run and validate claims.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Maintain a neutral verifier mode so third parties can run and validate claims.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:28.276857375Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.938939413Z","closed_at":"2026-02-20T07:41:21.720302844Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-1y5","title":"[10.5] Implement expected-loss action selector.","description":"## Plan Reference\nSection 10.5, item 5 (Implement expected-loss action selector). Cross-refs: 9C.2 (explicit expected-loss matrices in the full Bayesian decision loop), 9A.2 (Probabilistic Guardplane action selection), 9F.5 (cryptographic decision receipts for every action taken).\n\n## What\nImplement the \"decide\" stage of the 9C.2 Bayesian decision loop. Given a posterior distribution over extension risk states (from bd-3md) and an explicit loss matrix quantifying the cost of each (action, true-state) pair, the expected-loss action selector computes the expected loss for every candidate action and selects the action with minimum expected loss. Actions include: `Allow`, `Challenge`, `Sandbox`, `Suspend`, `Terminate`, `Quarantine`. The selector also produces a decision explanation (the \"explain\" stage of 9C.2) that records which posterior, which loss matrix, and which expected-loss values led to the chosen action -- this explanation is the basis for the cryptographic decision receipt (9F.5).\n\n## Detailed Requirements\n- Define `ContainmentAction` enum: `Allow`, `Challenge`, `Sandbox`, `Suspend`, `Terminate`, `Quarantine`.\n- Define `LossMatrix` as a mapping from `(ContainmentAction, RiskState) -> f64`. The matrix must be explicitly configured, never hardcoded. Provide a default matrix based on plan guidance.\n- Default loss matrix values (configurable):\n  - `(Allow, Benign) = 0.0` (correct: no cost)\n  - `(Allow, Malicious) = 100.0` (catastrophic: letting malicious code run)\n  - `(Terminate, Benign) = 10.0` (bad: killing a good extension)\n  - `(Terminate, Malicious) = 0.5` (minor: cleanup cost of terminating malicious code)\n  - Fill all 6x4 = 24 cells with principled defaults.\n- Implement `ExpectedLossSelector` with methods:\n  - `new(loss_matrix: LossMatrix) -> Self`\n  - `select(&self, posterior: &Posterior) -> ActionDecision` - compute expected loss for each action, return the action with minimum expected loss.\n  - `expected_losses(&self, posterior: &Posterior) -> BTreeMap<ContainmentAction, f64>` - return all expected losses for transparency.\n- `ActionDecision` struct: `{ action: ContainmentAction, expected_loss: f64, runner_up_action: ContainmentAction, runner_up_loss: f64, explanation: DecisionExplanation }`.\n- `DecisionExplanation` struct: `{ posterior_snapshot: Posterior, loss_matrix_id: String, all_expected_losses: BTreeMap<ContainmentAction, f64>, margin: f64 }` where margin = runner_up_loss - selected_loss.\n- The selector must be deterministic: identical posterior + loss matrix always produces identical action selection.\n- When two actions have identical expected loss, break ties by action severity (prefer less severe action).\n- Emit a structured `SecurityDecisionEvent` to telemetry for every selection.\n\n## Rationale\nRule-based security systems use fixed thresholds (e.g., \"if score > 0.9, terminate\"). This is fragile because it ignores the asymmetric costs of different errors. A false positive (terminating a benign extension) has a very different cost from a false negative (allowing a malicious extension to run). The expected-loss framework from 9C.2 makes these tradeoffs explicit and configurable per deployment. The decision explanation enables audit, debugging, and the cryptographic decision receipt (9F.5) that proves every security action was justified by evidence and a well-defined decision procedure.\n\n## Testing Requirements\n- **Unit tests**: Compute expected loss for a known posterior and loss matrix; verify arithmetic. Test that `P(Malicious) = 1.0` selects `Terminate`. Test that `P(Benign) = 1.0` selects `Allow`. Test tie-breaking favors less severe action. Test that changing the loss matrix changes the decision boundary.\n- **Boundary tests**: Posterior at exact decision boundaries (where two actions have nearly equal expected loss). Verify consistent tie-breaking.\n- **Explanation tests**: Verify `DecisionExplanation` contains correct posterior snapshot, all expected losses, and correct margin calculation.\n- **Property tests**: For any valid posterior (probabilities sum to 1.0) and any valid loss matrix (non-negative), the selector always returns a valid action. Expected loss of selected action is always <= expected loss of every other action.\n- **Integration tests**: Wire posterior updater (bd-3md) to action selector; feed synthetic evidence and verify the correct sequence of actions is selected.\n\n## Implementation Notes\n- Expected loss for action `a` = sum over states `s` of `P(s) * Loss(a, s)`. This is a simple dot product per action.\n- The `LossMatrix` should be loadable from a configuration file (TOML or JSON) for operator customization.\n- Consider providing named loss matrix presets: \"conservative\" (high cost for false negatives), \"permissive\" (high cost for false positives), \"balanced\".\n- The `margin` field in `DecisionExplanation` is crucial for monitoring: a small margin indicates the decision was borderline and may flip with small evidence changes.\n\n## Dependencies\n- **Blocked by**: bd-3md (Bayesian posterior updater provides the posterior input).\n- **Blocks**: bd-2gl (containment actions execute the selected action), bd-t2m (forensic replay must reproduce decision trajectories), bd-3jy (declassification decision contracts reference the action selector).\n- **Parent**: bd-1yq (10.5 epic).","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.415330701Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:30.979639471Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"]}
{"id":"bd-1y63","title":"[14] Revocation/quarantine propagation (freshness lag distribution, convergence SLO attainment).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Revocation/quarantine propagation (freshness lag distribution, convergence SLO attainment).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:33.570962678Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.020438683Z","closed_at":"2026-02-20T07:41:19.476657150Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-1yq","title":"[10.5] Extension Host + Security - Comprehensive Execution Epic","description":"Plan Reference: section 10.5 (Extension Host + Security).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-02-20T07:32:18.494764838Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:56.990036784Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-5"],"dependencies":[{"issue_id":"bd-1yq","depends_on_id":"bd-1hu","type":"parent-child","created_at":"2026-02-20T07:52:44.354665285Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-1hw","type":"parent-child","created_at":"2026-02-20T07:52:44.395056838Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-1y5","type":"parent-child","created_at":"2026-02-20T07:52:46.149148840Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-2gl","type":"parent-child","created_at":"2026-02-20T07:52:48.057808368Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-375","type":"parent-child","created_at":"2026-02-20T07:52:51.219838289Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-3ch","type":"blocks","created_at":"2026-02-20T07:32:55.781092336Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-3jy","type":"parent-child","created_at":"2026-02-20T07:52:52.559259178Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-3md","type":"parent-child","created_at":"2026-02-20T07:52:52.837272524Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-3vh","type":"blocks","created_at":"2026-02-20T07:32:55.608087994Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-5pk","type":"parent-child","created_at":"2026-02-20T07:52:54.621790619Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-ntq","type":"blocks","created_at":"2026-02-20T07:32:55.695053523Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-t2m","type":"parent-child","created_at":"2026-02-20T07:52:56.587250736Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-xq7","type":"parent-child","created_at":"2026-02-20T07:52:56.989963517Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1za","title":"[10.11] Add compile-time ambient-authority audit gate for forbidden direct calls in engine security-critical modules.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add compile-time ambient-authority audit gate for forbidden direct calls in engine security-critical modules.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:33.438713877Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.101228301Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-1ze","title":"[10.9] Release gate: official Node/Bun comparison harness is delivered with reproducible benchmark artifacts and publishable methodology (implementation ownership: `10.12` + section `14`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: official Node/Bun comparison harness is delivered with reproducible benchmark artifacts and publishable methodology (implementation ownership: `10.12` + section `14`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:27.698421336Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.141833282Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"]}
{"id":"bd-2031","title":"[13] fleet quarantine convergence meets published SLOs under partition/fault injection drills","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: fleet quarantine convergence meets published SLOs under partition/fault injection drills\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:23.024374212Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.182439715Z","closed_at":"2026-02-20T07:39:59.083570947Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-20b","title":"[10.2] Define typed execution-slot registry and ABI contract for slot replacement (`slot_id`, semantic boundary, authority envelope, promotion status).","description":"## Plan Reference\nSection 10.2, item 7. Cross-refs: 9I.6 (Verified Self-Replacement Architecture), 10.15 (self-replacement schema, delegate-cell harness, promotion gates).\n\n## What\nDefine the typed execution-slot registry that enables the Verified Self-Replacement Architecture. Each slot is a replaceable runtime component that can run either native Rust cells or explicitly untrusted delegate cells.\n\n## Detailed Requirements\n- Define slot_id: unique identifier for each replaceable runtime component\n- Define semantic boundary: what each slot does (parser, IR lowering, optimizer, interpreter, hostcall dispatch, etc.)\n- Define authority envelope: what capabilities each slot requires and is permitted\n- Define promotion status: current state (delegate/native, promotion candidate, promoted, demoted)\n- ABI contract: deterministic interface between slot and runtime, so swapping implementations is seamless\n- Registry must track: current implementation digest, promotion lineage, rollback targets\n\n## Rationale\nSection 9I.6: 'Build the runtime as typed execution slots that can run either native Rust cells or explicitly untrusted delegate cells, then continuously replace delegates with native cells via cryptographically signed promotion gates until GA lanes are fully native.' This converts the hardest part of the program (full ES2020-native execution) into an incremental, evidence-backed convergence process. The slot registry is the foundation that makes this possible.\n\n## Testing Requirements\n- Unit tests: register slots, verify slot_id uniqueness\n- Unit tests: verify ABI contract compatibility between native and delegate implementations\n- Unit tests: verify promotion status transitions (delegate → candidate → promoted)\n- Unit tests: verify rollback from promoted back to previous implementation\n- Integration tests: swap slot implementation at runtime, verify behavior preservation\n\n## Dependencies\n- Blocked by: nothing (foundational design)\n- Blocks: interpreter skeleton (bd-2f8), delegate-cell harness (10.15), promotion gate runner (10.15)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.203314107Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.222739637Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"]}
{"id":"bd-20c","title":"[10.0] Top-10 #1: TS-first capability-typed IR execution (strategy: `9A.1`; deep semantics: `9F.4`; execution owners: `10.2`, `10.5`, `10.12`).","description":"## Plan Reference\nSection 10.0 item 1. Strategy: 9A.1. Deep semantics: 9F.4 (Capability-Typed TS Execution Contract). Enhancement maps: 9B.1 (typestate/session types/algebraic effects), 9C.1 (proof-carrying compilation), 9D.1 (compilation benchmark suite).\n\n## What\nStrategic tracking bead for Initiative #1: TS-first authoring → native capability-typed IR execution. Extension developers keep JS/TS ergonomics and ecosystem velocity, but execution moves onto a native IR that explicitly carries capability intent, effect boundaries, and host interaction metadata.\n\n## Execution Owners\n- **10.2** (VM Core): parser trait, multi-level IR contract (IR0-IR4), lowering pipelines, IFC flow-lattice in IR2, proof-to-specialization linkage in IR3/IR4\n- **10.5** (Extension Host + Security): runtime capability enforcement, flow-label propagation\n- **10.12** (Frontier Programs): proof-carrying adaptive optimizer, translation-validation gates\n\n## Strategic Rationale (from 9A.1)\n'This gives high contributor throughput without surrendering runtime control to opaque third-party engine behavior. The rationale is to preserve rapid iteration and broad contributor participation while making security and performance constraints enforceable by the runtime itself, not by conventions.'\n\n## Key Deliverables\n- Capability-typed IR with explicit effect annotations (fs.read, net.connect, proc.spawn, policy.request)\n- Capability lattice checks during lowering and optimization\n- Ambiguous authority paths and ambient side effects rejected before execution\n- Runtime verifies capability proofs and executes only within declared contracts\n\n## Phase Gates\n- Phase A: native execution lanes pass baseline conformance\n- Phase B: security subsystems (capability enforcement) active\n- Phase C: >= 3x performance with capability-typed execution","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:19.238167621Z","created_by":"ubuntu","updated_at":"2026-02-20T07:53:08.766409633Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"]}
{"id":"bd-20xc","title":"Build benchmark reproducibility infrastructure and third-party verification pipeline","description":"## Plan Reference\nSection 14.3: Reproducibility + Neutral Verification\nSection 13: At least 2 independent third parties reproduce core benchmark claims\n\n## What\nBuild the infrastructure that enables external parties to independently verify benchmark claims. This includes manifest generation, artifact packaging, verification tooling, and publication workflow.\n\n## Components\n1. **Full run manifest generator**: Captures hardware, kernel, runtime versions, flags, dataset checksums, seed transcripts, harness commit IDs\n2. **Artifact packaging**: Creates self-contained verification bundles that can be shared externally\n3. **Verification pipeline**: Automated comparison of reproduced results against published claims\n4. **Publication workflow**: Gated pipeline requiring all prerequisites before claim can be published externally\n5. **frankensqlite integration**: Store result ledgers with versioned schemas\n6. **frankentui dashboards**: Operator triage and replay dashboards for benchmark results\n\n## Verification Requirements\n- Publish native-coverage progression alongside benchmark releases\n- Per-slot replacement lineage IDs tied to concrete replacement state\n- Version-stamped benchmark specification with migration notes for spec changes\n- Include both performance AND security co-metrics (not speed-only)\n\n## Testing Requirements\n- E2E test: generate manifest, package artifacts, run verification, confirm match\n- Test: tampered artifacts are detected by verification pipeline\n- Test: spec version mismatch is detected and reported\n- Test: incomplete manifests are rejected with clear error messages\n\n## Rationale\nCategory leadership requires defining the scoreboard (Section 14 preamble). External adoption requires trust, which requires rock-solid reproducibility.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:42:27.934805899Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:35.718679743Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["benchmark","reproducibility","verification"]}
{"id":"bd-21ds","title":"[14] Public Benchmark + Standardization Strategy - Comprehensive Execution Epic","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nPurpose: Operationalize this section's governance/validation/adoption requirements into enforceable engineering work.\nQuality requirements for all children:\n- explicit acceptance criteria and failure semantics\n- unit-test and e2e/integration verification expectations\n- detailed structured logging and reproducibility artifacts where applicable\n- traceability back to category-level goals (security, performance, explainability, adoption)\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:15.545871282Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:57.290917092Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-14"],"dependencies":[{"issue_id":"bd-21ds","depends_on_id":"bd-1401","type":"parent-child","created_at":"2026-02-20T07:52:42.738587819Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-14da","type":"parent-child","created_at":"2026-02-20T07:52:42.778284207Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-1dxl","type":"parent-child","created_at":"2026-02-20T07:52:43.839916807Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-1npj","type":"parent-child","created_at":"2026-02-20T07:52:45.179144385Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-1pqn","type":"parent-child","created_at":"2026-02-20T07:52:45.416022883Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-1tsf","type":"blocks","created_at":"2026-02-20T07:34:38.009455236Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-1xva","type":"parent-child","created_at":"2026-02-20T07:52:46.109438265Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-1y63","type":"parent-child","created_at":"2026-02-20T07:52:46.189465223Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-23br","type":"parent-child","created_at":"2026-02-20T07:52:46.518976599Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-24rp","type":"parent-child","created_at":"2026-02-20T07:52:46.679273797Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-27tk","type":"parent-child","created_at":"2026-02-20T07:52:47.038294007Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-2amp","type":"parent-child","created_at":"2026-02-20T07:52:47.423198107Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-2k6v","type":"parent-child","created_at":"2026-02-20T07:52:48.295598665Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-2knu","type":"parent-child","created_at":"2026-02-20T07:52:48.334579281Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-2qqv","type":"parent-child","created_at":"2026-02-20T07:52:49.071197472Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-2u5e","type":"parent-child","created_at":"2026-02-20T07:52:49.823701031Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-2wpo","type":"parent-child","created_at":"2026-02-20T07:52:50.064214400Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-2ytn","type":"parent-child","created_at":"2026-02-20T07:52:50.499528524Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-37zd","type":"parent-child","created_at":"2026-02-20T07:52:51.345962878Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-3db2","type":"parent-child","created_at":"2026-02-20T07:52:51.905283656Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-3de4","type":"parent-child","created_at":"2026-02-20T07:52:51.944636815Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-3h31","type":"parent-child","created_at":"2026-02-20T07:52:52.282551253Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-3h61","type":"parent-child","created_at":"2026-02-20T07:52:52.322172762Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-62mo","type":"parent-child","created_at":"2026-02-20T07:52:54.661823103Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-70bx","type":"parent-child","created_at":"2026-02-20T07:52:54.781325879Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-a5xc","type":"parent-child","created_at":"2026-02-20T07:52:55.113419064Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-anuw","type":"parent-child","created_at":"2026-02-20T07:52:55.234897950Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-c1co","type":"blocks","created_at":"2026-02-20T07:34:38.497452660Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-fp53","type":"parent-child","created_at":"2026-02-20T07:52:55.716820457Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-ye6k","type":"parent-child","created_at":"2026-02-20T07:52:57.029403859Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-zze6","type":"parent-child","created_at":"2026-02-20T07:52:57.290828667Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-21ul","title":"Maintain program risk register with active countermeasures and review cadence","description":"## Plan Reference\nSection 12: Risk Register\n\n## What\nMaintain a living risk register document tracking program-level risks with active countermeasures. This is a monitoring/governance artifact, not a one-time implementation task.\n\n## Identified Risks and Countermeasures\n\n### 1. Scope explosion\n- **Countermeasure**: Strict phase gates (A/B/C/D/E) and one-lever optimization discipline from Section 5.1\n- **Monitor**: Track scope additions vs. phase gate progress monthly\n\n### 2. False confidence from heuristic security\n- **Countermeasure**: Bayesian + sequential testing (e-process) + calibration audits (Section 6.4-6.5)\n- **Monitor**: Track calibration metrics, false-positive/negative rates on adversarial corpora\n\n### 3. Performance regressions from over-hardening\n- **Countermeasure**: Profile-driven optimization and tail-latency budgets (Section 7)\n- **Monitor**: p95/p99 regression CI gates, overhead budget per security subsystem\n\n### 4. Operational complexity\n- **Countermeasure**: Evidence-ledger tooling and deterministic fallback mode (Section 8.6)\n- **Monitor**: Operator burden metrics, fallback activation frequency\n\n### 5. Delegate-path entrenchment (temporary bridge becomes permanent)\n- **Countermeasure**: Hard GA 0-delegate gate for core slots (Section 8.8), signed replacement-lineage requirements, explicit closure obligations with ownership\n- **Monitor**: Native coverage percentage, time-since-last-promotion per slot\n\n### 6. IFC policy over-constraint causing false denies on benign integrations\n- **Countermeasure**: Static-first analysis, shadow-mode rollout, explicit declassification workflows, profile-guided label-granularity tuning (Section 6.9)\n- **Monitor**: False-deny rates on benign extension corpora, declassification request volume\n\n### 7. Stale/invalid security proofs causing unsound specialization\n- **Countermeasure**: Epoch-bound proof validity (Section 8.9), mandatory specialization invalidation on proof churn, fail-closed fallback to unspecialized paths\n- **Monitor**: Proof invalidation rate, specialization fallback frequency\n\n## Review Cadence\n- Weekly: check risk indicators against thresholds\n- Per-phase-gate: full risk register review with updated status\n- Per-incident: add new risks discovered during incidents\n\n## Testing Requirements\n- Validate risk register schema (all risks have countermeasure, monitor, owner)\n- CI check that risk register is updated when phase gates are crossed\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:39:24.951932623Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:35.811887477Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["governance","risk"]}
{"id":"bd-23br","title":"[14] Scale profiles per family (each required): `S`, `M`, `L` with fixed extension counts, event rates, dependency graph sizes, and policy complexity tiers.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Scale profiles per family (each required): `S`, `M`, `L` with fixed extension counts, event rates, dependency graph sizes, and policy complexity tiers.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:28.977678111Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.345044802Z","closed_at":"2026-02-20T07:41:21.424004164Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-23om","title":"[10.13] Introduce a narrow control-plane adapter layer in `franken_engine` that imports `franken-kernel`/`franken_kernel`, `franken-decision`/`franken_decision`, and `franken-evidence`/`franken_evidence` without pulling broad runtime internals into VM hot paths.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Introduce a narrow control-plane adapter layer in `franken_engine` that imports `franken-kernel`/`franken_kernel`, `franken-decision`/`franken_decision`, and `franken-evidence`/`franken_evidence` without pulling broad runtime internals into VM hot paths.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:42.140285490Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.385777180Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-24bu","title":"[10.13] Make `frankenlab replay` and deterministic scenario pass/fail outputs release blockers for security-critical paths.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Make `frankenlab replay` and deterministic scenario pass/fail outputs release blockers for security-critical paths.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:43.592729712Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.426560272Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-24ie","title":"[10.15] Add burn-in gate: no auto-enforcement promotion without shadow success rate, false-deny envelope, and rollback proof artifacts meeting threshold.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add burn-in gate: no auto-enforcement promotion without shadow success rate, false-deny envelope, and rollback proof artifacts meeting threshold.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:51.833560760Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.467355206Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-24rp","title":"[14] Publish native-coverage progression and per-slot replacement lineage IDs alongside benchmark releases so performance claims are tied to concrete replacement state.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Publish native-coverage progression and per-slot replacement lineage IDs alongside benchmark releases so performance claims are tied to concrete replacement state.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:32.602455317Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.508206866Z","closed_at":"2026-02-20T07:41:19.881879549Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-2501","title":"Deliver scientific contribution targets and publishable research artifacts","description":"## Plan Reference\nSection 16: Scientific Contribution Targets\n\n## What\nFrankenEngine is also a research-producing engineering program. Each major novelty should produce reusable scientific/technical artifacts. This bead tracks all scientific contribution obligations.\n\n## Required Contributions\n1. **Open specifications**: Core trust/replay/policy primitives published as open specs for community adoption\n2. **Reproducible datasets**: Incident replay and adversarial campaign evaluation datasets with deterministic reproduction guarantees\n3. **Reference proofs**: Proof sketches or formal proofs for key policy and protocol safety claims (e.g., IFC confinement, capability monotonicity, revocation precedence)\n4. **External evaluations**: Red-team and academic-style evaluations with published methodology, not just internal validation\n5. **Technical reports**: Public reports documenting failures, fixes, and measured frontier movement (not just successes)\n\n## Output Contract (Hard Requirements)\n- At least 4 publishable technical reports with reproducible artifact bundles\n- At least 2 externally replicated high-impact claims (e.g., 3x performance, containment latency SLOs)\n- At least 1 open benchmark or verification tool release adopted outside the project\n\n## Rationale\nFrom the plan: 'FrankenEngine is also a research-producing engineering program.' This means the project must contribute to the broader security/runtime research community, not just ship product. External validation through independent replication and academic evaluation strengthens category claims and builds credibility. Public failure documentation demonstrates intellectual honesty and builds trust.\n\n## Dependencies\n- Requires benchmark suite (10.6, Section 14) for replicable performance claims\n- Requires adversarial corpus (10.7, 10.12) for reproducible security datasets\n- Requires IFC/PLAS proofs (10.15) for formal safety claim artifacts\n- Requires decision receipt infrastructure (10.12) for trust/replay specification publication\n\n## Testing Requirements\n- Validation that each technical report artifact bundle is self-contained and reproducible (run on clean environment)\n- Test that open specifications pass conformance vector suites from Section 10.10\n- Test that reproducible datasets produce deterministic outputs when replayed\n- Verification that external evaluation methodology documents include complete reproduction instructions\n\n## Implementation Notes\n- Technical reports should follow alien-artifact-coding discipline (Section 5.2): every claim ships with proof artifacts\n- Reports should cover both successes AND failures per plan requirement\n- External evaluations should be coordinated with the partner program from Section 15\n- Open benchmark tools should be packaged for independent installation and execution\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:47:20.310689800Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:36.186513133Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["artifacts","publications","research","scientific"]}
{"id":"bd-256n","title":"[12] Prevent delegate-path entrenchment with GA zero-delegate gate and signed replacement-lineage obligations","description":"Plan Reference: section 12 (Risk Register).\nObjective: Delegate-path entrenchment (temporary bridge becomes permanent):\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:18.382010256Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.549087671Z","closed_at":"2026-02-20T07:39:04.634752198Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"]}
{"id":"bd-25b7","title":"[10.15] Publish PLAS benchmark bundle reporting over-privilege ratio, policy authoring-time reduction, false-deny rates, and escrow-event rates across representative extension cohorts.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Publish PLAS benchmark bundle reporting over-privilege ratio, policy authoring-time reduction, false-deny rates, and escrow-event rates across representative extension cohorts.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:51.999575373Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.590050939Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-25sh","title":"Track and validate program success criteria (Section 13 acceptance gates)","description":"## Plan Reference\nSection 13: Program Success Criteria\n\n## Purpose\nThis epic tracks ALL program-level success criteria from the plan. These are NOT implementation tasks - they are acceptance gates that must be satisfied by the implementation beads in sections 10.x. Each criterion should be linked to the implementation bead(s) that satisfy it.\n\n## Success Criteria Checklist\n\n### Core Runtime\n- [ ] Native execution lanes run without external engine bindings (10.2)\n- [ ] franken_node composes those lanes for practical runtime usage (Phase D)\n- [ ] ES2020 runtime conformance is demonstrably complete per test262 gate and waiver policy (10.7)\n\n### Security\n- [ ] Untrusted extension code is actively monitored and auto-contained under attack scenarios (10.5)\n- [ ] Red-team programs show >= 10x reduction in successful host compromise vs baseline Node/Bun (Phase B gate)\n- [ ] High-risk detections reach containment in <= 250ms median time (Phase B gate)\n- [ ] Unauthorized sensitive-source -> external-sink flows are deterministically blocked unless explicit declassification approved (10.15/IFC)\n- [ ] >= 99% of declassification decisions emit signed receipt-linked replay artifacts (10.15)\n- [ ] Data-confinement claims are machine-verifiable from evidence/provenance artifacts (10.15)\n\n### Determinism & Replay\n- [ ] Deterministic replay coverage is 100% for high-severity decisions (10.5, 10.11, 10.13)\n- [ ] All high-impact safety actions executed through decision contracts and emitted through canonical evidence ledgers (10.13)\n- [ ] Extension lifecycle transitions satisfy request -> drain -> finalize protocol invariants (10.11, 10.13)\n- [ ] Release gates include deterministic frankenlab scenario replay (10.13)\n\n### Performance\n- [ ] Extension-heavy benchmark suites show >= 3x weighted-geometric-mean throughput vs Node AND Bun (Section 14 denominator)\n- [ ] Security and performance claims are artifact-backed and reproducible (10.6, 10.8)\n- [ ] Proof-carrying optimization path enabled by default for >= 1 high-impact family (10.12)\n- [ ] Proof-specialized lanes show measurable improvement vs ambient-authority lanes (10.15)\n- [ ] 100% of activated proof-specializations carry signed receipts (10.15)\n\n### Control Plane & Integration\n- [ ] Control-plane identifiers canonicalized through asupersync-derived types (10.13)\n- [ ] All advanced operator TUI surfaces delivered through frankentui (10.14)\n- [ ] All SQLite-backed persistence delivered through frankensqlite (10.14)\n- [ ] Service/API surfaces leverage fastapi_rust where applicable (10.14)\n- [ ] Cross-repo conformance lab is a hard release gate (10.15)\n\n### Fleet & Ecosystem\n- [ ] Fleet quarantine convergence meets published SLOs under fault injection (10.12)\n- [ ] Secure extension reputation graph drives measurable reduction in first-time compromise windows (10.12)\n- [ ] At least 3 beyond-parity capabilities in production with evidence (Phase D)\n- [ ] At least 2 independent third parties reproduce core benchmark claims (Section 14)\n- [ ] Category benchmark standard adopted by external participants (Section 14)\n\n### Governance & Trust\n- [ ] >= 95% of high-impact decision receipts include valid attestation bindings (10.15)\n- [ ] Privacy-preserving fleet learning operates with zero budget-overrun incidents (10.15)\n- [ ] Moonshot portfolio governor enforces promote/hold/kill gates with 100% artifact completeness (10.15)\n- [ ] PLAS produces signed capability_witness for >= 90% of targeted extension cohorts (10.15)\n- [ ] Synthesized capability envelopes achieve <= 1.10 over-privilege ratio (10.15)\n- [ ] Manual policy-authoring time reduced by >= 70% (10.15)\n- [ ] Post-burn-in false-deny rate <= 0.5% on benign corpora (10.15)\n- [ ] 100% of capability escrow/emergency-grant decisions emit receipt-linked replay artifacts (10.15)\n- [ ] Every promoted delegate->native core slot has signed replacement receipt (10.15)\n- [ ] GA default lanes run with zero mandatory delegate cells (10.15)\n\n## Validation Process\nEach criterion gets checked off only when:\n1. The implementing bead(s) are complete\n2. Evidence artifacts exist proving the criterion\n3. Independent validation has been performed where specified","status":"open","priority":1,"issue_type":"epic","created_at":"2026-02-20T07:41:05.696299100Z","created_by":"ubuntu","updated_at":"2026-02-20T07:41:05.696299100Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["acceptance","governance","release-gate"]}
{"id":"bd-26f","title":"[10.10] Define revocation object chain (`revocation`, `revocation_event`, `revocation_head`) with monotonic head sequence.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Define revocation object chain (`revocation`, `revocation_event`, `revocation_head`) with monotonic head sequence.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.382960973Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.652673268Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-26i","title":"[10.11] Require deterministic ordering/stability for evidence entries (candidate sort, witness ids, bounded size policy).","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Require deterministic ordering/stability for evidence entries (candidate sort, witness ids, bounded size policy).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.933341113Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.696546246Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-26o","title":"[10.10] Add conformance suite for canonical serialization, ID derivation, signatures, revocation freshness, and epoch ordering.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Add conformance suite for canonical serialization, ID derivation, signatures, revocation freshness, and epoch ordering.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.547823652Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.737069895Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-26qa","title":"[10.14] Add an ADR for `/dp/fastapi_rust` reuse scope across FrankenEngine service/API control surfaces.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add an ADR for `/dp/fastapi_rust` reuse scope across FrankenEngine service/API control surfaces.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:46.189371169Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.777758131Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-27i1","title":"[10.15] Add automatic demotion/rollback mechanism when post-promotion divergence or risk-threshold breaches are detected.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add automatic demotion/rollback mechanism when post-promotion divergence or risk-threshold breaches are detected.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:54.577647962Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.818964451Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-27ks","title":"[12] Prevent over-hardening performance regressions with profile-driven optimization and tail-latency budgets","description":"Plan Reference: section 12 (Risk Register).\nObjective: Performance regressions from over-hardening:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:17.965796863Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.859758754Z","closed_at":"2026-02-20T07:39:04.832961058Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"]}
{"id":"bd-27tk","title":"[14] Store benchmark artifacts and result ledgers via `/dp/frankensqlite` contracts; provide operator triage and replay dashboards through `/dp/frankentui`.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Store benchmark artifacts and result ledgers via `/dp/frankensqlite` contracts; provide operator triage and replay dashboards through `/dp/frankentui`.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:31.868363217Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.900583785Z","closed_at":"2026-02-20T07:41:20.198493760Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-289","title":"[10.11] Add global bulkheads for remote in-flight operations and background maintenance concurrency.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add global bulkheads for remote in-flight operations and background maintenance concurrency.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.993267561Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.941463427Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-28fe","title":"[13] all high-impact safety actions are executed through decision contracts and emitted through canonical evidence ledgers","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: all high-impact safety actions are executed through decision contracts and emitted through canonical evidence ledgers\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:21.295029573Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:31.982177Z","closed_at":"2026-02-20T07:39:59.901373391Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-28m","title":"[10.10] Extend capability token format with audience, expiry/nbf, jti, checkpoint binding, and revocation freshness binding.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Extend capability token format with audience, expiry/nbf, jti, checkpoint binding, and revocation freshness binding.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.256356827Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.023285919Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-29a1","title":"[10.15] Emit randomness transcript commitments and seed-hash evidence for stochastic learning phases so downstream replay remains audit-deterministic at snapshot boundaries.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Emit randomness transcript commitments and seed-hash evidence for stochastic learning phases so downstream replay remains audit-deterministic at snapshot boundaries.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.986252558Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.064850266Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-29r","title":"[10.10] Implement monotonic message sequence and replay-drop enforcement on session channels.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement monotonic message sequence and replay-drop enforcement on session channels.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.098004329Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.105380468Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-29s","title":"[10.10] Add migration contract for explicit cutover boundaries on security-critical formats and policies.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Add migration contract for explicit cutover boundaries on security-critical formats and policies.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:33.128016647Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.146655616Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-29yn","title":"[13] extension lifecycle transitions (`start`, `reload`, `suspend`, `terminate`, `quarantine`, `revoke`) satisfy `request -> drain -> finalize` protocol invariants","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: extension lifecycle transitions (`start`, `reload`, `suspend`, `terminate`, `quarantine`, `revoke`) satisfy `request -> drain -> finalize` protocol invariants\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:21.505227665Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.189168681Z","closed_at":"2026-02-20T07:39:59.802594878Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-2ag6","title":"[13] compatibility and reliability meet release gates","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: compatibility and reliability meet release gates\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:19.836100523Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.230279373Z","closed_at":"2026-02-20T07:40:00.620773504Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-2amp","title":"[14] Throughput/latency (`p50`, `p95`, `p99`) under extension-heavy workloads.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Throughput/latency (`p50`, `p95`, `p99`) under extension-heavy workloads.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:32.839566229Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.271182689Z","closed_at":"2026-02-20T07:41:19.777047982Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-2ao","title":"[10.11] Implement region-quiescence close protocol (`cancel -> drain -> finalize`) for engine and host subsystems.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement region-quiescence close protocol (`cancel -> drain -> finalize`) for engine and host subsystems.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:33.737314445Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.312179139Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-2cc8","title":"[16] Public technical reports that document failures, fixes, and measured frontier movement.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: Public technical reports that document failures, fixes, and measured frontier movement.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:36.854316330Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.368490615Z","closed_at":"2026-02-20T07:46:43.924248041Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"]}
{"id":"bd-2che","title":"[13] at least 2 independent third parties reproduce core benchmark claims using published tooling","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: at least 2 independent third parties reproduce core benchmark claims using published tooling\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:22.808934326Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.413489068Z","closed_at":"2026-02-20T07:39:59.182490612Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-2cq","title":"[10.12] Implement measured attestation handshake between execution cells and runtime policy plane.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement measured attestation handshake between execution cells and runtime policy plane.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.632636997Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.454786669Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-2d21","title":"[10.14] Define when `/dp/sqlmodel_rust` must be used: typed schema/model workflows with material correctness or migration advantages.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Define when `/dp/sqlmodel_rust` must be used: typed schema/model workflows with material correctness or migration advantages.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:45.705450068Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.495598635Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-2eu","title":"[10.7] Add metamorphic tests for parser/IR/execution invariants.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add metamorphic tests for parser/IR/execution invariants.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.468393695Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.536377800Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"]}
{"id":"bd-2f8","title":"[10.2] Implement baseline interpreter skeleton for both lanes.","description":"## Plan Reference\nSection 10.2, item 8. Cross-refs: existing code in crates/franken-engine/src/lib.rs (QuickJsInspiredNativeEngine, V8InspiredNativeEngine, HybridRouter), 9F.1 (Verified Adaptive Compiler baseline path), Phase A exit gate.\n\n## What\nImplement the baseline interpreter skeleton for both execution lanes (quickjs-inspired-native and v8-inspired-native). These are de novo Rust implementations, not FFI wrappers. The baseline interpreter is the canonical execution path that all optimizations must prove equivalence against.\n\n## Detailed Requirements\n- QuickJsInspiredNativeEngine: deterministic, low-overhead execution lane for simple workloads\n- V8InspiredNativeEngine: throughput-optimized lane for complex workloads (imports, async)\n- Both must implement the JsEngine trait (already defined in crate)\n- Both must consume IR3 (ExecIR) and produce IR4 (WitnessIR) artifacts\n- HybridRouter: policy-directed routing between lanes (already has basic routing logic)\n- Interpreter must support: variable lookup, function calls, object operations, control flow, error handling\n- Baseline interpreter remains canonical even after optimized paths are available (per 9F.1)\n\n## Rationale\nFrom Section 2: 'No dependency on external JS engine bindings for core runtime behavior.' The baseline interpreter is the foundation for Phase A exit gate (native execution lanes pass baseline conformance). Per 9F.1, this baseline path is never removed - it serves as the canonical reference against which all adaptive optimizations are validated.\n\n## Testing Requirements\n- Unit tests: evaluate simple arithmetic expressions\n- Unit tests: evaluate variable declarations and references\n- Unit tests: evaluate function definitions and calls\n- Unit tests: evaluate object property access\n- Unit tests: evaluate control flow (if/else, loops, try/catch)\n- Conformance: test262 ES2020 subset for baseline correctness\n- Determinism: same input produces identical output and witness across runs\n\n## Dependencies\n- Blocked by: parser trait (bd-crp), IR contract (bd-1wa), execution-slot registry (bd-20b)\n- Blocks: ES2020 object/prototype semantics, closure/scope model, Promise/async, error semantics\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.332198398Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.576678834Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"]}
{"id":"bd-2fa1","title":"[10.13] Add dependency policy: no local forks of `TraceId`, `DecisionId`, `PolicyId`, `SchemaVersion`, `Budget`, or `Cx`.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add dependency policy: no local forks of `TraceId`, `DecisionId`, `PolicyId`, `SchemaVersion`, `Budget`, or `Cx`.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:41.981869972Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.617472757Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-2fqx","title":"[13] deterministic replay coverage is `100%` for high-severity decisions and incidents, with deterministic re-execution defined over fixed artifacts (`code`, `policy`, `model snapshot`, `randomness transcript`)","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: deterministic replay coverage is `100%` for high-severity decisions and incidents, with deterministic re-execution defined over fixed artifacts (`code`, `policy`, `model snapshot`, `randomness transcript`)\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:20.876810504Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.657986918Z","closed_at":"2026-02-20T07:40:00.105791687Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-2ftv","title":"[10.15] Implement IR2 flow-label inference + runtime label propagation with static-first optimization (runtime checks only on dynamic/ambiguous edges).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement IR2 flow-label inference + runtime label propagation with static-first optimization (runtime checks only on dynamic/ambiguous edges).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:52.332495317Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.701201519Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-2g9","title":"[10.11] FrankenSQLite-Inspired Runtime Systems Track - Comprehensive Execution Epic","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.881356235Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:57.069229398Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-11"],"dependencies":[{"issue_id":"bd-2g9","depends_on_id":"bd-117","type":"parent-child","created_at":"2026-02-20T07:52:42.339194110Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-121","type":"parent-child","created_at":"2026-02-20T07:52:42.538389971Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-127","type":"parent-child","created_at":"2026-02-20T07:52:42.577578514Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-18m","type":"parent-child","created_at":"2026-02-20T07:52:43.266428331Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-1bl","type":"parent-child","created_at":"2026-02-20T07:52:43.513229772Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-1i2","type":"parent-child","created_at":"2026-02-20T07:52:44.458393268Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-1if","type":"parent-child","created_at":"2026-02-20T07:52:44.505671428Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-1si","type":"parent-child","created_at":"2026-02-20T07:52:45.701245638Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-1v5","type":"parent-child","created_at":"2026-02-20T07:52:45.903048244Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-1yq","type":"blocks","created_at":"2026-02-20T07:32:56.914287078Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-1za","type":"parent-child","created_at":"2026-02-20T07:52:46.270036354Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-26i","type":"parent-child","created_at":"2026-02-20T07:52:46.839051198Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-289","type":"parent-child","created_at":"2026-02-20T07:52:47.078116550Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-2ao","type":"parent-child","created_at":"2026-02-20T07:52:47.462344962Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-2gg","type":"parent-child","created_at":"2026-02-20T07:52:48.018376112Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-2h2","type":"parent-child","created_at":"2026-02-20T07:52:48.096787721Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-2j3","type":"parent-child","created_at":"2026-02-20T07:52:48.255887059Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-2n6","type":"parent-child","created_at":"2026-02-20T07:52:48.670190869Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-2s1","type":"parent-child","created_at":"2026-02-20T07:52:49.350025646Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-2ta","type":"parent-child","created_at":"2026-02-20T07:52:49.586294208Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-30g","type":"parent-child","created_at":"2026-02-20T07:52:50.700016872Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-33h","type":"parent-child","created_at":"2026-02-20T07:52:50.938183761Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-359","type":"parent-child","created_at":"2026-02-20T07:52:51.140425555Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-3e7","type":"parent-child","created_at":"2026-02-20T07:52:51.984659621Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-3ix","type":"parent-child","created_at":"2026-02-20T07:52:52.440775370Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-3nc","type":"parent-child","created_at":"2026-02-20T07:52:52.995674443Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-3s3","type":"parent-child","created_at":"2026-02-20T07:52:53.664192040Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-3vg","type":"parent-child","created_at":"2026-02-20T07:52:54.183677712Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-3vh","type":"blocks","created_at":"2026-02-20T07:32:56.999733537Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-4hf","type":"parent-child","created_at":"2026-02-20T07:52:54.461372445Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-gr1","type":"parent-child","created_at":"2026-02-20T07:52:55.777045041Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-hli","type":"parent-child","created_at":"2026-02-20T07:52:55.819253839Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-qse","type":"parent-child","created_at":"2026-02-20T07:52:56.463536386Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-xga","type":"parent-child","created_at":"2026-02-20T07:52:56.950360793Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-yi6","type":"parent-child","created_at":"2026-02-20T07:52:57.069155550Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2gej","title":"[10.15] Add frankentui operator surfaces for capability-delta reviews (`current`, `proposed minimal`, `escrow events`, `override rationale`) with deterministic drill playback.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankentui operator surfaces for capability-delta reviews (`current`, `proposed minimal`, `escrow events`, `override rationale`) with deterministic drill playback.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:51.136955426Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.781661544Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-2gg","title":"[10.11] Define supervision tree for long-lived services with restart budgets, escalation, and monotone severity outcomes.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Define supervision tree for long-lived services with restart budgets, escalation, and monotone severity outcomes.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.355157581Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.821787562Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-2gl","title":"[10.5] Implement containment actions (`sandbox`, `suspend`, `terminate`, `quarantine`).","description":"## Plan Reference\nSection 10.5, item 6 (Implement containment actions: sandbox, suspend, terminate, quarantine). Cross-refs: 9A.8 (resource budgets per extension), Phase B exit gate (median detection-to-containment <= 250ms), 9G.2 (cancellation as protocol).\n\n## What\nImplement the four containment actions that the expected-loss action selector (bd-1y5) can trigger, plus the `Allow` and `Challenge` pass-through actions. Each containment action is a deterministic operation on an extension's lifecycle state (bd-1hu) with specific resource, capability, and communication implications. The containment subsystem must meet the Phase B exit gate of median detection-to-containment latency <= 250ms, meaning from the moment the Guardplane decides to contain an extension to the moment the containment is effective, no more than 250ms may elapse (at median).\n\n## Detailed Requirements\n- Implement `ContainmentExecutor` trait with method `execute(action: ContainmentAction, target: ExtensionId, context: ContainmentContext) -> Result<ContainmentReceipt, ContainmentError>`.\n- **Sandbox**: Restrict the extension's capability set to a minimal safe subset (e.g., deny all network, deny fs_write, allow only fs_read to a quarantine directory). The extension continues running but with reduced authority. Must not require extension cooperation. Implemented by intercepting hostcalls and filtering against the sandbox policy.\n- **Suspend**: Pause all execution of the extension. No hostcalls are processed. Timers are frozen. The extension's state is preserved in memory for potential resume. Implemented by suspending the extension's task/fiber and draining its hostcall queue.\n- **Terminate**: Initiate cooperative shutdown per 9G.2: send cancel token, wait for grace period (configurable, default 5s), then force-kill if not exited. Release all resources (memory, file handles, network connections). Log final resource accounting.\n- **Quarantine**: Like terminate, but additionally: preserve the extension's memory snapshot and hostcall log for forensic analysis (bd-t2m). Mark the extension's manifest as quarantined in the trust registry. Emit a quarantine event to the supply-chain trust fabric (9A.5).\n- **Allow**: No-op pass-through; log the decision for audit trail.\n- **Challenge**: Request additional authentication/attestation from the extension before allowing continued operation. If the challenge is not answered within a timeout, escalate to Sandbox.\n- Each containment action must produce a `ContainmentReceipt` struct: `{ receipt_id: ReceiptId, action: ContainmentAction, target: ExtensionId, timestamp_ns: u64, duration_ns: u64, success: bool, evidence_refs: Vec<EvidenceRef> }`.\n- Latency budget: median execution time for any containment action <= 200ms (leaving 50ms for decision pipeline).\n- All containment actions must be idempotent: executing the same action twice on an already-contained extension is a no-op returning the existing receipt.\n\n## Rationale\nContainment is the enforcement arm of the security decision system. Without fast, reliable containment, the Bayesian detection and decision components are academic exercises. The 250ms Phase B exit gate ensures that the engine can respond to threats in near-real-time. The differentiated actions (sandbox vs. suspend vs. terminate vs. quarantine) enable proportional response: the engine does not terminate an extension it could safely sandbox. Quarantine's forensic preservation is essential for post-incident analysis and for improving the Bayesian models over time.\n\n## Testing Requirements\n- **Unit tests**: Each containment action transitions the extension to the correct lifecycle state. Sandbox correctly restricts capabilities (denied hostcalls return `Denied`). Suspend freezes execution (no hostcalls processed during suspension). Terminate follows cooperative shutdown protocol. Quarantine preserves memory snapshot.\n- **Latency tests**: Benchmark each containment action; assert median < 200ms. Test under load (multiple extensions being contained simultaneously).\n- **Idempotency tests**: Execute each action twice on the same extension; verify second execution returns existing receipt without side effects.\n- **Integration tests**: Full pipeline: telemetry -> posterior update -> action selection -> containment execution. Verify end-to-end detection-to-containment latency < 250ms.\n- **Adversarial tests**: Extension that ignores cancel token (terminate must force-kill after grace period). Extension that floods hostcalls during containment (sandbox must filter correctly under load).\n\n## Implementation Notes\n- Sandbox is implemented at the hostcall dispatch layer: a `SandboxPolicy` filter is inserted into the extension's hostcall path, rejecting calls outside the allowed set.\n- Suspend is implemented by pausing the extension's async task (e.g., using a `tokio::sync::Notify` gate or cooperative yield point).\n- Terminate follows the 9G.2 protocol: `CancellationToken` -> grace period -> forced drop.\n- Quarantine must capture the extension's memory region before termination; this may require a copy-on-write snapshot or a pre-termination memory dump.\n- Receipt generation must be atomic with action execution to avoid partial containment without receipt.\n\n## Dependencies\n- **Blocked by**: bd-1hu (lifecycle manager provides state machine), bd-1y5 (action selector decides which containment to apply), bd-5pk (telemetry for logging containment events).\n- **Blocks**: bd-t2m (forensic replay uses quarantine snapshots), bd-375 (delegate cells need same containment actions).\n- **Parent**: bd-1yq (10.5 epic).","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.548856097Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.862389227Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"]}
{"id":"bd-2h2","title":"[10.11] Add optional MMR-style compact proof support for marker-stream inclusion/prefix verification.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add optional MMR-style compact proof support for marker-stream inclusion/prefix verification.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:37.470488011Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.904300901Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-2h70","title":"[11] Publish benchmark and correctness artifact bundle for each proposal","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: benchmark and correctness artifacts\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:17.346294237Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.944272422Z","closed_at":"2026-02-20T07:38:22.802113797Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-2h70","depends_on_id":"bd-18fu","type":"blocks","created_at":"2026-02-20T07:38:26.738320312Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2h70","depends_on_id":"bd-3tjn","type":"blocks","created_at":"2026-02-20T07:38:26.620876031Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2ic","title":"[10.10] Enforce revocation checks before token acceptance, risky operation execution, and extension activation.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Enforce revocation checks before token acceptance, risky operation execution, and extension activation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.522998007Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:32.984695924Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-2j0k","title":"[13] red-team programs show `>= 10x` reduction in successful host compromise versus baseline Node/Bun default posture","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: red-team programs show `>= 10x` reduction in successful host compromise versus baseline Node/Bun default posture\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:20.463421562Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.025445714Z","closed_at":"2026-02-20T07:40:00.305988279Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-2j3","title":"[10.11] Emit proof-carrying recovery artifacts for degraded-mode repairs and rejected trust transitions.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Emit proof-carrying recovery artifacts for degraded-mode repairs and rejected trust transitions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:37.918993715Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.065447702Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-2k6v","title":"[14] Equivalent external outputs (canonical digest).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Equivalent external outputs (canonical digest).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:29.452790735Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.105291575Z","closed_at":"2026-02-20T07:41:21.225463527Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-2knu","title":"[14] Benchmark families (each required): `boot-storm`, `capability-churn`, `mixed-cpu-io-agent-mesh`, `reload-revoke-churn`, `adversarial-noise-under-load`.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Benchmark families (each required): `boot-storm`, `capability-churn`, `mixed-cpu-io-agent-mesh`, `reload-revoke-churn`, `adversarial-noise-under-load`.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:28.746782737Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.145273004Z","closed_at":"2026-02-20T07:41:21.522710122Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-2l0x","title":"[10.14] Add an ADR declaring `/dp/frankentui` as the required substrate for advanced operator console/TUI surfaces in FrankenEngine.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add an ADR declaring `/dp/frankentui` as the required substrate for advanced operator console/TUI surfaces in FrankenEngine.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:44.731663363Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.185570181Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-2l6","title":"[10.6] Enforce one-lever-per-change performance policy.","description":"## Plan Reference\nSection 10.6, item 5. Cross-refs: 9D (extreme-software-optimization - one lever per commit), 9C.4 (experiment with prior/posterior/stopping rule).\n\n## What\nEnforce the one-lever-per-change performance policy in CI and workflow. Each optimization commit changes exactly one variable, with before/after evidence and semantic equivalence proof.\n\n## Detailed Requirements\n- CI gate: optimization PRs must include baseline/after benchmark data for the specific optimization\n- One lever rule: each optimization commit changes one thing (algorithm, data structure, layout, etc.)\n- Semantic equivalence: optimization commit must include evidence that behavior is unchanged (golden output comparison, trace replay)\n- Isomorphism artifacts: record ordering/tie-break semantics per 9C.1 isomorphism ledger\n- Re-profile requirement: post-merge re-profile to verify predicted improvement materialized\n- Rollback readiness: each optimization must include rollback instructions\n\n## Rationale\nPer 9D: 'Implement one lever per commit with opportunity score >= 2.0. Prove isomorphism. Verify against golden outputs and re-profile.' This discipline prevents the common failure mode where multiple simultaneous changes make it impossible to attribute improvements or debug regressions. It turns performance engineering into a measurable scientific practice.\n\n## Testing Requirements\n- CI integration test: PR with multiple optimization levers is flagged/rejected\n- CI integration test: PR without baseline/after data is flagged\n- Test: semantic equivalence check catches behavior change\n- Test: rollback instructions are present and executable\n\n## Dependencies\n- Blocked by: opportunity matrix (bd-js4), benchmark suite (bd-2ql)\n- Blocks: Phase C exit gate (performance improvements are evidence-backed)","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:25.750262716Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.225726205Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-6"]}
{"id":"bd-2lr7","title":"[10.15] Implement static upper-bound authority analyzer from capability-typed IR + manifest intents.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement static upper-bound authority analyzer from capability-typed IR + manifest intents.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:49.968133192Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.265778527Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-2lt9","title":"[10.15] Define privacy-learning contract for fleet calibration (`feature schema`, update policy, clipping strategy, DP budget semantics, secure-aggregation requirements).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define privacy-learning contract for fleet calibration (`feature schema`, update policy, clipping strategy, DP budget semantics, secure-aggregation requirements).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.659304528Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.306700908Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-2mf","title":"[10.1] Charter + Governance - Comprehensive Execution Epic","description":"Plan Reference: section 10.1 (Charter + Governance).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.238038859Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:55.900397066Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-1"],"dependencies":[{"issue_id":"bd-2mf","depends_on_id":"bd-10a","type":"parent-child","created_at":"2026-02-20T07:52:42.258611478Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2mf","depends_on_id":"bd-2u0","type":"parent-child","created_at":"2026-02-20T07:52:49.744782418Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2mf","depends_on_id":"bd-2xe","type":"parent-child","created_at":"2026-02-20T07:52:50.223166984Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2mf","depends_on_id":"bd-3fr","type":"parent-child","created_at":"2026-02-20T07:52:52.103231653Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2mf","depends_on_id":"bd-3u5","type":"parent-child","created_at":"2026-02-20T07:52:53.941316331Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2mf","depends_on_id":"bd-74l","type":"parent-child","created_at":"2026-02-20T07:52:54.831013547Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2mf","depends_on_id":"bd-j7z","type":"parent-child","created_at":"2026-02-20T07:52:55.900318990Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2mm","title":"[10.8] Add runtime diagnostics and evidence export CLI.","description":"## Plan Reference\nSection 10.8, item 1. Cross-refs: 9E.9 (normative observability surface), 10.11 (evidence-ledger schema), 10.13 (control-plane invariants dashboard).\n\n## What\nAdd runtime diagnostics and evidence export CLI. Operators need a single command to inspect runtime state, export evidence for incident investigation, and verify system health.\n\n## Detailed Requirements\n- Diagnostics CLI: show current runtime state (loaded extensions, active policies, security epoch, GC pressure, scheduler lane utilization)\n- Evidence export: export evidence ledger entries for a time range, extension, or incident trace_id\n- Format: structured JSON output for machine consumption, human-readable summary mode\n- Export must include: decision receipts, hostcall telemetry, containment actions, policy changes, replay artifacts\n- Filter support: by extension_id, trace_id, time range, severity, decision type\n- Deterministic export: same query on same data produces identical output (for audit)\n\n## Rationale\nThe plan requires operational readiness (Phase E) with evidence-backed operational reports. Operators cannot manage a system they cannot inspect. The evidence export CLI is the primary interface for post-incident forensics (9A.3) and audit compliance. Without it, the deterministic evidence graph has no practical access point.\n\n## Testing Requirements\n- Unit tests: diagnostics command returns structured runtime state\n- Unit tests: evidence export produces valid JSON with expected schema\n- Unit tests: filters correctly narrow results (by extension, trace_id, time range)\n- Integration test: export evidence for a simulated incident, verify completeness\n- Determinism test: same query → same output across runs\n\n## Dependencies\n- Blocked by: evidence ledger (10.11), hostcall telemetry (10.5), containment actions (10.5)\n- Blocks: Phase E exit gate (operational readiness report), operator workflows","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:27.282300916Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.388683919Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-8"]}
{"id":"bd-2n3","title":"[10.9] Release gate: PLAS is active for prioritized extension cohorts with signed `capability_witness` artifacts and escrow-path replay evidence (implementation ownership: `10.15`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: PLAS is active for prioritized extension cohorts with signed `capability_witness` artifacts and escrow-path replay evidence (implementation ownership: `10.15`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.422306795Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.429101150Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"]}
{"id":"bd-2n6","title":"[10.11] Implement O(Delta) anti-entropy reconciliation for distributed revocation/checkpoint/evidence object sets.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement O(Delta) anti-entropy reconciliation for distributed revocation/checkpoint/evidence object sets.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:37.620001617Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.470006821Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-2n9","title":"[10.6] Implement benchmark denominator calculator (`weighted geometric mean`) and publication gate for Node/Bun comparisons.","description":"## Plan Reference\nSection 10.6, item 2. Cross-refs: Section 14.2 (>= 3x Claim Denominator Normative), Phase C exit gate.\n\n## What\nImplement the benchmark denominator calculator using weighted geometric mean, with publication gates that enforce the >= 3x claim validity rules from Section 14.2.\n\n## Detailed Requirements\n- Per-case speedup: r_i = throughput_franken_engine_i / throughput_B_i for each baseline B in {Node, Bun}\n- Suite score: S_B = exp(sum_i w_i * ln(r_i)) with non-zero weights summing to 1\n- Default weighting: equal weighting across family/profile cells\n- Publication gate for >= 3x claim: S_Node >= 3.0 AND S_Bun >= 3.0 AND all cases pass behavior-equivalence\n- Failed-equivalence invalidation: any failed behavior-equivalence case invalidates claim publication until fixed or excluded via versioned benchmark-spec revision\n- Throughput claims must be accompanied by latency/error envelopes (speedups cannot hide tail-collapse)\n- Publication includes: native-coverage progression and per-slot replacement lineage IDs (Section 14.3)\n\n## Rationale\nThe >= 3x claim is a hard, normative requirement (Section 14.2). The weighted geometric mean prevents cherry-picking: a single fast case cannot compensate for many slow cases. The behavior-equivalence gate prevents inflating throughput by dropping work or relaxing correctness. This calculator is the mathematical foundation of the project's primary performance claim.\n\n## Testing Requirements\n- Unit tests: weighted geometric mean calculation on known inputs produces expected output\n- Unit tests: publication gate passes when S >= 3.0 for both baselines\n- Unit tests: publication gate fails when any case fails equivalence\n- Unit tests: publication gate fails when S < 3.0 for either baseline\n- Edge cases: single case (trivial), all equal speedups, one extreme outlier\n- Verify weight normalization (sum to 1)\n\n## Implementation Notes\n- Implement as library function for programmatic use + CLI for CI integration\n- Use f64 arithmetic with explicit rounding rules for reproducibility\n- Consider storing calculation artifacts in frankensqlite for audit trail\n- Publication report should be machine-readable (JSON) for CI gates\n\n## Dependencies\n- Blocked by: benchmark suite (bd-2ql)\n- Blocks: Phase C exit gate, Section 14.2 claim publication","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:25.351481353Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.510277879Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-6"]}
{"id":"bd-2ntw","title":"[11] Require standardized change-summary contract for major subsystem proposals","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: change summary\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:15.858259181Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.550556873Z","closed_at":"2026-02-20T07:38:23.501220128Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"]}
{"id":"bd-2nxj","title":"[10.15] Add shadow-evaluation gate that blocks global model/policy promotion unless privacy-preserving updates improve safety metrics without exceeding privacy budgets.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add shadow-evaluation gate that blocks global model/policy promotion unless privacy-preserving updates improve safety metrics without exceeding privacy budgets.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:48.149688287Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.591123001Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-2onl","title":"[10.12] Build continuous adversarial campaign generator with mutation grammars and exploit objective scoring.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Build continuous adversarial campaign generator with mutation grammars and exploit objective scoring.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:40.089188127Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.632087281Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-2pv","title":"[10.7] Add specialization-conformance suite ensuring proof-specialized and unspecialized execution remain semantically equivalent across policy/proof epoch transitions.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add specialization-conformance suite ensuring proof-specialized and unspecialized execution remain semantically equivalent across policy/proof epoch transitions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:27.144406733Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.673078450Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"]}
{"id":"bd-2pwr","title":"[16] Reproducible datasets for incident replay and adversarial campaign evaluation.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: Reproducible datasets for incident replay and adversarial campaign evaluation.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:36.246858840Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.713470735Z","closed_at":"2026-02-20T07:46:54.315573395Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"]}
{"id":"bd-2py0","title":"[10.13] Add interference tests for multiple controllers touching same metrics with required timescale-separation statements.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add interference tests for multiple controllers touching same metrics with required timescale-separation statements.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:43.753657799Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.757192551Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-2qj","title":"[10.12] Implement translation-validation gate on adaptive optimization paths with fail-closed rollback.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement translation-validation gate on adaptive optimization paths with fail-closed rollback.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:38.374222211Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.800240201Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-2ql","title":"[10.6] Define and publish Extension-Heavy Benchmark Suite v1.0 (workload matrix, profiles, datasets, golden outputs).","description":"## Plan Reference\nSection 10.6, item 1. Cross-refs: Section 14.1 (Extension-Heavy Benchmark Suite v1.0 Normative), 9A.4 (alien-performance profile discipline), 9D (extreme-software-optimization), Phase C exit gate.\n\n## What\nDefine and publish the Extension-Heavy Benchmark Suite v1.0 - the reference benchmark for secure extension runtimes. This is not just internal tooling; it becomes the industry standard (per Section 14).\n\n## Detailed Requirements\n- **Benchmark families** (each required): boot-storm, capability-churn, mixed-cpu-io-agent-mesh, reload-revoke-churn, adversarial-noise-under-load\n- **Scale profiles per family** (each required): S, M, L with fixed extension counts, event rates, dependency graph sizes, and policy complexity tiers\n- **Per-case metrics**: throughput, p50/p95/p99 latency, allocation/peak memory, correctness digest, security-event envelope\n- **Workload matrix**: deterministic, reproducible workload definitions with dataset checksums and seed transcripts\n- **Golden outputs**: canonical expected output for each workload case\n- **Behavior-equivalence requirements** (from Section 14.1):\n  - Equivalent external outputs (canonical digest)\n  - Equivalent side-effect trace class (filesystem/network/process/policy actions)\n  - Equivalent error-class semantics for exceptional cases\n  - No work dropping, relaxed durability, or disabled policy checks to inflate throughput\n- **Required metric families** (from Section 14.3):\n  - Throughput/latency under extension-heavy workloads\n  - Containment quality (time-to-detect, time-to-contain, false-positive/false-negative)\n  - Replay correctness (determinism pass rate, artifact completeness)\n  - Revocation/quarantine propagation\n  - Adversarial resilience\n  - Information-flow security\n  - Security-proof specialization uplift\n\n## Rationale\nFrom Section 14: 'FrankenEngine will define and own the reference benchmark standard for secure extension runtimes.' And: 'Benchmark ownership sets the language of competition.' This is a strategic asset, not just a testing tool. The benchmark must be rigorous enough for external adoption and transparent enough for independent verification.\n\n## Testing Requirements\n- Validate each benchmark family runs to completion on all scale profiles\n- Verify golden outputs are correct and deterministic\n- Verify behavior-equivalence checks detect violations (insert a violation, confirm detection)\n- Test benchmark harness reproducibility: same hardware/config → same results within tolerance\n- Meta-test: benchmark suite itself runs within reasonable time budgets\n\n## Implementation Notes\n- Publish as standalone harness with CLI interface for external use\n- Store artifacts via frankensqlite (per 10.14, Section 14.3)\n- Dashboard via frankentui (per 10.14, Section 14.3)\n- Consider Criterion.rs for Rust benchmarks, custom harness for extension workloads\n- Neutral verifier mode (Section 14.3) must be built-in from the start\n\n## Dependencies\n- Blocked by: baseline interpreter (10.2), extension host (10.5) for workload execution\n- Blocks: benchmark denominator (bd-2n9), performance gates (Phase C), Section 14 publication","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:25.217563396Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.841379096Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-6"]}
{"id":"bd-2qqv","title":"[14] Security-proof specialization uplift (performance delta between proof-specialized and ambient-authority modes, invalidation/fallback correctness rate).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Security-proof specialization uplift (performance delta between proof-specialized and ambient-authority modes, invalidation/fallback correctness rate).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:34.195377123Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.881993875Z","closed_at":"2026-02-20T07:41:19.177590053Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-2qx","title":"[10.8] Add deterministic safe-mode startup flag.","description":"## Plan Reference\nSection 10.8, item 2. Cross-refs: 9G.5 (policy controller with expected-loss under guardrails), 10.11 (deterministic fallback protocol), Phase B exit gate.\n\n## What\nAdd a deterministic safe-mode startup flag that forces the runtime into a maximally conservative configuration for incident recovery or untrusted environments.\n\n## Detailed Requirements\n- Safe-mode flag: --safe-mode or environment variable FRANKEN_SAFE_MODE=1\n- Safe-mode behavior: all extensions start sandboxed, no auto-promotion, conservative policy defaults, enhanced telemetry, disabled adaptive tuning\n- Deterministic: safe-mode startup sequence is identical across machines for replay\n- Explicit degradation: safe-mode clearly logs which features are restricted and why\n- No data loss: safe-mode preserves all evidence, logs, and state for later analysis\n- Exit path: clear procedure to transition from safe mode to normal operation with evidence\n\n## Rationale\nThe plan requires deterministic fallback for multiple scenarios: attestation failure (10.15), anti-entropy reconciliation failure (10.11), control-plane failure (10.13). A single, well-tested safe-mode entry point ensures consistent behavior across all degraded scenarios. Phase B exit gate requires that the system degrades gracefully rather than failing undefined.\n\n## Testing Requirements\n- Unit tests: safe-mode flag activates conservative configuration\n- Unit tests: all extensions are sandboxed in safe mode\n- Unit tests: safe-mode logs explain restrictions clearly\n- Integration test: simulate incident → enter safe mode → verify conservative behavior → exit to normal\n- Determinism test: safe-mode startup sequence is identical across runs\n\n## Dependencies\n- Blocked by: containment actions (10.5), policy controller (10.11)\n- Blocks: Phase E exit gate, operational incident response procedures","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:27.415482892Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.922623972Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-8"]}
{"id":"bd-2r0c","title":"[15] Enterprise governance hooks (policy-as-code pipelines, audit export, compliance evidence contracts).","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Enterprise governance hooks (policy-as-code pipelines, audit export, compliance evidence contracts).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:34.799999532Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:33.962800204Z","closed_at":"2026-02-20T07:45:50.118780110Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"]}
{"id":"bd-2r6","title":"[10.12] Frontier Programs Execution Track (9H Canonical Owners) - Comprehensive Execution Epic","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.946742810Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:57.170130896Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-12"],"dependencies":[{"issue_id":"bd-2r6","depends_on_id":"bd-12m","type":"blocks","created_at":"2026-02-20T07:32:57.174530148Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-12p","type":"parent-child","created_at":"2026-02-20T07:52:42.657119937Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-1bzp","type":"parent-child","created_at":"2026-02-20T07:52:43.595949265Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-1ddd","type":"parent-child","created_at":"2026-02-20T07:52:43.760216749Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-1nh","type":"parent-child","created_at":"2026-02-20T07:52:45.099979032Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-1o2","type":"parent-child","created_at":"2026-02-20T07:52:45.218510809Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-1yq","type":"blocks","created_at":"2026-02-20T07:32:57.087391637Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-2cq","type":"parent-child","created_at":"2026-02-20T07:52:47.583482061Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-2g9","type":"blocks","created_at":"2026-02-20T07:32:57.452351892Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-2onl","type":"parent-child","created_at":"2026-02-20T07:52:48.832092817Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-2qj","type":"parent-child","created_at":"2026-02-20T07:52:48.989623763Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-2th8","type":"parent-child","created_at":"2026-02-20T07:52:49.626499775Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-32pl","type":"parent-child","created_at":"2026-02-20T07:52:50.818115472Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-33ce","type":"parent-child","created_at":"2026-02-20T07:52:50.897102683Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-34l","type":"parent-child","created_at":"2026-02-20T07:52:51.020947045Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-383","type":"blocks","created_at":"2026-02-20T07:32:57.259276974Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-39f0","type":"parent-child","created_at":"2026-02-20T07:52:51.467232855Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-3b5m","type":"parent-child","created_at":"2026-02-20T07:52:51.665348023Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-3gsv","type":"parent-child","created_at":"2026-02-20T07:52:52.243011717Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-3oc","type":"parent-child","created_at":"2026-02-20T07:52:53.181927086Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-3ovc","type":"parent-child","created_at":"2026-02-20T07:52:53.221767773Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-3vh","type":"blocks","created_at":"2026-02-20T07:32:57.365641207Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-d6h","type":"parent-child","created_at":"2026-02-20T07:52:55.357830423Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-du2","type":"parent-child","created_at":"2026-02-20T07:52:55.476192194Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-ewy","type":"parent-child","created_at":"2026-02-20T07:52:55.611482284Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-nhp","type":"parent-child","created_at":"2026-02-20T07:52:56.263225278Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-yqe","type":"parent-child","created_at":"2026-02-20T07:52:57.170052751Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2rbm","title":"[12] Risk Register - Comprehensive Execution Epic","description":"Plan Reference: section 12 (Risk Register).\nPurpose: Operationalize this section's governance/validation/adoption requirements into enforceable engineering work.\nQuality requirements for all children:\n- explicit acceptance criteria and failure semantics\n- unit-test and e2e/integration verification expectations\n- detailed structured logging and reproducibility artifacts where applicable\n- traceability back to category-level goals (security, performance, explainability, adoption)\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:15.336762088Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:54.541567135Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-12"],"dependencies":[{"issue_id":"bd-2rbm","depends_on_id":"bd-15vm","type":"parent-child","created_at":"2026-02-20T07:52:42.904582129Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2rbm","depends_on_id":"bd-1blo","type":"parent-child","created_at":"2026-02-20T07:52:43.553777546Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2rbm","depends_on_id":"bd-1md2","type":"parent-child","created_at":"2026-02-20T07:52:45.020129044Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2rbm","depends_on_id":"bd-1tsf","type":"blocks","created_at":"2026-02-20T07:34:37.814888700Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2rbm","depends_on_id":"bd-256n","type":"parent-child","created_at":"2026-02-20T07:52:46.719656033Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2rbm","depends_on_id":"bd-27ks","type":"parent-child","created_at":"2026-02-20T07:52:46.998310604Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2rbm","depends_on_id":"bd-37go","type":"parent-child","created_at":"2026-02-20T07:52:51.302318176Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2rbm","depends_on_id":"bd-51gj","type":"parent-child","created_at":"2026-02-20T07:52:54.541480163Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2rbm","depends_on_id":"bd-c1co","type":"blocks","created_at":"2026-02-20T07:34:38.301934511Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2rk","title":"[10.7] Add probabilistic security conformance tests (benign vs malicious corpora).","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add probabilistic security conformance tests (benign vs malicious corpora).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.335202783Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.084686599Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"]}
{"id":"bd-2rx","title":"[10.9] Release gate: proof-carrying optimization pipeline is enabled with replayable validation artifacts (implementation ownership: `10.12`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: proof-carrying optimization pipeline is enabled with replayable validation artifacts (implementation ownership: `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.139535732Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.125608510Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"]}
{"id":"bd-2s1","title":"[10.11] Map work classes to scheduler lanes (`cancel`, `timed`, `ready`) and require task-type labeling for observability.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Map work classes to scheduler lanes (`cancel`, `timed`, `ready`) and require task-type labeling for observability.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.842779780Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.169699784Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-2s6b","title":"[13] data-confinement claims are machine-verifiable from evidence/provenance artifacts for published incident and benchmark corpora","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: data-confinement claims are machine-verifiable from evidence/provenance artifacts for published incident and benchmark corpora\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:26.404544393Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.210309613Z","closed_at":"2026-02-20T07:39:57.591553575Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-2s7","title":"[10.10] Define stable, versioned error-code namespace and compatibility policy.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Define stable, versioned error-code namespace and compatibility policy.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.260998047Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.250698211Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-2sbb","title":"[10.13] Add deterministic evidence replay checks ensuring decision/evidence linkage replays identically across machines.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add deterministic evidence replay checks ensuring decision/evidence linkage replays identically across machines.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:43.276406602Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.291651881Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-2t3","title":"[10.10] Implement deterministic serialization module with schema-hash prefix validation.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement deterministic serialization module with schema-hash prefix validation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.418156697Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.332109938Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-2t97","title":"[13] ES2020 runtime conformance is demonstrably complete per the declared `test262` normative gate and waiver policy","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: ES2020 runtime conformance is demonstrably complete per the declared `test262` normative gate and waiver policy\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:20.041315774Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.372311196Z","closed_at":"2026-02-20T07:40:00.518893834Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-2ta","title":"[10.11] Implement epoch-scoped derivation for symbol/session/authentication keys with domain separation.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement epoch-scoped derivation for symbol/session/authentication keys with domain separation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.817283657Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.412710163Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-2th8","title":"[10.12] Add frontier demo gates requiring externally auditable breakthrough artifacts before frontier-track promotion.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Add frontier demo gates requiring externally auditable breakthrough artifacts before frontier-track promotion.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:41.494277732Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.453336834Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-2tx","title":"Implement deterministic eval error contract and routing reason metadata","description":"Implements PLAN 10.2 deterministic error semantics milestone for the current native-lane scaffold. Replace ad-hoc anyhow string errors with a stable typed error contract and expose deterministic routing metadata (why HybridRouter selected a lane). Add focused unit tests covering empty-source rejection and route-selection reason invariants.","status":"in_progress","priority":1,"issue_type":"task","assignee":"BrightForge","created_at":"2026-02-20T07:24:05.905124184Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.494209143Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["determinism","engine","plan","section-10-2","testing"]}
{"id":"bd-2tzx","title":"[10.15] Integrate policy theorem checks so witness promotion requires merge legality, attenuation legality, and non-interference constraints.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Integrate policy theorem checks so witness promotion requires merge legality, attenuation legality, and non-interference constraints.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:50.468229572Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.534554039Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-2u0","title":"Add reproducibility contract templates (env/manifest/repro-lock)","description":"Implements PLAN section 10.1 third TODO by adding a reproducibility contract template for env.json, manifest.json, and repro.lock with deterministic field requirements and usage guidance.","status":"in_progress","priority":1,"issue_type":"task","created_at":"2026-02-20T07:26:28.252895583Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.616789911Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["governance","plan","reproducibility","section-10-1"]}
{"id":"bd-2u5e","title":"[14] Replay correctness (determinism pass rate, artifact completeness).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Replay correctness (determinism pass rate, artifact completeness).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:33.332670275Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.657068804Z","closed_at":"2026-02-20T07:41:19.575159067Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-2vnj","title":"[10.15] Add adversarial tests for capability-escalation attempts that try to exploit synthesis uncertainty or emergency-grant pathways.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add adversarial tests for capability-escalation attempts that try to exploit synthesis uncertainty or emergency-grant pathways.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:51.666451198Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.697382171Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-2vu","title":"[10.7] Add differential lockstep suite against Node/Bun for benchmark and semantic parity cases with deterministic failure classification.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add differential lockstep suite against Node/Bun for benchmark and semantic parity cases with deterministic failure classification.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.738270700Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.740470557Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"]}
{"id":"bd-2w2g","title":"[10.15] Implement signed witness publication pipeline with transparency-log inclusion and consistency proofs.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement signed witness publication pipeline with transparency-log inclusion and consistency proofs.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:50.633439456Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.780298581Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-2w9w","title":"[10.15] Define PLAS artifact schema (`capability_witness`) with canonical fields for minimal envelope, proof obligations, confidence bounds, and replay/rollback linkage.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define PLAS artifact schema (`capability_witness`) with canonical fields for minimal envelope, proof obligations, confidence bounds, and replay/rollback linkage.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:49.802319233Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.820193579Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-2wft","title":"[15] Migration of representative Node/Bun extension packs with deterministic behavior validation artifacts.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Migration of representative Node/Bun extension packs with deterministic behavior validation artifacts.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:35.617252704Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.859879588Z","closed_at":"2026-02-20T07:45:36.986807953Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"]}
{"id":"bd-2wpo","title":"[14] Publish full run manifest: hardware, kernel, runtime versions, flags, dataset checksums, seed transcripts, and harness commit IDs.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Publish full run manifest: hardware, kernel, runtime versions, flags, dataset checksums, seed transcripts, and harness commit IDs.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:31.627651448Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.903274545Z","closed_at":"2026-02-20T07:41:20.299664980Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-2wz9","title":"[10.13] Integrate and verify cancellation lifecycle compliance (`request -> drain -> finalize`) for unload, quarantine, suspend, terminate, and revocation events using `10.11` primitives.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Integrate and verify cancellation lifecycle compliance (`request -> drain -> finalize`) for unload, quarantine, suspend, terminate, and revocation events using `10.11` primitives.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:42.638122091Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.943809836Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-2x4b","title":"[15] Reputation graph APIs for ecosystem-wide trust sharing and rapid incident response.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Reputation graph APIs for ecosystem-wide trust sharing and rapid incident response.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:35.011111687Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:34.989918868Z","closed_at":"2026-02-20T07:45:47.124828112Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"]}
{"id":"bd-2xbp","title":"[13] release gates include deterministic `frankenlab` scenario replay for security-critical lifecycle and containment paths","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: release gates include deterministic `frankenlab` scenario replay for security-critical lifecycle and containment paths\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:21.731428315Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.030982844Z","closed_at":"2026-02-20T07:39:59.703972226Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-2xe","title":"[10.1] Add FrankenEngine-native architecture synthesis document derived from donor spec (no donor-architecture mirroring).","description":"Plan Reference: section 10.1 (Charter + Governance).\nObjective: Add FrankenEngine-native architecture synthesis document derived from donor spec (no donor-architecture mirroring).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.153093730Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.114419262Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-1"]}
{"id":"bd-2xs8","title":"[13] >= 99% of declassification decisions emit signed receipt-linked replay artifacts with source/sink label provenance","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: >= 99% of declassification decisions emit signed receipt-linked replay artifacts with source/sink label provenance\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:26.166577606Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.157693484Z","closed_at":"2026-02-20T07:39:57.690544854Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-2xu5","title":"[10.15] Define TEE attestation policy for decision-receipt emitters (`approved measurements`, `attestation freshness window`, `revocation sources`, `platform trust roots`).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define TEE attestation policy for decision-receipt emitters (`approved measurements`, `attestation freshness window`, `revocation sources`, `platform trust roots`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.007786026Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.198604074Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-2y5d","title":"[10.15] Add policy guard forbidding GA releases when any core slot depends on delegate cells.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add policy guard forbidding GA releases when any core slot depends on delegate cells.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:55.092049218Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.239204115Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-2y7","title":"[10.10] Define `EngineObjectId` derivation (`domain_sep || zone_or_scope || schema_id || canonical_bytes`) for all signed security-critical objects.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Define `EngineObjectId` derivation (`domain_sep || zone_or_scope || schema_id || canonical_bytes`) for all signed security-critical objects.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.139149044Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.281034097Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-2ygl","title":"[10.13] Thread `Cx` through all effectful extension-host APIs (hostcall gateways, policy checks, lifecycle transitions, telemetry emitters).","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Thread `Cx` through all effectful extension-host APIs (hostcall gateways, policy checks, lifecycle transitions, telemetry emitters).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:42.316309546Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.323475699Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-2ytn","title":"[14] Equivalent error-class semantics for negative/exceptional cases.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Equivalent error-class semantics for negative/exceptional cases.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:29.934286468Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.365416537Z","closed_at":"2026-02-20T07:41:21.023895780Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-2zjv","title":"[13] >= 95% of high-impact decision receipts include valid non-expired attestation bindings verifiable by independent tooling","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: >= 95% of high-impact decision receipts include valid non-expired attestation bindings verifiable by independent tooling\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:23.864992957Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.406311117Z","closed_at":"2026-02-20T07:39:58.686758722Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-2zk0","title":"[16] At least 4 publishable technical reports with reproducible artifact bundles.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: At least 4 publishable technical reports with reproducible artifact bundles.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:37.061838187Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.450101241Z","closed_at":"2026-02-20T07:46:40.958674729Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"]}
{"id":"bd-3044","title":"[13] native execution lanes run without external engine bindings","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: native execution lanes run without external engine bindings\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:19.005704610Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.490920170Z","closed_at":"2026-02-20T07:40:01.015299379Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-309","title":"[10.2] Implement TS-front-end normalization contract proving TS authoring lowers to ES2020-equivalent behavior before runtime.","description":"## Plan Reference\nSection 10.2, item 13. Cross-refs: 9A.1 (TS-first authoring → native capability-typed IR execution), 9F.4 (Capability-Typed TS Execution Contract), 9C.1 (proof-carrying compilation), Phase A exit gate.\n\n## What\nImplement the TypeScript front-end normalization contract that proves TS authoring lowers to ES2020-equivalent behavior before entering the native runtime IR pipeline. This enables 'TS-first authoring' developer experience while ensuring execution is on native capability-typed IR, not transpiled JS.\n\n## Detailed Requirements\n- TS normalization pipeline: accept TS source → strip type annotations → lower TS-specific syntax (enums, namespaces, decorators, parameter properties) to ES2020-equivalent forms\n- Proof contract: emit a machine-checkable witness proving that the normalized output is behaviorally equivalent to what tsc would produce for the same source (semantic preservation proof)\n- Capability annotation preservation: TS type information that maps to capability intent (e.g., typed hostcall signatures) must be extracted and forwarded to IR2 capability annotations, not discarded during normalization\n- TS-specific features to normalize: enum declarations (numeric and string), namespace merging, const assertions, definite assignment assertions, parameter properties in constructors, legacy decorators, abstract classes\n- JSX/TSX: normalize to function calls (createElement equivalent) with correct source mapping\n- Import elision: type-only imports must be elided; value imports preserved\n- tsconfig.json alignment: respect relevant compiler options (strict, target, module, jsx, etc.)\n- Source maps: maintain source mapping from original TS through normalization for debugging\n\n## Rationale\nSection 9A.1 describes the 'TS-first authoring → native capability-typed IR execution' pipeline. The key insight is that FrankenEngine does not transpile TS to JS and then interpret JS. Instead, TS is normalized to ES2020-equivalent semantics, and the capability-typed information from TS types is extracted for the IR2 capability annotation pass. This means developers get TS ergonomics (type checking, autocomplete, refactoring) while the runtime operates on native IR that carries richer semantic information than transpiled JS would. The normalization contract proves this transformation preserves behavior, which is critical for trust - developers must be confident that their TS code behaves identically whether run through tsc+Node or through FrankenEngine's normalization+native-IR pipeline.\n\n## Testing Requirements\n- Unit tests: normalize TS enum declarations, verify ES2020-equivalent output\n- Unit tests: normalize TS namespace declarations with merging\n- Unit tests: normalize parameter properties to constructor assignments\n- Unit tests: normalize decorators to spec-compliant wrapper functions\n- Unit tests: verify type-only import elision\n- Unit tests: verify capability annotations are extracted from typed hostcall signatures\n- Unit tests: verify normalization witness artifact is emitted and valid\n- Conformance: TS compiler test suite subset for normalization correctness\n- Behavioral equivalence tests: run normalized code and tsc-compiled code, verify identical observable behavior\n- Source map tests: verify source mapping accuracy through normalization\n\n## Implementation Notes\n- Consider SWC or OXC as reference implementations for TS parsing (but normalization logic is de novo per donor-extraction policy)\n- Normalization should produce IR0 (SyntaxIR) directly, not intermediate JS text\n- Capability extraction pass runs during IR1→IR2 lowering using metadata from normalization\n- This is the only entry point where TS types are visible - after normalization, the pipeline operates on ES2020 semantics with capability annotations\n- Witness emission: record normalization decisions for evidence graph linkage\n\n## Dependencies\n- Blocked by: parser trait (bd-crp) for IR0 output target, IR contract (bd-1wa) for canonical IR0 structure\n- Blocks: TS-first developer experience, capability annotation accuracy in IR2, Phase A exit gate (TS authoring must work end-to-end)","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.973117526Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.531427679Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"]}
{"id":"bd-30g","title":"[10.11] Add VOI-budgeted monitor scheduler for high-cost diagnostic probes.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add VOI-budgeted monitor scheduler for high-cost diagnostic probes.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.519690796Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.575430378Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-30vf","title":"[10.14] Add migration policy prohibiting ad-hoc local SQLite wrappers once `frankensqlite` adapter coverage exists.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add migration policy prohibiting ad-hoc local SQLite wrappers once `frankensqlite` adapter coverage exists.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:45.865261867Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.616129904Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-32d3","title":"[10.15] Add lockstep integration checks proving synthesized minimal policies preserve intended runtime behavior across FrankenEngine/Node/Bun comparison harnesses.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add lockstep integration checks proving synthesized minimal policies preserve intended runtime behavior across FrankenEngine/Node/Bun comparison harnesses.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:51.474286116Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.656473488Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-32pl","title":"[10.12] Define trust-economics model inputs (`loss_matrix`, `attacker_cost`, `containment_cost`, `blast_radius`).","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Define trust-economics model inputs (`loss_matrix`, `attacker_cost`, `containment_cost`, `blast_radius`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:40.397225012Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.703543060Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-32r","title":"[10.8] Operational Readiness - Comprehensive Execution Epic","description":"## Plan Reference\nSection 10.8: Operational Readiness\n\n## Overview\nThis epic covers operational readiness for production deployment: runtime diagnostics, safe-mode startup, and release checklist enforcement.\n\n## Child Beads\n- bd-2mm: Add runtime diagnostics and evidence export CLI\n- bd-2qx: Add deterministic safe-mode startup flag\n- bd-ag4: Add release checklist requiring security and performance artifact bundles\n\n## Key Requirements\n- Operators can inspect runtime state and export evidence\n- Deterministic safe-mode for incident recovery\n- Release checklist blocks shipping without required evidence bundles\n- Phase E exit gate: evidence-backed operational readiness report","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.689545523Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:55.155512948Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-8"],"dependencies":[{"issue_id":"bd-32r","depends_on_id":"bd-1yq","type":"blocks","created_at":"2026-02-20T07:32:56.310471121Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-32r","depends_on_id":"bd-2mm","type":"parent-child","created_at":"2026-02-20T07:52:48.590409709Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-32r","depends_on_id":"bd-2qx","type":"parent-child","created_at":"2026-02-20T07:52:49.111258730Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-32r","depends_on_id":"bd-383","type":"blocks","created_at":"2026-02-20T07:32:56.397421973Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-32r","depends_on_id":"bd-ag4","type":"parent-child","created_at":"2026-02-20T07:52:55.155435494Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-33ce","title":"[10.12] Integrate red/blue loop outputs into guardplane calibration and policy regression suites.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Integrate red/blue loop outputs into guardplane calibration and policy regression suites.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:40.244244207Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.797419343Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-33h","title":"[10.11] Define mandatory evidence-ledger schema for all controller/security decisions (candidates, constraints, chosen action, witnesses).","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Define mandatory evidence-ledger schema for all controller/security decisions (candidates, constraints, chosen action, witnesses).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.788764733Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.837901194Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-33z","title":"[10.7] Add native-vs-delegate differential gate per execution slot with minimized repro artifacts and deterministic divergence taxonomy.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add native-vs-delegate differential gate per execution slot with minimized repro artifacts and deterministic divergence taxonomy.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.874494833Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.878729911Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"]}
{"id":"bd-34l","title":"[10.12] Implement deterministic convergence + degraded partition policy for fleet containment actions.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement deterministic convergence + degraded partition policy for fleet containment actions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.017220192Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.919345001Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-34vj","title":"[13] all advanced operator terminal UX surfaces are delivered through `/dp/frankentui` integration rather than parallel local TUI frameworks","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: all advanced operator terminal UX surfaces are delivered through `/dp/frankentui` integration rather than parallel local TUI frameworks\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:21.960249206Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:35.959929633Z","closed_at":"2026-02-20T07:39:59.597924162Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-352c","title":"[10.15] Add minimized repro artifact format for conformance failures with deterministic replay and machine-readable delta classification.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add minimized repro artifact format for conformance failures with deterministic replay and machine-readable delta classification.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:49.304135826Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.000225799Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-359","title":"[10.11] Implement idempotency-key derivation and dedup semantics for retryable remote actions.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement idempotency-key derivation and dedup semantics for retryable remote actions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.403488089Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.040943599Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-36of","title":"[10.13] Publish an operator-facing “control-plane invariants dashboard” sourced from evidence ledgers and replay artifacts.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Publish an operator-facing “control-plane invariants dashboard” sourced from evidence ledgers and replay artifacts.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:44.571246918Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.082038282Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-375","title":"[10.5] Apply full extension-host security policy path to delegate cells (same capability checks, decision contracts, and evidence obligations as untrusted extensions).","description":"## Plan Reference\nSection 10.5, item 8 (Apply full security policy to delegate cells - same as untrusted extensions). Cross-refs: 9I.6 (Verified Self-Replacement), 9A.7 (capability lattice applies uniformly), 9A.2 (Guardplane monitors all executing code), 9A.8 (resource budgets for all execution contexts).\n\n## What\nEnsure that delegate cells -- runtime-internal components that execute on behalf of the engine itself (e.g., for self-update, module replacement, or administrative tasks) -- are subject to the SAME security policy path as untrusted third-party extensions. This means delegate cells must: declare a manifest with explicit capabilities, undergo manifest validation (bd-xq7), be managed by the lifecycle manager (bd-1hu), have their hostcalls recorded by the telemetry system (bd-5pk), be monitored by the Bayesian Guardplane (bd-3md), be subject to expected-loss action selection (bd-1y5), and be containable by the same containment actions (bd-2gl). The critical principle is: delegate cells are NOT trusted just because they are part of the runtime. They execute with the least privilege necessary for their declared task.\n\n## Detailed Requirements\n- Define `DelegateCellManifest` as an `ExtensionManifest` with additional fields: `delegation_scope: DelegationScope` (what operation the cell is authorized to perform), `delegator_id: ComponentId` (which runtime component created this delegate), `max_lifetime: Duration` (hard upper bound on how long the delegate may exist).\n- `DelegationScope` enum: `ModuleReplacement`, `ConfigUpdate`, `DiagnosticCollection`, `TrustChainRotation`, `Custom(String)`.\n- Delegate cells must go through the full lifecycle: `Unloaded -> Validating -> Loading -> Starting -> Running -> ... -> Terminated`. No shortcut paths.\n- The Guardplane must maintain a separate posterior for each delegate cell, using the same Bayesian updater and the same evidence types as third-party extensions.\n- The loss matrix for delegate cells may differ from third-party extensions (e.g., the cost of false-positive termination of a critical self-update delegate may be higher), but the decision framework is identical.\n- Resource budgets for delegate cells must be strictly bounded: a delegate cell for `DiagnosticCollection` must not be able to consume unbounded CPU or memory.\n- Delegate cells must not be able to escalate their capabilities beyond their declared manifest. Attempted capability escalation is treated as a hostile act (evidence for the Guardplane).\n- Implement `DelegateCellFactory` that creates delegate cells with: validated manifest, lifecycle manager instance, telemetry hooks, Guardplane monitoring registration.\n- All delegate cell operations must produce the same telemetry, decision receipts, and evidence artifacts as third-party extension operations.\n\n## Rationale\nThe plan explicitly states that delegate cells must receive the same security treatment as untrusted extensions. This is a critical architectural principle: if delegate cells were trusted by default, an attacker who compromises the delegation mechanism could bypass all security controls. The Verified Self-Replacement protocol (9I.6) requires that replacement delegates are monitored and containable. This bead eliminates the \"trusted insider\" attack surface. The cost of this rigor is complexity in delegate cell creation, but the security benefit is that the engine's security guarantees are uniform: there is no privileged code path that bypasses the Guardplane.\n\n## Testing Requirements\n- **Unit tests**: `DelegateCellManifest` validation rejects invalid delegation scopes, missing capabilities, excessive lifetime requests. `DelegateCellFactory` produces cells that are registered with the Guardplane.\n- **Integration tests**: Create a delegate cell for `ModuleReplacement`, run it through its full lifecycle, verify telemetry is recorded, verify the Guardplane monitors it, verify it can be contained (sandbox, suspend, terminate, quarantine).\n- **Privilege escalation tests**: A delegate cell attempts to use a capability not in its manifest; verify the hostcall is denied, the denial is recorded as evidence, and the Guardplane's posterior shifts toward `Malicious`.\n- **Resource budget tests**: A delegate cell exceeds its CPU or memory budget; verify automatic containment is triggered.\n- **Parity tests**: Run identical operations through a third-party extension and a delegate cell; verify the telemetry, decision, and containment events are structurally identical (same fields, same decision process).\n- **Verified self-replacement test**: A delegate cell performing module replacement is monitored throughout; if it deviates from its declared scope, containment is triggered.\n\n## Implementation Notes\n- `DelegateCellManifest` should be a newtype or extension of `ExtensionManifest` to ensure code reuse and policy parity.\n- The `DelegateCellFactory` should be the ONLY way to create delegate cells; direct instantiation must be prevented by making the constructor private.\n- Consider a `DelegateCellPolicy` configuration that allows operators to tune the loss matrix for delegate cells separately from third-party extensions.\n- The `max_lifetime` field should be enforced by a timer that auto-triggers `Terminate` when the lifetime expires, regardless of the Guardplane's assessment.\n\n## Dependencies\n- **Blocked by**: bd-xq7 (manifest validation), bd-1hu (lifecycle manager), bd-5pk (telemetry), bd-3md (Bayesian updater), bd-1y5 (action selector), bd-2gl (containment actions). This bead integrates all prior 10.5 components.\n- **Blocks**: 9I.6 (Verified Self-Replacement cannot be implemented without monitored delegate cells).\n- **Parent**: bd-1yq (10.5 epic).","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.818352242Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.122995128Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"]}
{"id":"bd-37cc","title":"[16] At least 1 open benchmark or verification tool release adopted outside the project.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: At least 1 open benchmark or verification tool release adopted outside the project.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:37.469454326Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.163712929Z","closed_at":"2026-02-20T07:46:34.755166158Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"]}
{"id":"bd-37go","title":"[12] Prevent IFC over-constraint false denies with static-first analysis, shadow rollout, and guided label tuning","description":"Plan Reference: section 12 (Risk Register).\nObjective: IFC policy over-constraint causing false denies on benign integrations:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:18.588610065Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.205236470Z","closed_at":"2026-02-20T07:39:04.531888375Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"]}
{"id":"bd-37zd","title":"[14] Information-flow security (unauthorized source->sink block rate, declassification false-allow/false-deny envelopes, confinement-proof completeness).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Information-flow security (unauthorized source->sink block rate, declassification false-allow/false-deny envelopes, confinement-proof completeness).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:33.992455835Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.245718672Z","closed_at":"2026-02-20T07:41:19.277944011Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-383","title":"[10.7] Conformance + Verification - Comprehensive Execution Epic","description":"Plan Reference: section 10.7 (Conformance + Verification).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.626241177Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:55.397612551Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-7"],"dependencies":[{"issue_id":"bd-383","depends_on_id":"bd-11p","type":"parent-child","created_at":"2026-02-20T07:52:42.418265618Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-12m","type":"blocks","created_at":"2026-02-20T07:32:56.222490451Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-1yq","type":"blocks","created_at":"2026-02-20T07:32:56.133863056Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-2eu","type":"parent-child","created_at":"2026-02-20T07:52:47.663478151Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-2pv","type":"parent-child","created_at":"2026-02-20T07:52:48.871790918Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-2rk","type":"parent-child","created_at":"2026-02-20T07:52:49.270998500Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-2vu","type":"parent-child","created_at":"2026-02-20T07:52:49.903207078Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-33z","type":"parent-child","created_at":"2026-02-20T07:52:50.979766322Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-3c1","type":"parent-child","created_at":"2026-02-20T07:52:51.744651383Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-3u0","type":"parent-child","created_at":"2026-02-20T07:52:53.901597391Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-d93","type":"parent-child","created_at":"2026-02-20T07:52:55.397526201Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-ntq","type":"blocks","created_at":"2026-02-20T07:32:56.047365819Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-395m","title":"[13] Program Success Criteria - Comprehensive Execution Epic","description":"Plan Reference: section 13 (Program Success Criteria).\nPurpose: Operationalize this section's governance/validation/adoption requirements into enforceable engineering work.\nQuality requirements for all children:\n- explicit acceptance criteria and failure semantics\n- unit-test and e2e/integration verification expectations\n- detailed structured logging and reproducibility artifacts where applicable\n- traceability back to category-level goals (security, performance, explainability, adoption)","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:15.440835033Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:57.332829258Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-13"],"dependencies":[{"issue_id":"bd-395m","depends_on_id":"bd-11ua","type":"parent-child","created_at":"2026-02-20T07:52:42.458300587Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-1525","type":"parent-child","created_at":"2026-02-20T07:52:42.820290227Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-1elf","type":"parent-child","created_at":"2026-02-20T07:52:43.919972629Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-1f45","type":"parent-child","created_at":"2026-02-20T07:52:43.959767060Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-1h7n","type":"parent-child","created_at":"2026-02-20T07:52:44.271234477Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-1k5f","type":"parent-child","created_at":"2026-02-20T07:52:44.669751733Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-1kd2","type":"parent-child","created_at":"2026-02-20T07:52:44.773966513Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-1ko5","type":"parent-child","created_at":"2026-02-20T07:52:44.857854462Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-1qj6","type":"parent-child","created_at":"2026-02-20T07:52:45.534935379Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-1rju","type":"parent-child","created_at":"2026-02-20T07:52:45.661066640Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-1tsf","type":"blocks","created_at":"2026-02-20T07:34:37.912339690Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-1tw4","type":"parent-child","created_at":"2026-02-20T07:52:45.821166742Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-2031","type":"parent-child","created_at":"2026-02-20T07:52:46.355335412Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-28fe","type":"parent-child","created_at":"2026-02-20T07:52:47.117885714Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-29yn","type":"parent-child","created_at":"2026-02-20T07:52:47.342986695Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-2ag6","type":"parent-child","created_at":"2026-02-20T07:52:47.382703181Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-2che","type":"parent-child","created_at":"2026-02-20T07:52:47.543444717Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-2fqx","type":"parent-child","created_at":"2026-02-20T07:52:47.783987180Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-2j0k","type":"parent-child","created_at":"2026-02-20T07:52:48.216169571Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-2s6b","type":"parent-child","created_at":"2026-02-20T07:52:49.389290089Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-2t97","type":"parent-child","created_at":"2026-02-20T07:52:49.547029554Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-2xbp","type":"parent-child","created_at":"2026-02-20T07:52:50.184308857Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-2xs8","type":"parent-child","created_at":"2026-02-20T07:52:50.301387227Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-2zjv","type":"parent-child","created_at":"2026-02-20T07:52:50.538732565Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-3044","type":"parent-child","created_at":"2026-02-20T07:52:50.617836193Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-34vj","type":"parent-child","created_at":"2026-02-20T07:52:51.060629888Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-3fon","type":"parent-child","created_at":"2026-02-20T07:52:52.064045315Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-3kch","type":"parent-child","created_at":"2026-02-20T07:52:52.638673805Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-3ksg","type":"parent-child","created_at":"2026-02-20T07:52:52.757658445Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-3qh2","type":"parent-child","created_at":"2026-02-20T07:52:53.381094043Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-3qt4","type":"parent-child","created_at":"2026-02-20T07:52:53.502675390Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-3set","type":"parent-child","created_at":"2026-02-20T07:52:53.743177488Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-3tt2","type":"parent-child","created_at":"2026-02-20T07:52:53.862672289Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-3uiy","type":"parent-child","created_at":"2026-02-20T07:52:54.103640305Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-8guj","type":"parent-child","created_at":"2026-02-20T07:52:55.074105128Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-c1co","type":"blocks","created_at":"2026-02-20T07:34:38.400218754Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-pace","type":"parent-child","created_at":"2026-02-20T07:52:56.383154057Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-qozg","type":"parent-child","created_at":"2026-02-20T07:52:56.422922409Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-skw6","type":"parent-child","created_at":"2026-02-20T07:52:56.543146588Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-twz2","type":"parent-child","created_at":"2026-02-20T07:52:56.710339731Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-zzgz","type":"parent-child","created_at":"2026-02-20T07:52:57.332760489Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-39f0","title":"[10.12] Define secure extension reputation graph schema with provenance, behavior evidence, revocation edges, and trust transitions.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Define secure extension reputation graph schema with provenance, behavior evidence, revocation edges, and trust transitions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:40.716047938Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.369213813Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-3a5e","title":"[10.13] Route all high-impact safety actions through `franken-decision` decision contracts with explicit loss matrices and fallback policies.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Route all high-impact safety actions through `franken-decision` decision contracts with explicit loss matrices and fallback policies.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:42.954526812Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.409339471Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-3ab3","title":"[10.15] Build verifier pipeline that validates signature chain, transparency log proofs, and attestation chain in one deterministic command.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Build verifier pipeline that validates signature chain, transparency log proofs, and attestation chain in one deterministic command.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.330897951Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.452569902Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-3ai","title":"[10.10] Split principal key roles into signing/encryption/issuance and enforce independent revocation.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Split principal key roles into signing/encryption/issuance and enforce independent revocation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.538665659Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.493108920Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-3azm","title":"[10.14] Add an ADR declaring `/dp/frankensqlite` as the required substrate for SQLite-backed control-plane persistence in FrankenEngine.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add an ADR declaring `/dp/frankensqlite` as the required substrate for SQLite-backed control-plane persistence in FrankenEngine.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:45.221039936Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.532801631Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-3b5m","title":"[10.12] Implement runtime decision scoring with explicit expected-loss and attacker-ROI outputs.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement runtime decision scoring with explicit expected-loss and attacker-ROI outputs.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:40.555565450Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.573121130Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-3bc","title":"[10.10] Reject non-canonical encodings for security-critical object classes (no silent normalization).","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Reject non-canonical encodings for security-critical object classes (no silent normalization).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.279236382Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.616348835Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-3bz4","title":"Implement ecosystem capture strategy for platform adoption and migration","description":"## Plan Reference\nSection 15: Ecosystem Capture Strategy\n\n## What\nFrankenEngine should not only outperform incumbents; it should become the default platform for high-trust extension ecosystems. This bead covers the full ecosystem capture strategy.\n\n## Execution Pillars\n1. **Signed extension registry**: Enforceable provenance, attestation, and revocation policies for all published extensions\n2. **Migration kits**: Convert existing Node/Bun extension workflows into capability-typed FrankenEngine workflows with deterministic behavior validation\n3. **Enterprise governance hooks**: Policy-as-code pipelines, audit export, and compliance evidence contracts for enterprise adoption\n4. **Reputation graph APIs**: Ecosystem-wide trust sharing and rapid incident response across the extension ecosystem\n5. **Partner program**: Early lighthouse adopters who validate category-shift outcomes in production environments\n\n## Adoption Targets\n- **Greenfield onboarding**: Minimal-friction deterministic safe-extension setup workflow for new users\n- **Migration validation**: Representative Node/Bun extension packs migrated with deterministic behavior validation artifacts proving equivalence\n- **Public case studies**: Documented real-world deployments showing materially improved security and operational outcomes\n\n## Rationale\nThe plan states: 'FrankenEngine should not only outperform incumbents; it should become the default platform for high-trust extension ecosystems.' This means the technical advantages (3x performance, deterministic security, proof-carrying decisions) must be coupled with practical adoption infrastructure. Without migration kits, enterprise hooks, and ecosystem trust mechanisms, technical superiority alone will not drive adoption.\n\n## Dependencies\n- Requires signed extension registry from 10.10 (FCP-Inspired Hardening)\n- Requires reputation graph from 10.12 (Frontier Programs)\n- Requires capability-typed IR from 10.2 (VM Core) for migration kits\n- Requires benchmark suite from 10.6/14 for case study evidence\n- Requires franken_node compatibility from Phase D for migration targets\n\n## Testing Requirements\n- Integration tests for migration kit: convert sample Node extension, verify capability-typed output, validate behavioral equivalence via lockstep\n- E2E test for greenfield onboarding workflow: new user can create, validate, and deploy a capability-typed extension with deterministic setup\n- Test for enterprise governance hook: policy-as-code pipeline validates extension, exports audit trail, produces compliance evidence\n- Test for reputation graph API: trust queries return correct scores, revocation events propagate to trust scores\n\n## Implementation Notes\n- Migration kits should leverage the tri-runtime lockstep oracle (9F.6) for behavior validation\n- Enterprise governance hooks should consume decision contracts and evidence ledgers from asupersync integration (10.13)\n- Signed registry should use FCP-inspired identity and revocation primitives from 10.10\n- Partner program should produce the case studies required by Section 16 (Scientific Contributions)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:46:21.021289385Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:43.427089427Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["adoption","ecosystem","migration","strategy"]}
{"id":"bd-3c1","title":"[10.7] Add stress tests for high-concurrency extension workloads.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add stress tests for high-concurrency extension workloads.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.603186612Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.657016412Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"]}
{"id":"bd-3c8n","title":"[16] At least 2 externally replicated high-impact claims.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: At least 2 externally replicated high-impact claims.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:37.267143165Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.722625195Z","closed_at":"2026-02-20T07:46:37.785839076Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"]}
{"id":"bd-3ch","title":"[10.4] Module + Runtime Surface - Comprehensive Execution Epic","description":"## Plan Reference\nSection 10.4: Module + Runtime Surface\n\n## Overview\nThis epic covers module resolution, caching, and compatibility for FrankenEngine's module system. This is the bridge between the VM core and the franken_node compatibility surface (Phase D).\n\n## Child Beads\n- bd-tgv: Implement module resolver trait with policy hooks (foundational)\n- bd-16x: Implement module cache invalidation strategy\n- bd-3vp: Add explicit compatibility mode matrix for Node/Bun module edge cases\n\n## Dependency Chain\nbd-tgv (resolver) → bd-16x (cache invalidation) → bd-3vp (compatibility matrix)\n\n## Key Requirements\n- Policy hooks at resolution time for capability enforcement\n- Cache invalidation on trust revocation events\n- No hidden shims for compatibility (explicit, testable, documented)\n- Support both ESM and CJS for Phase D Node/Bun superset","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.430649522Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:56.630185106Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-4"],"dependencies":[{"issue_id":"bd-3ch","depends_on_id":"bd-16x","type":"parent-child","created_at":"2026-02-20T07:52:43.106419710Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ch","depends_on_id":"bd-3vp","type":"parent-child","created_at":"2026-02-20T07:52:54.342897805Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ch","depends_on_id":"bd-ntq","type":"blocks","created_at":"2026-02-20T07:32:55.522152454Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ch","depends_on_id":"bd-tgv","type":"parent-child","created_at":"2026-02-20T07:52:56.630112200Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ciq","title":"[10.15] Implement delegate-cell runtime harness for not-yet-native slots with explicit capability envelopes, sandbox controls, and replay hooks.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement delegate-cell runtime harness for not-yet-native slots with explicit capability envelopes, sandbox controls, and replay hooks.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:54.063910753Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.806313202Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-3db2","title":"[14] No work dropping, relaxed durability, or disabled policy checks to inflate throughput.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: No work dropping, relaxed durability, or disabled policy checks to inflate throughput.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:30.185215499Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.849935122Z","closed_at":"2026-02-20T07:41:20.924285308Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-3de4","title":"[14] Include both performance and security co-metrics (not speed-only benchmarks).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Include both performance and security co-metrics (not speed-only benchmarks).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:27.810159997Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.900931808Z","closed_at":"2026-02-20T07:41:21.924584896Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-3e7","title":"[10.11] Add append-only hash-linked decision marker stream for high-impact security/policy transitions.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add append-only hash-linked decision marker stream for high-impact security/policy transitions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:37.318303109Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.950018096Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-3ebk","title":"[16] Open specifications for core trust/replay/policy primitives.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: Open specifications for core trust/replay/policy primitives.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:36.038965842Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:36.990677818Z","closed_at":"2026-02-20T07:46:58.631056580Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"]}
{"id":"bd-3fon","title":"[13] high-risk detections reach containment in `<= 250ms` median time under defined load envelopes","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: high-risk detections reach containment in `<= 250ms` median time under defined load envelopes\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:20.672412706Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.030712326Z","closed_at":"2026-02-20T07:40:00.207375906Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-3fr","title":"Add runtime charter codifying native-only engine policy","description":"Implements PLAN section 10.1 first TODO: add a runtime charter document that formalizes FrankenEngine's native-only execution doctrine and non-negotiable boundaries. Include explicit prohibition of binding-led execution cores and define acceptance criteria for architectural changes.","status":"closed","priority":1,"issue_type":"task","assignee":"StormyPond","created_at":"2026-02-20T07:23:21.056176395Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.111244084Z","closed_at":"2026-02-20T07:24:14.801246681Z","close_reason":"Added docs/RUNTIME_CHARTER.md and linked it from README to codify native-only runtime governance contract","source_repo":".","compaction_level":0,"original_size":0,"labels":["architecture","governance","plan","section-10-1"]}
{"id":"bd-3g4","title":"[10.0] Top-10 #4: Alien-performance profile discipline and hotpath program gates (strategy: `9A.4`; deep semantics: `9F.1`, `9F.12`, `9F.14`; execution owners: `10.6`, `10.12`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #4: Alien-performance profile discipline and hotpath program gates (strategy: `9A.4`; deep semantics: `9F.1`, `9F.12`, `9F.14`; execution owners: `10.6`, `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:19.640070759Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.150994282Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"]}
{"id":"bd-3gsv","title":"[10.12] Implement third-party verifier toolkit that can independently validate benchmark, replay, and containment claims.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement third-party verifier toolkit that can independently validate benchmark, replay, and containment claims.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:41.339396718Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.192620816Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-3h31","title":"[14] Compute suite score `S_B = exp(sum_i w_i * ln(r_i))`, with non-zero weights summing to `1` and equal weighting across family/profile cells by default.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Compute suite score `S_B = exp(sum_i w_i * ln(r_i))`, with non-zero weights summing to `1` and equal weighting across family/profile cells by default.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:30.676909298Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.232328555Z","closed_at":"2026-02-20T07:41:20.725587397Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-3h61","title":"[14] Require reproducibility artifacts for every published result.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Require reproducibility artifacts for every published result.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:28.043791177Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.272628628Z","closed_at":"2026-02-20T07:41:21.819283503Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-3hj","title":"[10.0] Top-10 #5: Supply-chain trust fabric integrated with containment policy (strategy: `9A.5`; deep semantics: `9F.11`, `9F.9`; execution owners: `10.10`, `10.12`, `10.13`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #5: Supply-chain trust fabric integrated with containment policy (strategy: `9A.5`; deep semantics: `9F.11`, `9F.9`; execution owners: `10.10`, `10.12`, `10.13`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:19.764889026Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.312305019Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"]}
{"id":"bd-3hkk","title":"[10.15] Implement declassification decision pipeline (`request -> policy/loss evaluation -> allow/deny -> signed receipt`) with deterministic replay.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement declassification decision pipeline (`request -> policy/loss evaluation -> allow/deny -> signed receipt`) with deterministic replay.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:52.505599946Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.351931006Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-3ix","title":"[10.11] Add systematic interleaving explorer coverage for checkpoint/revocation/policy-update race surfaces.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add systematic interleaving explorer coverage for checkpoint/revocation/policy-update race surfaces.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.644665211Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.392257928Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-3j5s","title":"[15] Public case studies showing materially improved security and operational outcomes.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Public case studies showing materially improved security and operational outcomes.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:35.820092460Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.432641968Z","closed_at":"2026-02-20T07:45:33.991333421Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"]}
{"id":"bd-3jg","title":"[10.2] Implement static flow-check pass proving source/sink legality and emitting flow-proof witness artifacts.","description":"## Plan Reference\nSection 10.2, item 5. Cross-refs: 9I.7 (IFC), 9C.1 (proof-carrying compilation), 10.15 (IFC artifacts).\n\n## What\nImplement a static analysis pass over IR2 that proves source-to-sink data flow legality using the IFC flow-lattice, and emits flow-proof witness artifacts for audit and replay.\n\n## Detailed Requirements\n- Analyze IR2 data flow paths to verify all source→sink flows comply with flow-lattice constraints\n- Emit flow-proof witness artifact for each analyzed extension/module containing: proved flows, denied flows, required declassifications\n- Reject compilation when unauthorized flows are detected (fail-closed)\n- Handle dynamic/late-bound paths by inserting runtime check points (runtime enforcement for paths that cannot be statically proven)\n- Witness artifacts must be deterministically serializable for evidence graph linkage\n\n## Rationale\nPer 9I.7: static compiler checks prove allowed flows where possible; runtime checks cover dynamic/late-bound paths. The flow-check pass is the static half of this design. It feeds into the evidence graph (9A.3) and enables the proof-guided specialization flywheel (9I.8) - regions with proven-safe IFC can have flow checks elided at runtime.\n\n## Testing Requirements\n- Unit tests: pass accepts code with only authorized flows\n- Unit tests: pass rejects code with unauthorized source→sink flows\n- Unit tests: pass correctly identifies flows requiring declassification\n- Unit tests: witness artifact contains correct flow analysis results\n- IFC conformance corpus tests (10.7): benign dual-capability, exfil-attempt, declassification-exception workloads\n\n## Dependencies\n- Blocked by: IFC flow-lattice semantics (bd-1fm), lowering pipelines (bd-ug9)\n- Blocks: runtime flow-label propagation (10.5), PLAS flow envelope synthesis (10.15), proof-guided specialization (10.15)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.933103541Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.472742639Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"]}
{"id":"bd-3jy","title":"[10.5] Route all declassification requests through decision contracts with mandatory signed receipt + evidence linkage.","description":"Plan Reference: section 10.5 (Extension Host + Security).\nObjective: Route all declassification requests through decision contracts with mandatory signed receipt + evidence linkage.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:25.084975407Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.512745758Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"]}
{"id":"bd-3jz8","title":"[10.15] Implement budget accountant for differential privacy with epoch-scoped burn tracking and hard fail-closed budget exhaustion behavior.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement budget accountant for differential privacy with epoch-scoped burn tracking and hard fail-closed budget exhaustion behavior.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.823976890Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.552525913Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-3kch","title":"[13] post-burn-in false-deny rate for PLAS-enforced policies remains <= 0.5% on defined benign extension corpora","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: post-burn-in false-deny rate for PLAS-enforced policies remains <= 0.5% on defined benign extension corpora\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:25.462814610Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.592752058Z","closed_at":"2026-02-20T07:39:57.987420819Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-3kd","title":"[10.10] Add golden vectors for critical binary encodings and verification paths.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Add golden vectors for critical binary encodings and verification paths.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.691915950Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.632741732Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-3kks","title":"[10.15] Implement runtime capability escrow pathway for out-of-envelope requests (`challenge`/`sandbox` default), including explicit emergency-grant artifact format and expiry semantics.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement runtime capability escrow pathway for out-of-envelope requests (`challenge`/`sandbox` default), including explicit emergency-grant artifact format and expiry semantics.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:50.801745266Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.673153463Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-3ksg","title":"[13] category benchmark standard is adopted by external runtime/security research participants","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: category benchmark standard is adopted by external runtime/security research participants\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:23.650704726Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.712755154Z","closed_at":"2026-02-20T07:39:58.788546781Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-3lt3","title":"[10.15] Add frankentui operator surfaces for flow decisions (`label map`, `blocked flows`, `declassification history`, `confinement proofs`).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankentui operator surfaces for flow decisions (`label map`, `blocked flows`, `declassification history`, `confinement proofs`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:53.550205413Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.752349493Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-3md","title":"[10.5] Implement Bayesian posterior updater API.","description":"## Plan Reference\nSection 10.5, item 4 (Implement Bayesian posterior updater API). Cross-refs: 9A.2 (Probabilistic Guardplane - Bayesian + sequential inference), 9C.2 (full Bayesian decision loop: classify -> quantify -> decide -> explain -> calibrate), 9B.2 (conformal prediction, e-process, BOCPD for online change detection).\n\n## What\nImplement the core Guardplane inference component that maintains a posterior probability distribution over extension risk states. For each monitored extension, the posterior updater takes hostcall telemetry evidence and updates a Bayesian belief about whether the extension is behaving within its declared capability envelope or exhibiting anomalous/malicious behavior. This is the \"classify + quantify\" stage of the 9C.2 decision loop. The updater supports multiple inference strategies: conjugate-prior updates for simple models, sequential e-process testing for anytime-valid confidence, and Bayesian Online Change Point Detection (BOCPD) for detecting behavioral regime shifts.\n\n## Detailed Requirements\n- Define `RiskState` enum: `Benign`, `Anomalous`, `Malicious`, `Unknown`.\n- Define `Posterior` struct holding probability mass over `RiskState` values: `P(Benign)`, `P(Anomalous)`, `P(Malicious)`, `P(Unknown)`, with invariant that probabilities sum to 1.0 (within floating-point tolerance).\n- Define `Evidence` struct wrapping a `HostcallTelemetryRecord` with derived features: `hostcall_rate`, `capability_usage_pattern`, `resource_consumption_rate`, `timing_anomaly_score`.\n- Implement `BayesianPosteriorUpdater` with methods:\n  - `new(prior: Posterior) -> Self` - initialize with a configurable prior (default: high `P(Benign)` for new extensions).\n  - `update(&mut self, evidence: &Evidence) -> UpdateResult` - perform one Bayesian update step, returning the new posterior and the likelihood ratio.\n  - `posterior(&self) -> &Posterior` - current belief state.\n  - `log_likelihood_ratio(&self) -> f64` - cumulative log-likelihood ratio for sequential testing.\n  - `change_point_probability(&self) -> f64` - BOCPD run-length posterior for regime change detection.\n  - `reset(&mut self, prior: Posterior)` - reset to a new prior (e.g., after containment action).\n  - `calibration_check(&self, ground_truth: RiskState) -> CalibrationResult` - check posterior calibration against known ground truth (for testing/monitoring).\n- Implement likelihood functions for each evidence type:\n  - `hostcall_rate_likelihood(rate: f64, state: RiskState) -> f64` - model hostcall rate distribution per risk state.\n  - `capability_pattern_likelihood(pattern: &CapabilityPattern, state: RiskState) -> f64` - model capability usage patterns.\n- All floating-point operations must be deterministic (no platform-dependent rounding). Use `f64` with explicit rounding where needed.\n- The updater must be serializable for checkpoint/replay.\n- Implement the BOCPD component: maintain a run-length distribution and detect when the generative model changes (indicating behavioral regime shift).\n\n## Rationale\nThe Probabilistic Guardplane (9A.2) is the security decision backbone of FrankenEngine. Unlike traditional rule-based systems that produce binary allow/deny decisions, the Bayesian approach maintains calibrated uncertainty over extension risk. This enables the expected-loss action selector (bd-1y5) to make cost-sensitive decisions: a high-uncertainty posterior leads to a \"challenge\" or \"sandbox\" action rather than an immediate terminate. The BOCPD component detects subtle behavioral shifts that would be invisible to threshold-based detection. Per 9C.2, every decision must be explainable by reference to the posterior and evidence chain.\n\n## Testing Requirements\n- **Unit tests**: Posterior initialization sums to 1.0. Single evidence update moves posterior in correct direction (benign evidence increases `P(Benign)`, malicious evidence increases `P(Malicious)`). Multiple sequential updates converge to correct state. Likelihood functions produce valid probabilities. Serialization round-trip preserves posterior exactly.\n- **Calibration tests**: Generate synthetic evidence sequences with known ground truth. Verify that posterior `P(state)` is well-calibrated (e.g., when posterior says P(Malicious) = 0.8, approximately 80% of such cases are truly malicious).\n- **BOCPD tests**: Inject a regime change in synthetic evidence (benign -> malicious at step N). Verify change-point detection triggers within a bounded delay.\n- **Determinism tests**: Run identical evidence sequences on two independent updater instances; verify bit-identical posteriors.\n- **Edge case tests**: All-zero evidence, NaN/infinity guards, underflow protection for very small probabilities, prior with zero mass on some states.\n\n## Implementation Notes\n- Use log-space arithmetic internally to avoid underflow: store `log P(state)` and use `log_sum_exp` for normalization.\n- The conjugate prior for hostcall rate modeling is Gamma-Poisson; for capability patterns, consider Dirichlet-Multinomial.\n- BOCPD implementation follows Adams & MacKay (2007): maintain a vector of run-length probabilities, prune low-probability run lengths for efficiency.\n- Deterministic floating-point: avoid `fast-math`, pin to `f64`, test on CI with the same target triple.\n- The `Evidence` feature extraction from raw `HostcallTelemetryRecord` should be a separate function, not embedded in the updater.\n\n## Dependencies\n- **Blocked by**: bd-5pk (telemetry recorder provides the evidence stream).\n- **Blocks**: bd-1y5 (expected-loss action selector consumes posterior), bd-t2m (forensic replay must reproduce posterior trajectories), bd-2gl (containment actions are triggered by posterior thresholds).\n- **Parent**: bd-1yq (10.5 epic).","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.283640895Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.792026244Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"]}
{"id":"bd-3mu","title":"[10.10] Add fuzz/adversarial targets for decode DoS, replay/splice handshake attacks, and token verification edge cases.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Add fuzz/adversarial targets for decode DoS, replay/splice handshake attacks, and token verification edge cases.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.834784649Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.832130302Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-3mx","title":"[10.0] Top-10 #10: Provenance + revocation fabric and recall workflow (strategy: `9A.10`; deep semantics: `9F.9`; execution owners: `10.10`, `10.11`, `10.12`, `10.13`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #10: Provenance + revocation fabric and recall workflow (strategy: `9A.10`; deep semantics: `9F.9`; execution owners: `10.10`, `10.11`, `10.12`, `10.13`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:20.401176718Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.872125366Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"]}
{"id":"bd-3n0","title":"[10.10] Enforce cross-zone reference constraints (provenance/audit allowed, authority leakage forbidden).","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Enforce cross-zone reference constraints (provenance/audit allowed, authority leakage forbidden).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.956701459Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.911831262Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-3nc","title":"[10.11] Implement e-process guardrail integration that can hard-block unsafe automatic retunes.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement e-process guardrail integration that can hard-block unsafe automatic retunes.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.225966982Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.953733439Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-3ncx","title":"[10.15] Define moonshot contract schema (`hypothesis`, `target metrics`, `EV model`, `risk budget`, `artifact obligations`, `kill criteria`, `rollback plan`).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define moonshot contract schema (`hypothesis`, `target metrics`, `EV model`, `risk budget`, `artifact obligations`, `kill criteria`, `rollback plan`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:48.311102630Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:37.993244392Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-3nr","title":"[10.13] Asupersync Constitutional Integration Track - Comprehensive Execution Epic","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:19.008944962Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:57.128894209Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-13"],"dependencies":[{"issue_id":"bd-3nr","depends_on_id":"bd-11z7","type":"parent-child","created_at":"2026-02-20T07:52:42.498386321Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-1o7u","type":"parent-child","created_at":"2026-02-20T07:52:45.257921244Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-1rdj","type":"parent-child","created_at":"2026-02-20T07:52:45.620945752Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-1ukb","type":"parent-child","created_at":"2026-02-20T07:52:45.863634823Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-23om","type":"parent-child","created_at":"2026-02-20T07:52:46.559258157Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-24bu","type":"parent-child","created_at":"2026-02-20T07:52:46.599350102Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-2fa1","type":"parent-child","created_at":"2026-02-20T07:52:47.748398453Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-2g9","type":"blocks","created_at":"2026-02-20T07:32:57.630221276Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-2py0","type":"parent-child","created_at":"2026-02-20T07:52:48.950784862Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-2sbb","type":"parent-child","created_at":"2026-02-20T07:52:49.467994834Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-2wz9","type":"parent-child","created_at":"2026-02-20T07:52:50.105054398Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-2ygl","type":"parent-child","created_at":"2026-02-20T07:52:50.458551690Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-36of","type":"parent-child","created_at":"2026-02-20T07:52:51.180436379Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-3a5e","type":"parent-child","created_at":"2026-02-20T07:52:51.506938701Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-3q36","type":"parent-child","created_at":"2026-02-20T07:52:53.301699073Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-3vh","type":"blocks","created_at":"2026-02-20T07:32:57.541284936Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-3vlb","type":"parent-child","created_at":"2026-02-20T07:52:54.303182982Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-jaqy","type":"parent-child","created_at":"2026-02-20T07:52:55.980007768Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-m9pa","type":"parent-child","created_at":"2026-02-20T07:52:56.182715571Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-uvmm","type":"parent-child","created_at":"2026-02-20T07:52:56.830507826Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-ypl4","type":"parent-child","created_at":"2026-02-20T07:52:57.128820111Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3o95","title":"[10.14] Build a thin integration template for service endpoints (health, control actions, evidence export, replay control) using `fastapi_rust` conventions/components where relevant.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Build a thin integration template for service endpoints (health, control actions, evidence export, replay control) using `fastapi_rust` conventions/components where relevant.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:46.353647664Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.072938790Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-3oc","title":"[10.12] Build policy theorem compiler passes and machine-check hooks for non-interference and merge determinism.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Build policy theorem compiler passes and machine-check hooks for non-interference and merge determinism.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.785361094Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.112000697Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-3ovc","title":"[10.12] Implement low-latency reputation updates and explainable trust-card generation for operators.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement low-latency reputation updates and explainable trust-card generation for operators.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:40.869149197Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.151633196Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-3pl","title":"[10.10] Enforce deterministic ordering for multi-signature arrays before verification.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Enforce deterministic ordering for multi-signature arrays before verification.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.695572103Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.191858900Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-3q36","title":"[10.13] Add migration compatibility tests ensuring control-plane schema evolution preserves replay compatibility or fails with explicit machine-readable migration errors.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add migration compatibility tests ensuring control-plane schema evolution preserves replay compatibility or fails with explicit machine-readable migration errors.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:44.092670713Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.231748919Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-3q9","title":"[10.15] Delta Moonshots Execution Track (9I) - Comprehensive Execution Epic","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:19.166766614Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:56.099505945Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-15"],"dependencies":[{"issue_id":"bd-3q9","depends_on_id":"bd-12n5","type":"parent-child","created_at":"2026-02-20T07:52:42.617690145Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-133a","type":"parent-child","created_at":"2026-02-20T07:52:42.696876527Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-15g2","type":"parent-child","created_at":"2026-02-20T07:52:42.860382893Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-17v2","type":"parent-child","created_at":"2026-02-20T07:52:43.146812175Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1999","type":"parent-child","created_at":"2026-02-20T07:52:43.307011571Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1fu7","type":"parent-child","created_at":"2026-02-20T07:52:44.081941541Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1g5c","type":"parent-child","created_at":"2026-02-20T07:52:44.165825082Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1gcu","type":"parent-child","created_at":"2026-02-20T07:52:44.220572314Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1hh4","type":"parent-child","created_at":"2026-02-20T07:52:44.312650729Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1ilz","type":"parent-child","created_at":"2026-02-20T07:52:44.545933510Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1jqt","type":"parent-child","created_at":"2026-02-20T07:52:44.628421672Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1kdc","type":"parent-child","created_at":"2026-02-20T07:52:44.817730558Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1kzo","type":"parent-child","created_at":"2026-02-20T07:52:44.900943019Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1n78","type":"parent-child","created_at":"2026-02-20T07:52:45.060331485Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1ovk","type":"parent-child","created_at":"2026-02-20T07:52:45.336633133Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1r25","type":"parent-child","created_at":"2026-02-20T07:52:45.577335413Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1v90","type":"parent-child","created_at":"2026-02-20T07:52:45.948157735Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1yq","type":"blocks","created_at":"2026-02-20T07:32:58.147892723Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-24ie","type":"parent-child","created_at":"2026-02-20T07:52:46.639675221Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-25b7","type":"parent-child","created_at":"2026-02-20T07:52:46.759581448Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-27i1","type":"parent-child","created_at":"2026-02-20T07:52:46.957885989Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-29a1","type":"parent-child","created_at":"2026-02-20T07:52:47.220575082Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-2ftv","type":"parent-child","created_at":"2026-02-20T07:52:47.826363110Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-2gej","type":"parent-child","created_at":"2026-02-20T07:52:47.976662496Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-2lr7","type":"parent-child","created_at":"2026-02-20T07:52:48.453073347Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-2lt9","type":"parent-child","created_at":"2026-02-20T07:52:48.507421766Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-2nxj","type":"parent-child","created_at":"2026-02-20T07:52:48.792882464Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-2r6","type":"blocks","created_at":"2026-02-20T07:32:57.803135730Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-2tzx","type":"parent-child","created_at":"2026-02-20T07:52:49.705505951Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-2vnj","type":"parent-child","created_at":"2026-02-20T07:52:49.863015718Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-2w2g","type":"parent-child","created_at":"2026-02-20T07:52:49.943119058Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-2w9w","type":"parent-child","created_at":"2026-02-20T07:52:49.982581130Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-2xu5","type":"parent-child","created_at":"2026-02-20T07:52:50.341513365Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-2y5d","type":"parent-child","created_at":"2026-02-20T07:52:50.380491025Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-32d3","type":"parent-child","created_at":"2026-02-20T07:52:50.778824479Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-352c","type":"parent-child","created_at":"2026-02-20T07:52:51.100913921Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-383","type":"blocks","created_at":"2026-02-20T07:32:58.234088558Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-3ab3","type":"parent-child","created_at":"2026-02-20T07:52:51.546524834Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-3ciq","type":"parent-child","created_at":"2026-02-20T07:52:51.864858010Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-3hkk","type":"parent-child","created_at":"2026-02-20T07:52:52.401454732Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-3jz8","type":"parent-child","created_at":"2026-02-20T07:52:52.599182539Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-3kks","type":"parent-child","created_at":"2026-02-20T07:52:52.717650727Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-3lt3","type":"parent-child","created_at":"2026-02-20T07:52:52.797365944Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-3ncx","type":"parent-child","created_at":"2026-02-20T07:52:53.034996343Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-3nr","type":"blocks","created_at":"2026-02-20T07:32:57.889983660Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-3rgq","type":"parent-child","created_at":"2026-02-20T07:52:53.624483159Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-3sq4","type":"parent-child","created_at":"2026-02-20T07:52:53.782656712Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-6qsi","type":"parent-child","created_at":"2026-02-20T07:52:54.741692798Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-7rwi","type":"parent-child","created_at":"2026-02-20T07:52:54.916418411Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-83jh","type":"parent-child","created_at":"2026-02-20T07:52:54.955680391Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-ami3","type":"parent-child","created_at":"2026-02-20T07:52:55.194894520Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-kfe4","type":"parent-child","created_at":"2026-02-20T07:52:56.059250575Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-kr99","type":"parent-child","created_at":"2026-02-20T07:52:56.099429252Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-ntq","type":"blocks","created_at":"2026-02-20T07:32:58.060658013Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-zvn","type":"blocks","created_at":"2026-02-20T07:32:57.975537360Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3qh2","title":"[13] every promoted `delegate -> native` core slot has a signed replacement receipt with reproducible differential/security/performance artifacts","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: every promoted `delegate -> native` core slot has a signed replacement receipt with reproducible differential/security/performance artifacts\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:27.109383954Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.311657085Z","closed_at":"2026-02-20T07:39:57.294852766Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-3qhv","title":"[15] Greenfield onboarding uses a minimal-friction deterministic safe-extension setup workflow.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Greenfield onboarding uses a minimal-friction deterministic safe-extension setup workflow.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:35.415623153Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.351870517Z","closed_at":"2026-02-20T07:45:41.075897502Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"]}
{"id":"bd-3qm1","title":"[11] Require EV scoring output and tier classification","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: EV score and tier\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:16.275442400Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.397968398Z","closed_at":"2026-02-20T07:38:23.302829750Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-3qm1","depends_on_id":"bd-18fu","type":"blocks","created_at":"2026-02-20T07:38:26.041084965Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3qm1","depends_on_id":"bd-2ntw","type":"blocks","created_at":"2026-02-20T07:38:25.921720016Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3qt4","title":"[13] unauthorized sensitive-source -> external-sink flows are deterministically blocked unless explicit declassification is approved by policy","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: unauthorized sensitive-source -> external-sink flows are deterministically blocked unless explicit declassification is approved by policy\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:25.932500234Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.441252148Z","closed_at":"2026-02-20T07:39:57.789509804Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-3qv","title":"[10.6] Add constrained-vs-ambient benchmark lanes quantifying specialization uplift from PLAS/IFC proof tightening under equivalent behavior.","description":"## Plan Reference\nSection 10.6, item 6. Cross-refs: 9I.5 (PLAS), 9I.7 (IFC), 9I.8 (Security-Proof-Guided Specialization), Phase C exit gate.\n\n## What\nAdd benchmark lanes that compare constrained-mode execution (with PLAS/IFC security constraints active) against ambient-authority mode, quantifying the performance uplift from security proof tightening.\n\n## Detailed Requirements\n- Constrained lane: run benchmarks with PLAS capability witnesses and IFC flow proofs active, enabling proof-guided specialization\n- Ambient lane: run same benchmarks without security proofs, using generic dynamic checks\n- Measure: throughput delta, p50/p95/p99 latency delta, memory/allocation delta\n- Equivalent behavior requirement: both lanes must produce identical outputs (canonical digest match)\n- Per-specialization attribution: which security proofs contributed which performance gains\n- Publication format: structured results suitable for Section 14 benchmark reports\n\n## Rationale\nSection 9I.8: 'Make security proofs first-class optimizer inputs so tighter verified constraints yield faster executable paths instead of being treated as overhead.' This benchmark lane proves the flywheel: security investment → better proofs → faster code. Phase C exit gate explicitly requires: 'constrained-mode benchmark lane demonstrates measurable speedup versus ambient-authority mode on the same workloads with identical outputs and policy outcomes.'\n\n## Testing Requirements\n- Benchmark: constrained lane produces equal or better performance than ambient lane\n- Verification: both lanes produce identical behavior (canonical digest match)\n- Per-proof attribution: removing specific proofs degrades specific specializations\n- Regression: constrained lane performance does not regress below ambient lane after changes\n\n## Dependencies\n- Blocked by: PLAS (10.15), IFC (10.15/10.2), proof-to-specialization linkage (10.2 bd-161), benchmark suite (bd-2ql)\n- Blocks: Phase C exit gate, Security-Proof-Guided Specialization validation","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:25.886536901Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.486827717Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-6"]}
{"id":"bd-3rd","title":"[10.9] Release gate: continuous adversarial campaign runner demonstrates measurable compromise-rate suppression versus baseline engines (implementation ownership: `10.12`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: continuous adversarial campaign runner demonstrates measurable compromise-rate suppression versus baseline engines (implementation ownership: `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.284422049Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.526857286Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"]}
{"id":"bd-3rgq","title":"[10.15] Build conformance-vector generator and property/fuzz harness for cross-repo boundary invariants, including degraded/fault-mode scenarios.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Build conformance-vector generator and property/fuzz harness for cross-repo boundary invariants, including degraded/fault-mode scenarios.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:48.971309556Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.566488943Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-3s3","title":"[10.11] Implement named remote computation registry with deterministic input encoding and schema validation.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement named remote computation registry with deterministic input encoding and schema validation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.257470024Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.606544140Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-3s6","title":"[10.10] Define mandatory runtime metrics and structured logs for auth/capability/replay/revocation/checkpoint failures.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Define mandatory runtime metrics and structured logs for auth/capability/replay/revocation/checkpoint failures.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.116293518Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.646273460Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-3set","title":"[13] extension-heavy benchmark suites show `>= 3x` weighted-geometric-mean throughput versus Node baseline and `>= 3x` versus Bun baseline under Section `14` denominator and equivalence rules","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: extension-heavy benchmark suites show `>= 3x` weighted-geometric-mean throughput versus Node baseline and `>= 3x` versus Bun baseline under Section `14` denominator and equivalence rules\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:20.256995867Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.686158309Z","closed_at":"2026-02-20T07:40:00.419810734Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-3sq4","title":"[10.15] Add frankentui operator dashboard for replacement progress (`slot status`, `native coverage`, `blocked promotions`, `rollback events`, `next-best-EV replacements`).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankentui operator dashboard for replacement progress (`slot status`, `native coverage`, `blocked promotions`, `rollback events`, `next-best-EV replacements`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:54.750417096Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.732243196Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-3t2d","title":"[MASTER] Execute PLAN 1-16 as self-contained bead graph","description":"Full-program orchestration epic spanning PLAN sections 1-16.\nThis includes architecture doctrine, execution tracks, evidence contracts, risk controls, success-criteria verification, benchmarking/standardization, ecosystem strategy, and scientific output obligations.\nCompletion requires:\n- all section epics complete\n- dependency graph remains acyclic and actionable\n- benchmark/security/replay claims supported by reproducible artifacts\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:38.990452762Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:55.563075432Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["full-program","master","plan"],"dependencies":[{"issue_id":"bd-3t2d","depends_on_id":"bd-1jak","type":"parent-child","created_at":"2026-02-20T07:52:44.587604125Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3t2d","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:52:45.780735936Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3t2d","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:52:46.478453901Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3t2d","depends_on_id":"bd-2rbm","type":"parent-child","created_at":"2026-02-20T07:52:49.231930242Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3t2d","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:52:51.427341443Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3t2d","depends_on_id":"bd-c1co","type":"parent-child","created_at":"2026-02-20T07:52:55.278397282Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3t2d","depends_on_id":"bd-esst","type":"parent-child","created_at":"2026-02-20T07:52:55.563026040Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3tjn","title":"[11] Define rollout wedge with progressive exposure guardrails","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: rollout wedge\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:16.937810451Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.772143815Z","closed_at":"2026-02-20T07:38:22.997619181Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-3tjn","depends_on_id":"bd-11ni","type":"blocks","created_at":"2026-02-20T07:38:26.389490704Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3tt2","title":"[13] synthesized capability envelopes achieve <= 1.10 over-privilege ratio versus empirically required capability sets on benchmark cohorts","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: synthesized capability envelopes achieve <= 1.10 over-privilege ratio versus empirically required capability sets on benchmark cohorts\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:25.001151288Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.814349938Z","closed_at":"2026-02-20T07:39:58.185460504Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-3u0","title":"[10.7] Add IFC conformance corpus: dual-capability benign workloads, exfil-attempt workloads, and declassification-exception workloads with deterministic expected outcomes.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add IFC conformance corpus: dual-capability benign workloads, exfil-attempt workloads, and declassification-exception workloads with deterministic expected outcomes.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:27.009147518Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.853939787Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"]}
{"id":"bd-3u5","title":"[10.1] Add semantic donor spec document (observable behavior, edge cases, compatibility-critical semantics) as implementation source of truth.","description":"Plan Reference: section 10.1 (Charter + Governance).\nObjective: Add semantic donor spec document (observable behavior, edge cases, compatibility-critical semantics) as implementation source of truth.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.024917569Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.933541263Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-1"]}
{"id":"bd-3u7","title":"[10.10] Implement delegated capability attenuation chain verification (no ambient authority path).","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement delegated capability attenuation chain verification (no ambient authority path).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.397976479Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:38.973571302Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-3ub","title":"[10.3] Implement initial GC with deterministic test mode.","description":"## Plan Reference\nSection 10.3, item 2. Cross-refs: 9B.4 (modern allocator strategy), 9D.4 (allocation profiling), Phase A exit gate.\n\n## What\nImplement the initial garbage collector with a deterministic test mode. The GC must support per-extension collection, domain-aware scanning, and fully deterministic behavior when running under test/replay conditions.\n\n## Detailed Requirements\n- GC must be domain-aware: collect per-extension independently, never scan across extension boundaries\n- Deterministic test mode: GC collection points, ordering, and outcomes are fully reproducible for replay\n- Support explicit GC triggers for testing (force collection at specific points)\n- GC must respect allocation domain budgets: trigger collection before OOM, report pressure\n- Safe mode: GC must never crash or corrupt on malformed object graphs (extensions are untrusted)\n- Incremental/generational design preferred but not required for initial implementation\n- GC pause metrics must be recorded for pause-time instrumentation (bd-50o)\n\n## Rationale\nDeterministic GC is critical for replay (9A.3/9F.3): if GC timing differs between record and replay, execution diverges. Per-extension collection is required for resource budget enforcement (9A.8) and security isolation. The plan requires that extensions cannot cause denial-of-service through memory exhaustion affecting other extensions.\n\n## Testing Requirements\n- Unit tests: allocate objects, trigger GC, verify dead objects collected\n- Unit tests: verify per-extension collection isolation (collecting ext A does not affect ext B)\n- Unit tests: deterministic mode produces identical collection sequence across runs\n- Unit tests: GC handles malformed/circular references safely (no crash, no infinite loop)\n- Stress tests: high allocation rate with concurrent extensions, verify no corruption\n- Regression tests: GC pause times stay within budget thresholds\n\n## Implementation Notes\n- Implement in crates/franken-engine memory module\n- Must work with #![forbid(unsafe_code)] - use safe abstractions for object graph traversal\n- Consider mark-sweep as initial strategy with upgrade path to generational\n- Deterministic mode: fix collection ordering, disable concurrent/parallel collection\n- Record GC events for evidence ledger integration\n\n## Dependencies\n- Blocked by: allocation domains (bd-3w2)\n- Blocks: pause-time instrumentation (bd-50o), interpreter correctness under GC pressure\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:23.238420251Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.012947214Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-3"]}
{"id":"bd-3uiy","title":"[13] moonshot portfolio governor enforces documented promote/hold/kill gates with 100% governance decision artifact completeness","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: moonshot portfolio governor enforces documented promote/hold/kill gates with 100% governance decision artifact completeness\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:24.310746694Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.052990047Z","closed_at":"2026-02-20T07:39:58.483056530Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-3uk","title":"[10.0] Top-10 #2: Probabilistic Guardplane runtime subsystem (strategy: `9A.2`; deep semantics: `9F.15`; execution owners: `10.5`, `10.11`, `10.12`).","description":"## Plan Reference\nSection 10.0 item 2. Strategy: 9A.2. Deep semantics: 9F.15 (Live Safety Twin). Enhancement maps: 9B.2 (conformal prediction, e-process, BOCPD), 9C.2 (full Bayesian decision loop), 9D.2 (per-stage latency budgets).\n\n## What\nStrategic tracking bead for Initiative #2: Probabilistic Guardplane (Bayesian + sequential inference) as first-class runtime subsystem. Security decisions are online inference, not static denylist checks.\n\n## Execution Owners\n- **10.5** (Extension Host): Bayesian posterior updater API, expected-loss action selector, containment actions\n- **10.11** (Runtime Systems): PolicyController, e-process guardrails, BOCPD regime detector, VOI-budgeted monitors\n- **10.12** (Frontier Programs): trust-economics model, fleet immune system, operator safety copilot\n\n## Strategic Rationale (from 9A.2)\n'Supply-chain attacks adapt over time; a posterior-driven system with anytime-valid boundaries can detect drift and react earlier with quantifiable error control.'\n\n## Key Deliverables\n- Posterior risk maintenance over extension behavior using hostcall patterns, temporal anomalies, policy mismatch\n- Continuous decision updates as evidence accumulates\n- Full decision loop: classify → quantify → decide → explain → calibrate (9C.2)\n- Conformal coverage wrappers and PAC-Bayes confidence accounting\n- Phase B exit gate: median detection-to-containment <= 250ms","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:19.363943722Z","created_by":"ubuntu","updated_at":"2026-02-20T07:53:18.407773974Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"]}
{"id":"bd-3vg","title":"[10.11] Add explicit checkpoint-placement contract for long-running loops (dispatch, scanning, policy iteration, replay, decode/verify paths).","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add explicit checkpoint-placement contract for long-running loops (dispatch, scanning, policy iteration, replay, decode/verify paths).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:33.592338932Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.140103785Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-3vh","title":"[10.10] FCP-Inspired Hardening + Interop Track - Comprehensive Execution Epic","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-02-20T07:32:18.818455160Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:56.139589695Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-10"],"dependencies":[{"issue_id":"bd-3vh","depends_on_id":"bd-10a","type":"parent-child","created_at":"2026-02-20T07:52:42.299109399Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-16n","type":"parent-child","created_at":"2026-02-20T07:52:42.984791696Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-16u","type":"parent-child","created_at":"2026-02-20T07:52:43.026310920Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-1ai","type":"parent-child","created_at":"2026-02-20T07:52:43.388268149Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-1b2","type":"parent-child","created_at":"2026-02-20T07:52:43.430510149Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-1bi","type":"parent-child","created_at":"2026-02-20T07:52:43.471706230Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-1c7","type":"parent-child","created_at":"2026-02-20T07:52:43.636209333Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-1dp","type":"parent-child","created_at":"2026-02-20T07:52:43.800050793Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-1fx","type":"parent-child","created_at":"2026-02-20T07:52:44.124512654Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-1lp","type":"parent-child","created_at":"2026-02-20T07:52:44.940915742Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-1p4","type":"parent-child","created_at":"2026-02-20T07:52:45.376827819Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-26f","type":"parent-child","created_at":"2026-02-20T07:52:46.798749713Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-26o","type":"parent-child","created_at":"2026-02-20T07:52:46.879083792Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-28m","type":"parent-child","created_at":"2026-02-20T07:52:47.174377365Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-29r","type":"parent-child","created_at":"2026-02-20T07:52:47.260375384Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-29s","type":"parent-child","created_at":"2026-02-20T07:52:47.302980851Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-2ic","type":"parent-child","created_at":"2026-02-20T07:52:48.175916847Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-2s7","type":"parent-child","created_at":"2026-02-20T07:52:49.428498950Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-2t3","type":"parent-child","created_at":"2026-02-20T07:52:49.507462186Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-2u0","type":"parent-child","created_at":"2026-02-20T07:52:49.784488213Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-2xe","type":"parent-child","created_at":"2026-02-20T07:52:50.262400240Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-2y7","type":"parent-child","created_at":"2026-02-20T07:52:50.419505002Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-3ai","type":"parent-child","created_at":"2026-02-20T07:52:51.585966969Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-3bc","type":"parent-child","created_at":"2026-02-20T07:52:51.704959974Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-3fr","type":"parent-child","created_at":"2026-02-20T07:52:52.150832685Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-3kd","type":"parent-child","created_at":"2026-02-20T07:52:52.677976720Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-3mu","type":"parent-child","created_at":"2026-02-20T07:52:52.876575550Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-3n0","type":"parent-child","created_at":"2026-02-20T07:52:52.956277402Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-3pl","type":"parent-child","created_at":"2026-02-20T07:52:53.261687507Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-3s6","type":"parent-child","created_at":"2026-02-20T07:52:53.703482603Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-3u5","type":"parent-child","created_at":"2026-02-20T07:52:53.981014933Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-3u7","type":"parent-child","created_at":"2026-02-20T07:52:54.020546885Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-74l","type":"parent-child","created_at":"2026-02-20T07:52:54.877026640Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-8az","type":"parent-child","created_at":"2026-02-20T07:52:55.034717875Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-j7z","type":"parent-child","created_at":"2026-02-20T07:52:55.940237753Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vh","depends_on_id":"bd-lpl","type":"parent-child","created_at":"2026-02-20T07:52:56.139504676Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3vk","title":"[10.3] Memory + GC - Comprehensive Execution Epic","description":"## Plan Reference\nSection 10.3: Memory + GC\n\n## Overview\nThis epic covers FrankenEngine's memory management subsystem including allocation domain design, garbage collection with deterministic test mode, and GC pause-time instrumentation with regression budgets.\n\n## Child Beads\n- bd-3w2: Define allocation domains and lifetime classes (foundational)\n- bd-3ub: Implement initial GC with deterministic test mode\n- bd-50o: Add pause-time instrumentation and regression budgets\n\n## Dependency Chain\nbd-3w2 (allocation domains) → bd-3ub (GC implementation) → bd-50o (pause instrumentation)\n\n## Key Requirements\n- Per-extension memory isolation for security\n- Deterministic GC for replay support (9A.3/9F.3)\n- Pause-time budgets for tail-latency control (Phase C)\n- Safe under #![forbid(unsafe_code)] constraint","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.367735864Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:54.501067511Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-3"],"dependencies":[{"issue_id":"bd-3vk","depends_on_id":"bd-3ub","type":"parent-child","created_at":"2026-02-20T07:52:54.059912948Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vk","depends_on_id":"bd-3w2","type":"parent-child","created_at":"2026-02-20T07:52:54.382280969Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vk","depends_on_id":"bd-50o","type":"parent-child","created_at":"2026-02-20T07:52:54.500996609Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vk","depends_on_id":"bd-ntq","type":"blocks","created_at":"2026-02-20T07:32:55.435834240Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3vlb","title":"[10.13] Define a formal control-plane adoption ADR naming `/dp/asupersync` crates as canonical sources for `Cx`, decision contracts, and evidence schema.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Define a formal control-plane adoption ADR naming `/dp/asupersync` crates as canonical sources for `Cx`, decision contracts, and evidence schema.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:41.647466885Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.278938557Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-3vp","title":"[10.4] Add explicit compatibility mode matrix for Node/Bun module edge cases (no hidden shims).","description":"## Plan Reference\nSection 10.4, item 3. Cross-refs: Phase D (Node/Bun surface superset), 9F.6 (Tri-Runtime Lockstep Oracle), 10.7 (differential lockstep suite).\n\n## What\nAdd an explicit compatibility mode matrix documenting how FrankenEngine handles Node and Bun module edge cases. No hidden shims - every compatibility behavior must be documented and testable.\n\n## Detailed Requirements\n- Compatibility matrix: for each module feature (ESM, CJS, dual-mode, conditional exports, package.json fields), document FrankenEngine behavior vs Node vs Bun\n- Explicit divergence documentation: where FrankenEngine intentionally differs from Node/Bun, document why and what the impact is\n- No hidden shims: compatibility layers must be explicit, testable, and removable (not buried in resolution logic)\n- Waiver governance: when FrankenEngine cannot match Node/Bun behavior, a formal waiver must be filed (per 10.1 feature-parity tracker)\n- Migration guidance: for each divergence, provide clear migration path for users moving from Node/Bun\n\n## Rationale\nThe plan explicitly states 'no hidden shims' for compatibility. Phase D requires Node/Bun surface superset, but the plan also requires that FrankenEngine be a de novo implementation (Section 2). This matrix is the governance mechanism that keeps compatibility explicit and intentional rather than accidental. The tri-runtime lockstep oracle (9F.6) will continuously validate this matrix.\n\n## Testing Requirements\n- Compatibility tests: for each matrix entry, test that FrankenEngine behavior matches documented behavior\n- Divergence tests: for each documented divergence, test that FrankenEngine produces the expected (different) behavior\n- Lockstep tests: feed matrix test cases to tri-runtime lockstep oracle for automated divergence detection\n- Regression tests: new code changes do not silently alter compatibility matrix entries\n\n## Implementation Notes\n- Compatibility matrix should be machine-readable (TOML/JSON) for automated testing\n- Each matrix entry should link to relevant test262 or lockstep test cases\n- Consider compatibility mode flags for opt-in Node/Bun-compatible behavior where divergence exists\n- This is primarily a documentation/governance artifact with test backing\n\n## Dependencies\n- Blocked by: module resolver (bd-tgv), module cache (bd-16x)\n- Blocks: Phase D exit gate, migration kits (Section 15 ecosystem capture)","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:23.766540351Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.318761231Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-4"]}
{"id":"bd-3w2","title":"[10.3] Define allocation domains and lifetime classes.","description":"## Plan Reference\nSection 10.3, item 1. Cross-refs: 9B.4 (allocator strategy), 9D.4 (allocation profiling), 9B.1 (arena allocation for IR nodes).\n\n## What\nDefine the allocation domain taxonomy and lifetime class hierarchy for FrankenEngine's memory management. This is the foundational design for how memory is organized, tracked, and reclaimed across the runtime.\n\n## Detailed Requirements\n- Define allocation domains: per-extension heaps, shared runtime heap, IR arena, evidence/witness arena, temporary/scratch buffers\n- Define lifetime classes: request-scoped (single hostcall), session-scoped (extension session), global (runtime lifetime), arena (compilation unit)\n- Each domain must have explicit size limits for per-extension resource budget enforcement (9A.8)\n- Allocation tracking must be deterministic for replay: same allocation sequence under same inputs\n- Domain isolation: one extension's allocation cannot corrupt another's (security requirement)\n- Integration point with GC: lifetime classes inform GC root scanning and collection strategy\n\n## Rationale\nPer-extension resource budgets (9A.8) require fine-grained allocation control. The plan requires deterministic behavior for replay (9A.3), which means memory allocation patterns must be reproducible. Domain isolation is a security requirement - extensions are untrusted code that must not be able to corrupt runtime or other extension memory. Arena allocation (recommended in 9B.1) provides both performance and determinism benefits.\n\n## Testing Requirements\n- Unit tests: allocate from each domain, verify isolation (writes in one domain cannot read from another)\n- Unit tests: verify lifetime class scoping (request-scoped allocation freed after hostcall completes)\n- Unit tests: verify domain size limits are enforced (allocation fails when budget exceeded)\n- Property tests: allocation/deallocation sequences are deterministic given same inputs\n- Stress tests: high allocation rates across multiple domains do not corrupt or leak\n\n## Implementation Notes\n- Define domain/lifetime types in crates/franken-engine as core memory module\n- Consider typed arenas (one per IR level) for compilation pipeline\n- Must work with #![forbid(unsafe_code)] constraint from AGENTS.md - use safe abstractions\n- Arena designs should be compatible with the existing serde-based serialization approach\n\n## Dependencies\n- Blocks: GC implementation (bd-3ub), interpreter skeleton (bd-2f8 in 10.2)\n- Blocked by: nothing (foundational design)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:23.104967561Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.357978647Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-3"]}
{"id":"bd-3zj","title":"[10.0] Top-10 #9: Adversarial security corpus + continuous fuzzing harness (strategy: `9A.9`; deep semantics: `9F.7`; execution owners: `10.7`, `10.12`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #9: Adversarial security corpus + continuous fuzzing harness (strategy: `9A.9`; deep semantics: `9F.7`; execution owners: `10.7`, `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:20.276166263Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.398401719Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"]}
{"id":"bd-4hf","title":"[10.11] Implement three-tier hash strategy contract (hot integrity, content identity, trust authenticity) with explicit scope boundaries.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement three-tier hash strategy contract (hot integrity, content identity, trust authenticity) with explicit scope boundaries.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:37.149605579Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.438426419Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-50o","title":"[10.3] Add pause-time instrumentation and regression budgets.","description":"## Plan Reference\nSection 10.3, item 3. Cross-refs: 9D.4 (allocation profiling), 9D (extreme-software-optimization discipline), Phase C exit gate (p95/p99 improvements).\n\n## What\nAdd GC pause-time instrumentation with regression budgets. Every GC pause must be measured, recorded, and gated against defined latency budgets to prevent GC from becoming a tail-latency source.\n\n## Detailed Requirements\n- Instrument every GC pause with: start time, duration, objects scanned, objects collected, memory reclaimed, domain/extension\n- Define pause-time budgets: p50, p95, p99 targets per GC event class\n- CI regression gate: fail build if GC pauses exceed budget on benchmark workloads\n- Structured telemetry output compatible with evidence ledger schema (10.11)\n- Dashboard/export format for operator visibility into GC pressure\n- Per-extension GC overhead tracking for resource budget accounting\n\n## Rationale\nPer 9D (extreme-software-optimization): baseline first (p50/p95/p99), profile top-5 hotspots before changes. GC pauses are a known tail-latency source in managed runtimes. Without explicit instrumentation and budgets, GC pauses silently degrade p99 performance. The plan requires measured p95/p99 improvements (Phase C exit gate) which requires GC pause visibility.\n\n## Testing Requirements\n- Unit tests: GC pause events are recorded with correct timing data\n- Unit tests: budget violation detection triggers CI failure\n- Benchmark tests: GC pause times on standard workloads stay within defined budgets\n- Regression tests: GC pause times do not degrade after code changes\n- Integration: pause data feeds into evidence ledger format\n\n## Implementation Notes\n- Use std::time::Instant for high-resolution timing\n- Output structured JSON for integration with frankentui dashboards (per 10.14)\n- Budget thresholds should be configurable per environment (lab vs production)\n- Consider ring-buffer storage for recent GC events to limit memory overhead\n\n## Dependencies\n- Blocked by: GC implementation (bd-3ub)\n- Blocks: Performance program benchmarks (10.6), operational readiness diagnostics (10.8)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:23.372225999Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.478365399Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-3"]}
{"id":"bd-51gj","title":"[12] Mitigate scope explosion via strict phase gates and one-lever optimization discipline","description":"Plan Reference: section 12 (Risk Register).\nObjective: Scope explosion:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:17.552939631Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.518581976Z","closed_at":"2026-02-20T07:39:05.031472511Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"]}
{"id":"bd-52ko","title":"[16] External red-team and academic-style evaluations with published methodology.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: External red-team and academic-style evaluations with published methodology.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:36.653405607Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.558745634Z","closed_at":"2026-02-20T07:46:47.843750720Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"]}
{"id":"bd-5pk","title":"[10.5] Implement hostcall telemetry schema and recorder.","description":"## Plan Reference\nSection 10.5, item 3 (Implement hostcall telemetry schema and recorder). Cross-refs: 9A.2 (Probabilistic Guardplane needs hostcall patterns as evidence), 9E.9 (normative observability surface), 9C.2 (Bayesian decision loop requires structured evidence input).\n\n## What\nImplement a structured telemetry system that records every hostcall made by extensions with sufficient detail for the Probabilistic Guardplane (9A.2) to use as evidence in its Bayesian inference loop. The telemetry schema defines what fields are captured per hostcall. The recorder is the runtime component that captures, timestamps, and persists these records with deterministic ordering guarantees. This is the primary evidence pipeline feeding the security decision system.\n\n## Detailed Requirements\n- Define `HostcallTelemetryRecord` struct with fields: `record_id: u64` (monotonic), `timestamp_ns: u64` (monotonic nanoseconds), `extension_id: ExtensionId`, `hostcall_type: HostcallType`, `capability_used: Capability`, `arguments_hash: [u8; 32]` (hash of call arguments for privacy), `result_status: HostcallResult`, `duration_ns: u64`, `resource_delta: ResourceDelta`, `flow_label: FlowLabel` (IFC label at call time), `decision_id: Option<DecisionId>` (if a security decision was triggered).\n- Define `HostcallType` enum covering all hostcall categories: `FsRead`, `FsWrite`, `NetworkSend`, `NetworkRecv`, `ProcessSpawn`, `EnvRead`, `MemAlloc`, `TimerCreate`, `CryptoOp`, `IpcSend`, `IpcRecv`.\n- Define `HostcallResult` enum: `Success`, `Denied { reason: DenialReason }`, `Error { code: u32 }`, `Timeout`.\n- Implement `TelemetryRecorder` that: (a) accepts records via a lock-free channel (bounded, backpressure on full), (b) assigns monotonic `record_id` and `timestamp_ns`, (c) writes to an append-only log with deterministic binary encoding, (d) supports snapshot/checkpoint for replay alignment.\n- The recorder must guarantee causal ordering: if hostcall A completes before hostcall B starts (within the same extension), A's record_id < B's record_id.\n- Implement `TelemetryQuery` API for the Guardplane to query recent hostcall patterns: `recent_by_extension(ext_id, window)`, `recent_by_type(hostcall_type, window)`, `anomaly_candidates(threshold)`.\n- All telemetry must be available for forensic replay (bd-t2m) with bit-exact reproduction.\n- Telemetry overhead budget: < 2 microseconds per hostcall record in the hot path.\n\n## Rationale\nThe Probabilistic Guardplane (9A.2) cannot make security decisions without evidence. Hostcall patterns are the primary behavioral signal for detecting anomalous extension behavior. The structured schema ensures that Bayesian inference has well-typed inputs. The normative observability surface (9E.9) requires that all runtime-significant events are captured in a structured, queryable format. Deterministic ordering is essential for forensic replay fidelity.\n\n## Testing Requirements\n- **Unit tests**: Record creation with all field combinations. Monotonic ordering invariant (record_id and timestamp always increase). Serialization round-trip for every field type. Query API returns correct results for time-windowed queries.\n- **Performance tests**: Benchmark recording overhead per hostcall (must be < 2us). Benchmark under contention (multiple extensions recording concurrently).\n- **Integration tests**: Record a sequence of hostcalls from a mock extension, query the telemetry, and verify the Guardplane can consume the records as evidence. Verify checkpoint/snapshot produces a consistent view.\n- **Determinism tests**: Record the same hostcall sequence twice with deterministic timestamps; verify bit-identical output.\n- **Backpressure tests**: Fill the telemetry channel and verify graceful handling (no data loss, appropriate backpressure signal to caller).\n\n## Implementation Notes\n- Use a lock-free MPSC channel (e.g., `crossbeam-channel` bounded) for the recording hot path.\n- The append-only log can use a memory-mapped file or a simple `BufWriter` with periodic fsync; choose based on durability requirements.\n- `arguments_hash` uses BLAKE3 for speed; never log raw arguments (privacy + size).\n- The `FlowLabel` field connects to the IFC system (bd-1hw, 10.2); initially can be a placeholder type.\n- Consider a ring-buffer for the query API's recent-window access pattern.\n\n## Dependencies\n- **Blocked by**: bd-xq7 (needs `ExtensionId` and `Capability` types from manifest validation).\n- **Blocks**: bd-3md (Bayesian updater consumes telemetry as evidence), bd-1y5 (action selector needs telemetry context), bd-t2m (forensic replay reads telemetry logs).\n- **Parent**: bd-1yq (10.5 epic).","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.153140274Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.599079169Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"]}
{"id":"bd-62mo","title":"[14] Any failed-equivalence case invalidates claim publication until fixed or explicitly excluded via versioned benchmark-spec revision.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Any failed-equivalence case invalidates claim publication until fixed or explicitly excluded via versioned benchmark-spec revision.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:31.158639217Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.639338516Z","closed_at":"2026-02-20T07:41:20.501707210Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-6pk","title":"[10.9] Define and enforce disruption scorecard (`performance_delta`, `security_delta`, `autonomy_delta`) as release blockers.","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Define and enforce disruption scorecard (`performance_delta`, `security_delta`, `autonomy_delta`) as release blockers.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:27.852223090Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.679395476Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"]}
{"id":"bd-6qsi","title":"[10.15] Define specialization receipt schema (`proof_specialization_receipt`) linking security-proof inputs to activated optimization classes and rollback lineage.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define specialization receipt schema (`proof_specialization_receipt`) linking security-proof inputs to activated optimization classes and rollback lineage.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:52.844002772Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.718770706Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-70bx","title":"[14] Publish benchmark specification, harness code, datasets, and scoring formulas.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Publish benchmark specification, harness code, datasets, and scoring formulas.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:27.571404471Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.758672607Z","closed_at":"2026-02-20T07:41:22.023074751Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-74l","title":"Formalize evidence-bound claim language policy","description":"Implements PLAN section 10.1 second TODO. Extend runtime governance with explicit claim-language rules that gate performance/security/compatibility claims on reproducible artifacts, denominator disclosure, and bounded wording requirements.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:25:04.896000733Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.841491635Z","closed_at":"2026-02-20T07:26:12.419622162Z","close_reason":"Extended docs/RUNTIME_CHARTER.md with binding claim-language policy and updated README charter summary","source_repo":".","compaction_level":0,"original_size":0,"labels":["evidence","governance","plan","section-10-1"]}
{"id":"bd-7rwi","title":"[10.15] Define verified self-replacement schema (`slot_registry`, `delegate_cell_manifest`, `replacement_receipt`, `promotion_decision`) with deterministic encoding and signature requirements.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define verified self-replacement schema (`slot_registry`, `delegate_cell_manifest`, `replacement_receipt`, `promotion_decision`) with deterministic encoding and signature requirements.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:53.891031464Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.881079992Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-83jh","title":"[10.15] Add synthesis search-budget contract (time/compute/depth caps) with fail-closed conservative fallback behavior on budget exhaustion.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add synthesis search-budget contract (time/compute/depth caps) with fail-closed conservative fallback behavior on budget exhaustion.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:50.303431746Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.920566059Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-89l2","title":"[10.14] Create a `franken_engine` storage adapter layer that binds runtime persistence contracts to `frankensqlite` APIs.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Create a `franken_engine` storage adapter layer that binds runtime persistence contracts to `frankensqlite` APIs.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:45.545669748Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:39.960554501Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-8az","title":"[10.10] Implement deterministic nonce derivation for any AEAD-protected data-plane envelope.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement deterministic nonce derivation for any AEAD-protected data-plane envelope.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.240856597Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.000041018Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-8guj","title":"[13] service/API control surfaces relevant to runtime operations leverage `/dp/fastapi_rust` patterns/components where they provide equal or better capability","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: service/API control surfaces relevant to runtime operations leverage `/dp/fastapi_rust` patterns/components where they provide equal or better capability\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:22.385059452Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.039773824Z","closed_at":"2026-02-20T07:39:59.385562019Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-a5xc","title":"[14] Require at least two independent third-party reruns before category-level claims are treated as externally validated.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Require at least two independent third-party reruns before category-level claims are treated as externally validated.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:32.364545016Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.079251595Z","closed_at":"2026-02-20T07:41:19.994875004Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-ag4","title":"[10.8] Add release checklist requiring security and performance artifact bundles.","description":"## Plan Reference\nSection 10.8, item 3. Cross-refs: Section 11 (evidence and decision contracts), Section 14.3 (reproducibility + neutral verification), Phase E exit gate.\n\n## What\nAdd a release checklist requiring security and performance artifact bundles before any release is shipped. This is the enforcement mechanism for the evidence-backed discipline.\n\n## Detailed Requirements\n- Release checklist: machine-readable checklist that CI/release pipeline enforces\n- Required security artifacts: conformance suite pass, adversarial corpus results, containment latency data, IFC coverage, PLAS witness coverage\n- Required performance artifacts: benchmark suite results with >= 3x gate, flamegraph comparisons, GC pause budgets\n- Required reproducibility artifacts: env.json, manifest.json, repro.lock (per 10.1 reproducibility contract)\n- Required operational artifacts: safe-mode test pass, diagnostics CLI functional test, evidence export test\n- Blocking gate: release pipeline cannot proceed without all required artifacts\n- Artifact storage: all release artifacts stored with release tag for later verification\n\n## Rationale\nSection 11 mandates: 'No contract, no merge.' The release checklist is the program-level equivalent: no evidence bundle, no release. The plan requires that every claim ships with proof artifacts. This checklist operationalizes that principle at the release boundary, ensuring nothing ships without the backing evidence.\n\n## Testing Requirements\n- CI test: release pipeline blocks when any required artifact is missing\n- CI test: release pipeline succeeds when all artifacts are present and valid\n- Test: artifact bundle is complete and self-contained (can be independently verified)\n- Test: reproducibility artifacts enable independent re-run of benchmarks\n\n## Dependencies\n- Blocked by: benchmark suite (10.6), conformance suite (10.7), diagnostics CLI (bd-2mm), safe-mode (bd-2qx)\n- Blocks: Phase E exit gate (evidence-backed operational readiness report)","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:27.547431330Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.118962330Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-8"]}
{"id":"bd-ami3","title":"[10.15] Add frankensqlite-backed witness/index stores and conformance tests for deterministic witness retrieval and replay joins.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankensqlite-backed witness/index stores and conformance tests for deterministic witness retrieval and replay joins.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:51.303479086Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.157953495Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-anuw","title":"[14] Provide one-command neutral verifier mode that replays official runs and validates scoring + equivalence checks independently.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Provide one-command neutral verifier mode that replays official runs and validates scoring + equivalence checks independently.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:32.125965809Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.197572750Z","closed_at":"2026-02-20T07:41:20.099462276Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-c1co","title":"[11] Evidence And Decision Contracts (Mandatory) - Comprehensive Execution Epic","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nPurpose: Operationalize this section's governance/validation/adoption requirements into enforceable engineering work.\nQuality requirements for all children:\n- explicit acceptance criteria and failure semantics\n- unit-test and e2e/integration verification expectations\n- detailed structured logging and reproducibility artifacts where applicable\n- traceability back to category-level goals (security, performance, explainability, adoption)\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:15.233637630Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:56.910169784Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-11"],"dependencies":[{"issue_id":"bd-c1co","depends_on_id":"bd-11ni","type":"parent-child","created_at":"2026-02-20T07:52:42.378952364Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-c1co","depends_on_id":"bd-18fu","type":"parent-child","created_at":"2026-02-20T07:52:43.226196536Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-c1co","depends_on_id":"bd-1tsf","type":"blocks","created_at":"2026-02-20T07:34:37.717812047Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-c1co","depends_on_id":"bd-2h70","type":"parent-child","created_at":"2026-02-20T07:52:48.136269269Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-c1co","depends_on_id":"bd-2ntw","type":"parent-child","created_at":"2026-02-20T07:52:48.752901876Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-c1co","depends_on_id":"bd-3qm1","type":"parent-child","created_at":"2026-02-20T07:52:53.463205053Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-c1co","depends_on_id":"bd-3tjn","type":"parent-child","created_at":"2026-02-20T07:52:53.822655043Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-c1co","depends_on_id":"bd-ulle","type":"parent-child","created_at":"2026-02-20T07:52:56.790381276Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-c1co","depends_on_id":"bd-von8","type":"parent-child","created_at":"2026-02-20T07:52:56.910120692Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-crp","title":"[10.2] Define parser trait + canonical AST invariants for ES2020 script/module goals.","description":"## Plan Reference\nSection 10.2, item 1. Cross-refs: 9A.1, 9B.1, 9F.4, Phase A exit gate.\n\n## What\nDefine the parser trait interface and canonical AST type hierarchy for ES2020 script and module goal symbols. This is the foundation of the entire compilation pipeline - IR0 (SyntaxIR) is produced by this layer.\n\n## Detailed Requirements\n- Parser trait must be generic over input source (string, stream, file) with deterministic error reporting\n- AST nodes must be canonical: structurally identical source produces identical AST (no parse-order-dependent metadata)\n- Must support both Script and Module goal symbols per ES2020 spec\n- AST must carry source location spans for error reporting and debugging\n- AST serialization must be deterministic for replay/hash purposes (canonical serialization invariant from plan)\n- Must NOT mirror V8 or QuickJS internal AST structures - this is a de novo design informed by observable ES2020 semantics (per Section 10.1 donor-extraction policy)\n\n## Rationale\nThe plan's multi-level IR stack (IR0→IR4) starts here. Without a well-defined parser trait and canonical AST, nothing downstream can be deterministic. The 9F.4 Capability-Typed TS Execution Contract requires that capability intent be traceable from source through all IR levels. This means the AST must be designed to support downstream capability annotation, not retrofitted later.\n\n## Testing Requirements\n- Unit tests: parse valid ES2020 script/module sources, verify AST structure matches expected canonical form\n- Unit tests: parse invalid sources, verify deterministic error with source location\n- Unit tests: verify canonical serialization (same source → same serialized AST bytes)\n- Property tests: round-trip parse → serialize → parse produces identical AST\n- Conformance: test262 parse-only subset as baseline validation\n- Edge cases: empty source, unicode identifiers, nested template literals, destructuring patterns\n\n## Implementation Notes\n- Define in crates/franken-engine as core parser trait\n- Consider arena allocation for AST nodes (9B.1 recommends arena allocation for IR nodes)\n- AST node types should be exhaustive enum, not trait objects, for determinism and performance\n- Hash invariant: define canonical hash over AST for use in IR0 witness artifacts\n\n## Dependencies\n- Blocks: IR contract (bd-1wa), lowering pipelines (bd-ug9), interpreter skeleton (bd-2f8)\n- Blocked by: nothing (foundational)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.404986697Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.277092963Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"]}
{"id":"bd-d6h","title":"[10.12] Add counterexample synthesizer for conflicting policy controllers and ambiguous merges.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Add counterexample synthesizer for conflicting policy controllers and ambiguous merges.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.936839901Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.316873248Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-d93","title":"[10.7] Integrate transplanted extension conformance assets into runnable suites.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Integrate transplanted extension conformance assets into runnable suites.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.052376658Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.356679451Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"]}
{"id":"bd-dkh","title":"[10.9] Release gate: proof-specialized lanes demonstrate positive performance delta versus ambient-authority lanes with 100% specialization-receipt coverage and deterministic fallback correctness (implementation ownership: `10.12` + `10.15` + `10.6` + `10.7`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: proof-specialized lanes demonstrate positive performance delta versus ambient-authority lanes with 100% specialization-receipt coverage and deterministic fallback correctness (implementation ownership: `10.12` + `10.15` + `10.6` + `10.7`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.858616381Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.417603628Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"]}
{"id":"bd-du2","title":"[10.12] Define fleet immune-system message protocol for signed evidence, local confidence, and containment intent propagation.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Define fleet immune-system message protocol for signed evidence, local confidence, and containment intent propagation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:38.863421634Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.460160033Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-eke","title":"[10.9] Release gate: deterministic IFC protections block unauthorized sensitive-source exfiltration across the published exfil corpus, with receipt-backed declassification audit for approved exceptions (implementation ownership: `10.15` + `10.5` + `10.7`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: deterministic IFC protections block unauthorized sensitive-source exfiltration across the published exfil corpus, with receipt-backed declassification audit for approved exceptions (implementation ownership: `10.15` + `10.5` + `10.7`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.716828695Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.499265471Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"]}
{"id":"bd-esst","title":"[16] Scientific Contribution Targets - Comprehensive Execution Epic","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nPurpose: Operationalize this section's governance/validation/adoption requirements into enforceable engineering work.\nQuality requirements for all children:\n- explicit acceptance criteria and failure semantics\n- unit-test and e2e/integration verification expectations\n- detailed structured logging and reproducibility artifacts where applicable\n- traceability back to category-level goals (security, performance, explainability, adoption)\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"closed","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:15.754049481Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:54.581456984Z","closed_at":"2026-02-20T07:46:28.422584014Z","close_reason":"Replaced by consolidated scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-16"],"dependencies":[{"issue_id":"bd-esst","depends_on_id":"bd-16up","type":"parent-child","created_at":"2026-02-20T07:52:43.066907304Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-esst","depends_on_id":"bd-1jak","type":"blocks","created_at":"2026-02-20T07:34:38.887370442Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-esst","depends_on_id":"bd-1tsf","type":"blocks","created_at":"2026-02-20T07:34:38.203687358Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-esst","depends_on_id":"bd-21ds","type":"blocks","created_at":"2026-02-20T07:34:38.790126648Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-esst","depends_on_id":"bd-2cc8","type":"parent-child","created_at":"2026-02-20T07:52:47.501470326Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-esst","depends_on_id":"bd-2pwr","type":"parent-child","created_at":"2026-02-20T07:52:48.911310567Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-esst","depends_on_id":"bd-2zk0","type":"parent-child","created_at":"2026-02-20T07:52:50.578236785Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-esst","depends_on_id":"bd-37cc","type":"parent-child","created_at":"2026-02-20T07:52:51.260019140Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-esst","depends_on_id":"bd-3c8n","type":"parent-child","created_at":"2026-02-20T07:52:51.784681513Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-esst","depends_on_id":"bd-3ebk","type":"parent-child","created_at":"2026-02-20T07:52:52.024234073Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-esst","depends_on_id":"bd-52ko","type":"parent-child","created_at":"2026-02-20T07:52:54.581387404Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-ewy","title":"[10.12] Define attested execution-cell architecture and trust-root interface contract.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Define attested execution-cell architecture and trust-root interface contract.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.482664196Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.580461576Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-f7n","title":"[10.9] Publish first category-shift report demonstrating beyond-parity capabilities with evidence bundles.","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Publish first category-shift report demonstrating beyond-parity capabilities with evidence bundles.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.996358340Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.623384544Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"]}
{"id":"bd-fp53","title":"[14] Equivalent side-effect trace class (filesystem/network/process/policy actions normalized by contract schema).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Equivalent side-effect trace class (filesystem/network/process/policy actions normalized by contract schema).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:29.692115611Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.663375431Z","closed_at":"2026-02-20T07:41:21.126076460Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-gr1","title":"[10.11] Add BOCPD-based regime detector for workload/health stream shifts feeding policy decisions.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add BOCPD-based regime detector for workload/health stream shifts feeding policy decisions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.371586294Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.703980902Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-hli","title":"[10.11] Gate all remote operations behind explicit runtime capability (no implicit network side effects).","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Gate all remote operations behind explicit runtime capability (no implicit network side effects).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.110278994Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.742874756Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-iqrn","title":"[15] Migration kits that convert existing Node/Bun extension workflows into capability-typed FrankenEngine workflows.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Migration kits that convert existing Node/Bun extension workflows into capability-typed FrankenEngine workflows.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:34.599613006Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.782995134Z","closed_at":"2026-02-20T07:45:53.787429606Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"]}
{"id":"bd-j7z","title":"[10.1] Add feature-parity tracker wired to `test262`, lockstep corpora, and waiver governance.","description":"Plan Reference: section 10.1 (Charter + Governance).\nObjective: Add feature-parity tracker wired to `test262`, lockstep corpora, and waiver governance.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.280072732Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.861780639Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-1"]}
{"id":"bd-jaqy","title":"[10.13] Add fallback validation proving control-plane failure degrades to deterministic safe mode rather than undefined behavior.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add fallback validation proving control-plane failure degrades to deterministic safe mode rather than undefined behavior.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:44.412727627Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.901587493Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-js4","title":"[10.6] Add opportunity matrix scoring to optimization workflow.","description":"## Plan Reference\nSection 10.6, item 4. Cross-refs: 9D (extreme-software-optimization - opportunity score >= 2.0), 9F.14 (Autopilot Performance Scientist - VOI selection).\n\n## What\nAdd opportunity matrix scoring to the optimization workflow. Each potential optimization is scored based on expected gain, risk, and engineering cost before implementation begins.\n\n## Detailed Requirements\n- Opportunity matrix: ranked list of optimization candidates with scores\n- Scoring inputs: hotspot profile data, estimated performance gain, implementation risk, engineering effort\n- Opportunity score threshold: only pursue optimizations with score >= 2.0 (per 9D global rule)\n- VOI-based prioritization: score includes value-of-information component (9F.14) estimating expected performance gain per engineering hour\n- Historical tracking: record which optimizations were pursued, their predicted vs actual impact\n- Integration with flamegraph data (bd-1nn) and benchmark results (bd-2ql)\n\n## Rationale\nPer 9D global rule: 'Implement one lever per commit with opportunity score >= 2.0.' This prevents random optimization and focuses effort where measured impact is highest. The Autopilot Performance Scientist (9F.14) concept formalizes this: 'Optimization effort concentrates where probability of meaningful win is highest, reducing random tuning churn.'\n\n## Testing Requirements\n- Unit tests: scoring function produces correct scores for known inputs\n- Unit tests: threshold filter rejects low-score candidates\n- Unit tests: scoring is deterministic given same inputs\n- Integration test: end-to-end flow from profile data → candidate generation → scoring → ranked output\n\n## Dependencies\n- Blocked by: flamegraph pipeline (bd-1nn), benchmark suite (bd-2ql)\n- Blocks: one-lever policy enforcement (bd-2l6)","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:25.615583411Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.941461833Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-6"]}
{"id":"bd-kfe4","title":"[10.15] Add version-matrix CI lane (N/N-1/N+1 where applicable) for contract compatibility checks across supported repo/version combinations.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add version-matrix CI lane (N/N-1/N+1 where applicable) for contract compatibility checks across supported repo/version combinations.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:49.135710723Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:40.980582649Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-kr99","title":"[10.15] Implement signed replacement-lineage log with transparency-verifiable append semantics and independent verifier CLI integration.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement signed replacement-lineage log with transparency-verifiable append semantics and independent verifier CLI integration.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:54.408624545Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.020498085Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"]}
{"id":"bd-lpl","title":"[10.10] Persist highest accepted checkpoint frontier and reject rollback/regression attempts.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Persist highest accepted checkpoint frontier and reject rollback/regression attempts.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.977331511Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.062439054Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"]}
{"id":"bd-m9pa","title":"[10.13] Integrate obligation-tracking for two-phase safety-critical operations on extension-host paths and fail lab runs on unresolved obligations.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Integrate obligation-tracking for two-phase safety-critical operations on extension-host paths and fail lab runs on unresolved obligations.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:42.795493644Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.104648774Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-mhz4","title":"Implement benchmark harness, scoring calculator, and neutral verifier mode","description":"## Plan Reference\nSection 14.2-14.3: Claim Denominator and Reproducibility\nSection 10.6: Performance Program TODOs\n\n## What\nBuild the executable benchmark infrastructure: harness runner, weighted-geometric-mean scoring calculator, equivalence checker, neutral verifier mode, and artifact storage integration.\n\n## Components\n1. **Benchmark harness runner**: Orchestrates workload execution across FrankenEngine/Node/Bun with deterministic seeding, warm/cold cache control, and artifact capture\n2. **Weighted geometric mean calculator**: Implements the exact scoring formula from Section 14.2\n3. **Behavior-equivalence checker**: Validates output canonical digests, side-effect trace equivalence, and error-class semantics\n4. **Neutral verifier mode**: One-command mode for third parties to replay and validate scoring independently\n5. **Artifact storage**: Integration with frankensqlite for result ledgers and frankentui for operator dashboards\n6. **Publication gate**: Automated check that all prerequisites are met before allowing claim publication\n\n## Implementation Details\n- CLI: frankenctl benchmark run --suite extension-heavy --profile S/M/L\n- CLI: frankenctl benchmark score --baseline node --compare ./results/\n- CLI: frankenctl benchmark verify --manifest ./results/manifest.json\n- Run manifests include: hardware, kernel, runtime versions, flags, dataset checksums, seed transcripts, harness commit IDs\n- Store raw per-run data, not just aggregates\n- Native-coverage progression published alongside benchmark releases\n\n## Testing Requirements\n- Unit tests for scoring formula with known inputs/outputs\n- Unit tests for equivalence checker (matching and non-matching cases)\n- Integration tests for full harness lifecycle (setup, run, score, verify)\n- E2E test with mini workload producing complete artifact set\n- Regression test ensuring scoring formula changes require version bump\n\n## Rationale\nSection 14.3 requires at least two independent third-party reruns. The neutral verifier mode must be robust enough for external use. From Section 7.5: every published claim must include verifier scripts and deterministic repro commands.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:42:12.677337908Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:49.776053393Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["benchmark","performance","tooling"]}
{"id":"bd-mrf8","title":"[15] Signed extension registry with enforceable provenance, attestation, and revocation policies.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Signed extension registry with enforceable provenance, attestation, and revocation policies.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:34.395892910Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.145671903Z","closed_at":"2026-02-20T07:45:56.851175521Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"]}
{"id":"bd-nhp","title":"[10.12] Implement epoch-bound specialization invalidation and deterministic fallback to baseline paths on proof/policy churn.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement epoch-bound specialization invalidation and deterministic fallback to baseline paths on proof/policy churn.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:38.688630984Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.185899831Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-ntq","title":"[10.2] VM Core - Comprehensive Execution Epic","description":"## Plan Reference\nSection 10.2 (VM Core). This is the top-level epic for the entire VM Core execution track.\n\n## Purpose\nThe VM Core epic encompasses the fundamental execution engine of FrankenEngine - from source parsing through multi-level IR compilation to baseline interpretation and full ES2020 semantics. This is the architectural spine on which all other subsystems (memory/GC, module system, security, performance optimization) depend.\n\n## Scope and Ambition\nThe VM Core must deliver:\n1. **De novo execution**: No dependency on external JS engine bindings (V8, QuickJS) for core runtime behavior. Both execution lanes are native Rust implementations.\n2. **Full ES2020 semantics**: No permanent subset scope. Every ES2020 feature must be implemented correctly.\n3. **Proof-carrying compilation**: Every IR lowering stage emits machine-checkable witnesses for evidence graph linkage.\n4. **IFC-annotated IR**: Information Flow Control labels are first-class citizens in IR2, enabling deterministic exfiltration prevention.\n5. **Security-proof-guided specialization**: Security proofs serve as optimizer inputs, creating a flywheel where tighter verification yields faster code.\n6. **Verified self-replacement**: Typed execution slots enable incremental convergence from delegate cells to native cells.\n7. **Deterministic replay**: All execution produces witness artifacts (IR4) enabling byte-identical replay.\n8. **TS-first authoring**: TypeScript source is normalized to ES2020-equivalent IR with capability annotations preserved.\n\n## Child Beads (dependency order)\n### Foundation Layer\n- **bd-crp**: Parser trait + canonical AST for ES2020 script/module goals (IR0 foundation)\n- **bd-1wa**: Multi-level IR contract (IR0/IR1/IR2/IR3/IR4) with canonical serialization/hash invariants\n- **bd-20b**: Typed execution-slot registry and ABI contract for verified self-replacement\n\n### Compilation Pipeline\n- **bd-ug9**: Lowering pipelines (IR0→IR1→IR2→IR3) with per-pass verification and witness emission\n- **bd-1fm**: IFC flow-lattice semantics in IR2 (label classes, clearance classes, declassification obligations)\n- **bd-3jg**: Static flow-check pass proving source/sink legality with flow-proof witness artifacts\n- **bd-161**: Proof-to-specialization linkage in IR3/IR4 (security proofs as optimizer inputs)\n\n### Execution Layer\n- **bd-2f8**: Baseline interpreter skeleton for both lanes (QuickJS-inspired-native, V8-inspired-native)\n- **bd-1m9**: Complete ES2020 object/prototype semantics (Proxy, Reflect, property descriptors, no permanent subset)\n- **bd-1k7**: Closure and lexical scope model (lexical scoping, TDZ, scope chain, IFC label propagation)\n- **bd-o8v**: Deterministic Promise jobs/microtask ordering and async semantics\n- **bd-2tx**: Deterministic error/exception semantics with eval error contract\n\n### Front-End\n- **bd-309**: TS front-end normalization contract (TS → ES2020-equivalent IR with capability extraction)\n\n## Exit Gates\n- **Phase A**: Native execution lanes pass baseline conformance (test262 ES2020 subset). All child beads in Foundation and Execution layers must be complete.\n- **Phase B**: Security subsystems active (IFC flow-check, proof-to-specialization linkage). Compilation Pipeline beads must be complete.\n- **Phase C**: >= 3x performance vs Node/Bun. Requires optimization work in 10.6 but depends on correct baselines from this epic.\n\n## Cross-Section Dependencies\n- **Blocks**: 10.3 (Memory + GC), 10.4 (Module + Runtime Surface), 10.5 (Extension Host + Security), 10.6 (Performance Program), 10.7 (Conformance + Verification), 10.10 (FCP-Inspired Hardening), 10.15 (Delta Moonshots)\n- **Blocked by**: nothing (this is the foundational execution track)\n\n## Success Criteria\n1. All child beads complete with artifact-backed acceptance evidence\n2. Both execution lanes produce identical results for identical inputs (determinism invariant)\n3. test262 ES2020 parse/eval conformance meets Phase A exit gate threshold\n4. IR witness artifacts are emitted at every compilation and execution stage\n5. IFC flow labels propagate correctly through the full IR stack\n6. TS-first authoring produces behaviorally equivalent results to tsc+Node baseline\n7. Execution-slot registry supports runtime slot swapping with behavior preservation","status":"open","priority":2,"issue_type":"epic","created_at":"2026-02-20T07:32:18.302155218Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:56.750602284Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-2"],"dependencies":[{"issue_id":"bd-ntq","depends_on_id":"bd-161","type":"parent-child","created_at":"2026-02-20T07:52:42.944714339Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-1fm","type":"parent-child","created_at":"2026-02-20T07:52:44.042229023Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-1k7","type":"parent-child","created_at":"2026-02-20T07:52:44.714629212Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-1m9","type":"parent-child","created_at":"2026-02-20T07:52:44.980743074Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-1wa","type":"parent-child","created_at":"2026-02-20T07:52:45.988273023Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-20b","type":"parent-child","created_at":"2026-02-20T07:52:46.395673104Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-2f8","type":"parent-child","created_at":"2026-02-20T07:52:47.703189678Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-2tx","type":"parent-child","created_at":"2026-02-20T07:52:49.665728572Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-309","type":"parent-child","created_at":"2026-02-20T07:52:50.657421454Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-3jg","type":"parent-child","created_at":"2026-02-20T07:52:52.519160831Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-3vh","type":"blocks","created_at":"2026-02-20T07:32:55.347873177Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-crp","type":"parent-child","created_at":"2026-02-20T07:52:55.318112615Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-o8v","type":"parent-child","created_at":"2026-02-20T07:52:56.343733262Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-ug9","type":"parent-child","created_at":"2026-02-20T07:52:56.750530450Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-o8v","title":"[10.2] Implement deterministic Promise jobs/microtask ordering and async semantics.","description":"## Plan Reference\nSection 10.2, item 12. Cross-refs: 9A.3 (deterministic evidence graph), 9F.3 (deterministic replay), 9F.4 (Capability-Typed TS Execution), Phase A exit gate.\n\n## What\nImplement deterministic Promise job queue, microtask ordering, and async/await semantics. The key design constraint is full determinism: given the same inputs, Promise resolution order must be identical across runs, across execution lanes, and across replays.\n\n## Detailed Requirements\n- Promise state machine: pending, fulfilled, rejected with correct state transitions\n- Promise.resolve, Promise.reject, Promise.all, Promise.allSettled, Promise.any, Promise.race with correct semantics\n- Microtask queue: enqueue PromiseReactionJob and PromiseResolveThenableJob per ES2020 spec\n- Job ordering: microtask queue drains completely before returning to macrotask queue (event loop integration)\n- async/await: async functions return Promises; await suspends execution and enqueues continuation as microtask\n- for-await-of: async iteration protocol\n- Deterministic ordering: the microtask queue must produce identical ordering given identical inputs, regardless of system timing, thread scheduling, or execution lane choice\n- Replay compatibility: Promise resolution order must be captured in IR4 witness artifacts for deterministic replay (per 9F.3)\n- Error propagation: unhandled rejections must follow deterministic reporting order\n\n## Rationale\nNon-deterministic scheduling is the single most common cause of replay divergence in JavaScript runtimes. If two Promises resolve in different order across runs, replay fails, evidence graphs become inconsistent, and IFC flow analysis may miss data paths. The plan (9A.3, 9F.3) requires deterministic replay as a first-class property. This means the Promise/microtask system cannot rely on OS scheduling, timer jitter, or any external non-deterministic input. Every scheduling decision must be a deterministic function of program state. This is a hard architectural constraint that must be designed in from the start, not patched later.\n\n## Testing Requirements\n- Unit tests: Promise state transitions (pending → fulfilled, pending → rejected, settled is immutable)\n- Unit tests: Promise.all/race/any/allSettled with various resolution patterns\n- Unit tests: microtask ordering - verify exact microtask execution sequence for known patterns\n- Unit tests: async/await - verify suspension and resumption produces correct values\n- Unit tests: nested Promise chains - verify resolution order matches ES2020 spec\n- Unit tests: determinism - run same async code 100 times, verify identical microtask ordering\n- Unit tests: replay - capture witness, replay from witness, verify identical behavior\n- Conformance: test262 built-ins/Promise, language/expressions/await, language/statements/for-await-of\n- Stress tests: deeply nested Promise chains, Promise.all with 1000+ elements, rapid resolve/reject cycling\n\n## Implementation Notes\n- Microtask queue should be a simple FIFO with no priority or preemption\n- async/await desugaring should happen at IR1→IR2 lowering, not in the interpreter\n- Witness emission: record each microtask enqueue/dequeue event in IR4 for replay\n- No reliance on tokio/async-std scheduling - the microtask queue is purely synchronous within a single execution turn\n- Both execution lanes (QuickJS-inspired and V8-inspired) must produce identical microtask ordering for identical programs\n\n## Dependencies\n- Blocked by: baseline interpreter skeleton (bd-2f8), ES2020 object semantics (bd-1m9) for Promise objects, closure/scope model (bd-1k7) for async function scoping\n- Blocks: Phase A exit gate conformance, deterministic replay system (10.5), event loop integration (10.4)","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.839997827Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.265796176Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"]}
{"id":"bd-pace","title":"[13] all SQLite-backed control-plane persistence in FrankenEngine is delivered through `/dp/frankensqlite` integration, with `/dp/sqlmodel_rust` used where typed model layers materially improve safety","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: all SQLite-backed control-plane persistence in FrankenEngine is delivered through `/dp/frankensqlite` integration, with `/dp/sqlmodel_rust` used where typed model layers materially improve safety\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:22.173603817Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.305371118Z","closed_at":"2026-02-20T07:39:59.484477117Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-qozg","title":"[13] security and performance claims are artifact-backed and reproducible","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: security and performance claims are artifact-backed and reproducible\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:19.631811548Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.345127298Z","closed_at":"2026-02-20T07:40:00.719193158Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-qse","title":"[10.11] Add obligation leak response policy split (`lab=fatal`, `prod=diagnostic + scoped failover`).","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add obligation leak response policy split (`lab=fatal`, `prod=diagnostic + scoped failover`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.207033523Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.384787198Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-rr94","title":"[10.14] Add cross-repo contract tests validating schema/API compatibility for integration boundaries (`frankentui`, `frankensqlite`, `sqlmodel_rust`, `fastapi_rust`).","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add cross-repo contract tests validating schema/API compatibility for integration boundaries (`frankentui`, `frankensqlite`, `sqlmodel_rust`, `fastapi_rust`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:46.516678118Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.424028058Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-skw6","title":"[13] untrusted extension code is actively monitored and auto-contained under attack scenarios","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: untrusted extension code is actively monitored and auto-contained under attack scenarios\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:19.423294387Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.463391746Z","closed_at":"2026-02-20T07:40:00.817580432Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-t2m","title":"[10.5] Implement forensic replay tooling for incident traces.","description":"## Plan Reference\nSection 10.5, item 7 (Implement forensic replay tooling for incident traces). Cross-refs: 9A.3 (deterministic replay infrastructure), 9F.3 (deterministic time-travel + counterfactual replay), 9C.2 (decision loop must be explainable and replayable).\n\n## What\nImplement tooling that can replay a recorded incident trace -- comprising hostcall telemetry logs, posterior update history, decision events, and containment actions -- and reproduce the exact sequence of security decisions that were made during the original incident. The replay tool also supports counterfactual analysis: given an incident trace, the operator can modify parameters (e.g., change the loss matrix, adjust the prior, inject additional evidence) and observe how the decision trajectory would have changed. This is the forensic and continuous-improvement backbone of the security system.\n\n## Detailed Requirements\n- Define `IncidentTrace` struct containing: `trace_id: TraceId`, `extension_id: ExtensionId`, `telemetry_log: Vec<HostcallTelemetryRecord>`, `posterior_history: Vec<(u64, Posterior)>`, `decision_log: Vec<ActionDecision>`, `containment_log: Vec<ContainmentReceipt>`, `metadata: IncidentMetadata`.\n- Implement `ForensicReplayer` with methods:\n  - `replay(trace: &IncidentTrace, config: ReplayConfig) -> ReplayResult` - replay the trace deterministically, producing an identical decision trajectory.\n  - `counterfactual(trace: &IncidentTrace, modifications: CounterfactualSpec) -> ReplayResult` - replay with modified parameters and report divergence points.\n  - `diff(original: &ReplayResult, counterfactual: &ReplayResult) -> ReplayDiff` - structured diff showing where and why decisions diverged.\n- `CounterfactualSpec` allows modifying: prior, loss matrix, evidence injection/removal, posterior updater configuration.\n- `ReplayResult` contains the full decision trajectory: `Vec<(step_index, Evidence, Posterior, ActionDecision)>`.\n- `ReplayDiff` identifies: first divergence point, list of decision changes, final outcome difference.\n- Deterministic replay guarantee: `replay(trace, default_config)` MUST produce bit-identical `ReplayResult` to the original decision trajectory. Any divergence is a bug.\n- The replayer must be usable both as a library API and as a CLI tool (`franken-forensic-replay`) for operator use.\n- Support streaming replay for large traces that do not fit in memory.\n- Include a trace validation step that checks internal consistency (monotonic timestamps, posterior sums to 1.0, decisions match posteriors).\n\n## Rationale\nPer 9F.3, the engine must support deterministic time-travel and counterfactual replay. This is essential for: (a) post-incident analysis (\"why did the engine quarantine this extension?\"), (b) decision system tuning (\"would a different loss matrix have caught this earlier?\"), (c) regression testing (\"does a model update change decisions on historical incidents?\"), and (d) auditor/regulator requirements (\"prove that this security action was the correct response to the evidence\"). The counterfactual capability is what separates forensic replay from simple log viewing: it enables causal reasoning about security decisions.\n\n## Testing Requirements\n- **Determinism tests**: Record a live incident trace, replay it, and verify bit-identical decision trajectory. Repeat 100 times; all must match.\n- **Counterfactual tests**: Replay with a more aggressive loss matrix; verify earlier containment. Replay with injected additional malicious evidence; verify faster detection. Replay with removed evidence; verify delayed or missed detection.\n- **Diff tests**: Verify `ReplayDiff` correctly identifies divergence points and classifies decision changes.\n- **Consistency validation tests**: Inject corrupted traces (out-of-order timestamps, posteriors that do not sum to 1.0, decisions that do not match posteriors) and verify the validator catches them.\n- **Streaming tests**: Replay a trace larger than available memory in streaming mode; verify correct results.\n- **CLI tests**: End-to-end test of the `franken-forensic-replay` CLI tool with a recorded trace file.\n\n## Implementation Notes\n- The replayer instantiates a fresh `BayesianPosteriorUpdater` and `ExpectedLossSelector` with the trace's original configuration, then feeds evidence records one at a time, comparing each step's output to the recorded trajectory.\n- For counterfactual replay, the replayer uses the modified configuration but the same evidence sequence (unless evidence injection/removal is specified).\n- Trace serialization format should be CBOR or a custom binary format for compactness and determinism; avoid JSON for large traces.\n- The CLI tool should support output formats: human-readable summary, JSON detail, and a structured diff format.\n- Consider integration with the telemetry recorder's (bd-5pk) checkpoint mechanism for trace extraction.\n\n## Dependencies\n- **Blocked by**: bd-5pk (telemetry records are the trace input), bd-3md (posterior updater must be replayable), bd-1y5 (action selector must be replayable), bd-2gl (containment receipts are part of the trace).\n- **Blocks**: Calibration and continuous improvement of the Bayesian models. Phase B exit gate evidence (proving detection-to-containment latency compliance on historical incidents).\n- **Parent**: bd-1yq (10.5 epic).","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.687661517Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.502842928Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"]}
{"id":"bd-tgv","title":"[10.4] Implement module resolver trait with policy hooks.","description":"## Plan Reference\nSection 10.4, item 1. Cross-refs: 9A.1 (TS-first authoring), 9A.7 (capability lattice), Phase D (Node/Bun surface superset).\n\n## What\nImplement the module resolver trait with policy hooks. The resolver determines how import/require statements are resolved to actual code, with security policy enforcement at resolution time.\n\n## Detailed Requirements\n- Module resolver trait: generic interface for resolving module specifiers to loadable code\n- Policy hooks: capability checks at resolution time (can this extension import this module?)\n- Support both ES module (import) and CommonJS (require) resolution semantics\n- Resolution must be deterministic: same specifier + same policy → same resolution\n- Built-in module resolution for FrankenEngine standard library\n- External module resolution with provenance tracking (where did this code come from?)\n- Resolution errors must be structured and deterministic (not platform-dependent)\n- Policy hook integration: capability lattice checks before allowing resolution (per 9A.7)\n\n## Rationale\nModule resolution is a security boundary: it determines what code an extension can access. The plan requires capability-typed execution (9A.1) which means module access must be governed by the capability lattice. Without policy hooks at resolution time, extensions could bypass capability restrictions by importing unrestricted modules. Phase D requires Node/Bun module compatibility, so the resolver must support both ESM and CJS.\n\n## Testing Requirements\n- Unit tests: resolve built-in module specifiers correctly\n- Unit tests: resolve relative and absolute path specifiers\n- Unit tests: policy hook denies resolution when capability is missing\n- Unit tests: deterministic resolution (same inputs → same output)\n- Integration tests: resolve chains (A imports B imports C), verify transitive policy checks\n- Compatibility tests: Node-style resolution for CJS modules, ESM resolution for ES modules\n\n## Implementation Notes\n- Define trait in crates/franken-engine with default implementations for common cases\n- Policy hooks should accept Capability context from the extension manifest\n- Consider caching resolved modules (but cache invalidation is bd-16x)\n- Resolution provenance should feed into evidence graph for forensic audit\n\n## Dependencies\n- Blocked by: parser trait (10.2 bd-crp) for module parsing, capability lattice design (10.5)\n- Blocks: module cache invalidation (bd-16x), compatibility mode matrix (bd-3vp), Phase D work","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:23.504206677Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.542296053Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-4"]}
{"id":"bd-ttd","title":"[10.0] Top-10 #7: Capability lattice + typed policy DSL (strategy: `9A.7`; deep semantics: `9F.8`; execution owners: `10.5`, `10.10`, `10.12`, `10.13`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #7: Capability lattice + typed policy DSL (strategy: `9A.7`; deep semantics: `9F.8`; execution owners: `10.5`, `10.10`, `10.12`, `10.13`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:20.022177843Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.581704906Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"]}
{"id":"bd-twz2","title":"[13] secure extension reputation graph drives measurable reduction in first-time compromise windows","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: secure extension reputation graph drives measurable reduction in first-time compromise windows\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:23.441037994Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.622194541Z","closed_at":"2026-02-20T07:39:58.886875205Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
{"id":"bd-ug9","title":"[10.2] Implement lowering pipelines with per-pass verification and witness emission.","description":"## Plan Reference\nSection 10.2, item 3. Cross-refs: 9B.1 (incremental/self-adjusting compilation), 9C.1 (proof-carrying compilation with isomorphism ledger), 9D.1 (compilation benchmark suite).\n\n## What\nImplement the lowering pipelines that transform code through the IR stack: IR0→IR1→IR2→IR3. Each pass must emit verification witnesses proving the transformation preserves semantics.\n\n## Detailed Requirements\n- IR0→IR1 lowering: resolve scopes, bindings, and spec-level semantics\n- IR1→IR2 lowering: annotate capability intent, effect boundaries, and IFC flow labels\n- IR2→IR3 lowering: produce execution-ready form with proof linkage metadata\n- Each pass must emit a witness artifact proving semantic preservation (per 9C.1 proof-carrying compilation contract)\n- Isomorphism ledger: record ordering/tie-break semantics and verify behavioral equivalence on golden corpora (per 9C.1)\n- Passes must be independently testable and composable\n- Support per-pass verification: each lowering step can be validated in isolation\n- Consider incremental/self-adjusting compilation (per 9B.1) for low-latency rebuilds under rapid extension edits\n\n## Rationale\nThe plan requires proof-carrying compilation (9C.1): 'each lowering stage emits invariants and a machine-checkable witness that capability annotations are preserved end-to-end.' This means lowering is not just a transformation but a verified transformation pipeline. The witness artifacts feed into the deterministic evidence graph (9A.3) and are required for replay/audit.\n\n## Testing Requirements\n- Unit tests: lower valid IR0 through each stage, verify output IR type and content\n- Unit tests: verify witness artifacts are emitted for each pass\n- Unit tests: verify lowering rejects invalid IR (missing required annotations)\n- Golden corpus tests: lower known inputs, compare output IR hashes against golden values\n- Isomorphism tests: verify lowered IR produces identical behavior to source\n- Performance: benchmark each lowering pass separately (per 9D.1)\n\n## Implementation Notes\n- Each pass should be a separate function/module for testability\n- Witness format should be defined in the IR contract (bd-1wa)\n- Consider arena allocation for intermediate IR nodes\n- Passes should be pure functions (no side effects) for determinism\n\n## Dependencies\n- Blocked by: parser trait (bd-crp), IR contract (bd-1wa)\n- Blocks: interpreter skeleton (bd-2f8), IFC flow-check (bd-3jg), proof-to-specialization (bd-161)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.672487055Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.661288037Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"]}
{"id":"bd-ulle","title":"[11] Define deterministic rollback command and known-good recovery path","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: rollback command\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:17.140889042Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.700719822Z","closed_at":"2026-02-20T07:38:22.899595123Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-ulle","depends_on_id":"bd-3tjn","type":"blocks","created_at":"2026-02-20T07:38:26.506754839Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-uvmm","title":"[10.13] Emit canonical evidence entries via `franken-evidence` for all high-impact actions, linked to `trace_id`, `decision_id`, `policy_id`, and artifact hashes.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Emit canonical evidence entries via `franken-evidence` for all high-impact actions, linked to `trace_id`, `decision_id`, `policy_id`, and artifact hashes.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:43.116221318Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.739578580Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-uwc","title":"[10.9] Release gate: autonomous quarantine mesh is implemented and validated under fault injection (implementation ownership: `10.12`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: autonomous quarantine mesh is implemented and validated under fault injection (implementation ownership: `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.000188653Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.778869754Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"]}
{"id":"bd-von8","title":"[11] Require explicit expected-loss model with asymmetric risk costs","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: expected-loss model\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:16.487226497Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.817908817Z","closed_at":"2026-02-20T07:38:23.204039826Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-von8","depends_on_id":"bd-3qm1","type":"blocks","created_at":"2026-02-20T07:38:26.156742107Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-xga","title":"[10.11] Define monotonic `security_epoch` model and validity-window checks across signed trust artifacts.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Define monotonic `security_epoch` model and validity-window checks across signed trust artifacts.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.669967173Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.857377241Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-xq7","title":"Port extension manifest validation scaffold into franken-extension-host","description":"## Plan Reference\nSection 10.5, item 1 (Port extension manifest validation into compile-active modules). Cross-refs: 9A.1 (capability-typed execution model), 9A.7 (capability lattice + typed policy DSL), 9A.5 (supply-chain trust fabric).\n\n## What\nPromote the existing runtime manifest validation logic in `crates/franken-extension-host/src/lib.rs` into a compile-active module so that manifest correctness is enforced at build time wherever possible. The existing `ExtensionManifest`, `Capability` enum, `ManifestValidationError`, and `validate_manifest()` function form the foundation. This bead extends them with: (a) compile-time const-evaluable validation paths for statically-known manifests, (b) capability-lattice awareness so that declared capabilities are checked against the 9A.7 lattice ordering (e.g., `FsWrite` implies `FsRead`), (c) supply-chain provenance fields required by 9A.5 (publisher signature, content hash, trust-chain reference), and (d) deterministic serialization so manifest bytes are reproducible for signature verification.\n\n## Detailed Requirements\n- Extend `ExtensionManifest` with fields: `publisher_signature: Option<Vec<u8>>`, `content_hash: [u8; 32]`, `trust_chain_ref: Option<String>`, `min_engine_version: String`.\n- Extend `ManifestValidationError` with variants: `InvalidCapabilityLattice { declared: Capability, missing_implied: Capability }`, `InvalidContentHash`, `MissingPublisherSignature`, `UnsupportedEngineVersion`.\n- Implement `validate_capability_lattice()` that checks declared capabilities against the partial order defined in the capability lattice (9A.7). If an extension declares `FsWrite` but not `FsRead`, validation must fail.\n- Implement `validate_provenance()` that checks publisher signature and content hash fields when the trust level requires them.\n- Provide a `const fn`-compatible validation path for manifests known at compile time (using `const`-friendly subset of checks).\n- All validation errors must produce deterministic, structured error messages suitable for logging with `trace_id` and `extension_id` context.\n- Manifest serialization must be canonical (sorted keys, no optional whitespace) to ensure content-hash stability.\n\n## Rationale\nThe plan mandates that extension security is impossible-by-default: no extension runs without a validated manifest. Moving validation to compile-active modules means that statically-linked extensions are verified at build time, eliminating an entire class of runtime failures. The capability lattice check ensures extensions cannot under-declare their authority footprint. Provenance fields connect to the supply-chain trust fabric (9A.5) so that the runtime can verify publisher identity before loading any extension code.\n\n## Testing Requirements\n- **Unit tests**: Validate manifests with every valid capability combination. Test lattice violations (e.g., `FsWrite` without `FsRead`). Test all error variants produce correct deterministic messages. Test canonical serialization round-trips.\n- **Compile-time tests**: Verify that `const`-path validation catches errors at compile time for static manifests.\n- **Integration tests**: Load a manifest from TOML/JSON, validate, and check that provenance fields are correctly verified against a test trust chain.\n- **Adversarial tests**: Malformed manifests (missing fields, extra fields, duplicate capabilities, empty strings, extremely long strings, invalid UTF-8 in name).\n\n## Implementation Notes\n- Existing code in `crates/franken-extension-host/src/lib.rs` already has `Capability` (5 variants), `ExtensionManifest`, `ManifestValidationError` (5 variants), `validate_manifest()`, and comprehensive tests for the current validation surface.\n- The `BTreeSet`-based duplicate detection is already in place; extend it with lattice-implication checks.\n- Use `serde` with `#[serde(rename_all = \"snake_case\")]` (already present) and add canonical serialization via a deterministic JSON serializer or CBOR.\n- `#![forbid(unsafe_code)]` is already set; maintain this invariant.\n\n## Dependencies\n- **Blocked by**: None (foundational bead for 10.5).\n- **Blocks**: bd-1hu (lifecycle manager needs validated manifests), bd-5pk (telemetry references manifest identity), bd-375 (delegate cells need manifest validation path), all downstream 10.5 beads that assume manifest integrity.\n- **Parent**: bd-1yq (10.5 epic).","status":"in_progress","priority":1,"issue_type":"task","assignee":"AzureMountain","created_at":"2026-02-20T07:24:27.192973464Z","created_by":"AzureMountain","updated_at":"2026-02-20T07:52:41.896397991Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["extension-host","plan","section-10-5","security","validation"]}
{"id":"bd-ye6k","title":"[14] Update standards with explicit versioning and migration notes.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Update standards with explicit versioning and migration notes.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:28.509746083Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.935795683Z","closed_at":"2026-02-20T07:41:21.621584293Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-yi6","title":"[10.11] Add phase gates for this track: deterministic replay pass, interleaving suite pass, conformance vectors pass, and fuzz/adversarial pass.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add phase gates for this track: deterministic replay pass, interleaving suite pass, conformance vectors pass, and fuzz/adversarial pass.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:38.071605272Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:41.974782469Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"]}
{"id":"bd-ypl4","title":"[10.13] Add naming guidance to the ADR: Cargo package names (`franken-kernel`, `franken-decision`, `franken-evidence`) and Rust crate paths (`franken_kernel`, `franken_decision`, `franken_evidence`) are both normative references.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add naming guidance to the ADR: Cargo package names (`franken-kernel`, `franken-decision`, `franken-evidence`) and Rust crate paths (`franken_kernel`, `franken_decision`, `franken_evidence`) are both normative references.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:41.801377101Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:42.014113858Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"]}
{"id":"bd-yqe","title":"[10.12] Define proof schema and signer model for optimizer activation witnesses (`opt_receipt`, `rollback_token`, `invariance_digest`).","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Define proof schema and signer model for optimizer activation witnesses (`opt_receipt`, `rollback_token`, `invariance_digest`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:38.223290222Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:42.052991240Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"]}
{"id":"bd-yqg5","title":"[10.14] Add release checklist item requiring explicit “reuse vs reimplement” justification for any new console, SQLite, or service layer work.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add release checklist item requiring explicit “reuse vs reimplement” justification for any new console, SQLite, or service layer work.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:46.843784864Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:42.095120280Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"]}
{"id":"bd-zvn","title":"[10.14] FrankenSuite Sibling Integration Track - Comprehensive Execution Epic","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:19.072342452Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:57.211028442Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-14"],"dependencies":[{"issue_id":"bd-zvn","depends_on_id":"bd-1ad6","type":"parent-child","created_at":"2026-02-20T07:52:43.346811442Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-1coe","type":"parent-child","created_at":"2026-02-20T07:52:43.679639987Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-1edh","type":"parent-child","created_at":"2026-02-20T07:52:43.879910219Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-1ps3","type":"parent-child","created_at":"2026-02-20T07:52:45.455616951Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-1qgn","type":"parent-child","created_at":"2026-02-20T07:52:45.495117745Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-26qa","type":"parent-child","created_at":"2026-02-20T07:52:46.919061405Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-2d21","type":"parent-child","created_at":"2026-02-20T07:52:47.623806439Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-2l0x","type":"parent-child","created_at":"2026-02-20T07:52:48.373481580Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-30vf","type":"parent-child","created_at":"2026-02-20T07:52:50.739553002Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-3azm","type":"parent-child","created_at":"2026-02-20T07:52:51.625613273Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-3nr","type":"blocks","created_at":"2026-02-20T07:32:57.715391711Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-3o95","type":"parent-child","created_at":"2026-02-20T07:52:53.114680753Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-89l2","type":"parent-child","created_at":"2026-02-20T07:52:54.995524254Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-rr94","type":"parent-child","created_at":"2026-02-20T07:52:56.503033824Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-yqg5","type":"parent-child","created_at":"2026-02-20T07:52:57.210951659Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-zze6","title":"[14] Throughput claims must be accompanied by latency/error envelopes so speedups cannot hide tail-collapse or correctness loss.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Throughput claims must be accompanied by latency/error envelopes so speedups cannot hide tail-collapse or correctness loss.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:31.392914698Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:42.178504260Z","closed_at":"2026-02-20T07:41:20.401677447Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"]}
{"id":"bd-zzgz","title":"[13] proof-specialized execution lanes show measurable throughput or tail-latency improvement versus ambient-authority lanes at equivalent semantics","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: proof-specialized execution lanes show measurable throughput or tail-latency improvement versus ambient-authority lanes at equivalent semantics\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:26.640725162Z","created_by":"ubuntu","updated_at":"2026-02-20T07:52:42.218405901Z","closed_at":"2026-02-20T07:39:57.492950760Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"]}
