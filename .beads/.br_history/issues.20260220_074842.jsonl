{"id":"bd-10a","title":"Add donor-extraction scope document with explicit V8/QuickJS exclusions","description":"Implements PLAN 10.1 fourth TODO: define semantic donor extraction scope and explicit exclusions, including prohibition on transplanting V8/QuickJS architecture/runtime internals while allowing behavior-level semantic harvesting. Include acceptance criteria and review gates.","status":"in_progress","priority":1,"issue_type":"task","assignee":"StormyPond","created_at":"2026-02-20T07:24:56.303039948Z","created_by":"StormyPond","updated_at":"2026-02-20T07:45:15.320248677Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["architecture","documentation","donor-spec","governance","plan","section-10-1"],"dependencies":[{"issue_id":"bd-10a","depends_on_id":"bd-2mf","type":"parent-child","created_at":"2026-02-20T07:45:07.397769666Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10a","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.320196790Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-117","title":"[10.11] Add deterministic fallback protocol when anti-entropy reconciliation cannot peel/resolve.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add deterministic fallback protocol when anti-entropy reconciliation cannot peel/resolve.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:37.768994935Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:29.172966884Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-117","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:05.975940932Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-11ni","title":"[11] Define deterministic fallback-trigger conditions and safe-mode entry","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: fallback trigger\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Fallback trigger conditions are formally specified with deterministic predicates.\\n2. Safe-mode transition is exercised by unit tests and end-to-end replay scenarios with structured logs.\\n3. Documentation includes operator-visible trigger semantics and rollback linkage.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:16.714171974Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:17.028618971Z","closed_at":"2026-02-20T07:38:23.098483379Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-11ni","depends_on_id":"bd-c1co","type":"parent-child","created_at":"2026-02-20T07:45:17.028566693Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-11ni","depends_on_id":"bd-von8","type":"blocks","created_at":"2026-02-20T07:38:26.271271018Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-11p","title":"[10.7] Integrate `test262` ES2020 normative profile as a release blocker with explicit waiver file and zero silent failures policy.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Integrate `test262` ES2020 normative profile as a release blocker with explicit waiver file and zero silent failures policy.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.184167072Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:29.262817635Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"],"dependencies":[{"issue_id":"bd-11p","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-02-20T07:45:09.304049463Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-11ua","title":"[13] PLAS produces signed `capability_witness` artifacts for >= 90% of targeted extension cohorts in production lanes","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: PLAS produces signed `capability_witness` artifacts for >= 90% of targeted extension cohorts in production lanes\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:24.766230125Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:09.705956758Z","closed_at":"2026-02-20T07:39:58.284248144Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-11ua","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:09.705910071Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-11z7","title":"[10.13] Add compile-time lint/CI guard rejecting ambient authority in extension-host control paths.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add compile-time lint/CI guard rejecting ambient authority in extension-host control paths.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:43.934720672Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:29.355693440Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-11z7","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:11.606964778Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-121","title":"[10.11] Build deterministic lab runtime harness with schedule replay, virtual time, and cancellation injection.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Build deterministic lab runtime harness with schedule replay, virtual time, and cancellation injection.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.501148876Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:29.444171534Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-121","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.020621340Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-127","title":"[10.11] Add bounded masking helper for tiny atomic publication steps only; block long-operation masking by policy.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add bounded masking helper for tiny atomic publication steps only; block long-operation masking by policy.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:33.901233114Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:29.531551102Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-127","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.061688087Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-12m","title":"[10.6] Performance Program - Comprehensive Execution Epic","description":"Plan Reference: section 10.6 (Performance Program).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.562536505Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:42.065626851Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-6"],"dependencies":[{"issue_id":"bd-12m","depends_on_id":"bd-1yq","type":"blocks","created_at":"2026-02-20T07:32:55.957795889Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-12m","depends_on_id":"bd-ntq","type":"blocks","created_at":"2026-02-20T07:32:55.871267855Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-12n5","title":"[10.15] Publish governance scorecards covering attested-receipt coverage, privacy-budget health, moonshot-governor decisions, and cross-repo conformance stability.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Publish governance scorecards covering attested-receipt coverage, privacy-budget health, moonshot-governor decisions, and cross-repo conformance stability.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:49.637142682Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:29.620395949Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-12n5","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:12.816076036Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-12p","title":"[10.12] Add incident replay artifact bundle format and verifier CLI for external audit.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Add incident replay artifact bundle format and verifier CLI for external audit.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.330652847Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:29.708399199Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-12p","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:07.722712824Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-133a","title":"[10.15] Add frankensqlite-backed specialization index enabling deterministic audit queries from security proof -> optimization receipt -> benchmark outcome.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankensqlite-backed specialization index enabling deterministic audit queries from security proof -> optimization receipt -> benchmark outcome.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:53.380938673Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:29.795339779Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-133a","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:12.859952757Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-13a5","title":"Define and enforce evidence-and-decision contract template for all subsystem proposals","description":"## Plan Reference\nSection 11: Evidence And Decision Contracts (Mandatory)\n\n## What\nCreate a mandatory contract template that every major subsystem proposal must satisfy before merge. The template enforces artifact-backed discipline across the entire program.\n\n## Required Template Fields\nEvery proposal must include ALL of the following:\n1. **Change summary**: What is being proposed and why\n2. **Hotspot/threat evidence**: Profile data, threat model, or risk assessment justifying the change\n3. **EV score and tier**: Expected value assessment using the program's EV >= 2.0 threshold from alien-graveyard methodology (Section 5.3)\n4. **Expected-loss model**: Explicit loss matrix for the action space, following alien-artifact-coding discipline (Section 5.2)\n5. **Fallback trigger**: Conditions under which the change auto-reverts or degrades to safe mode\n6. **Rollout wedge**: Staged deployment strategy (shadow -> canary -> ramp -> default per Section 8.8)\n7. **Rollback command**: Exact command(s) to revert the change\n8. **Benchmark and correctness artifacts**: Before/after performance data, golden output checksums, test results\n\n## Enforcement Rule\n'No contract, no merge.' This is a hard gate, not a guideline.\n\n## Rationale\nFrom the plan's ambition-first doctrine: every claim must ship with proof artifacts. This contract template ensures that principle is operationalized at the PR level, preventing unfounded changes from entering the codebase.\n\n## Testing Requirements\n- Unit test: validate that a contract struct with any missing field fails validation\n- Unit test: validate that a complete contract struct passes validation\n- Integration test: CI gate that rejects PRs touching runtime code without a linked contract artifact\n- Test that contract schema is versioned and backward-compatible\n\n## Implementation Notes\n- Implement as a Rust struct with serde support in a shared governance module\n- Consider a CLI subcommand (frankenctl contract validate) for pre-commit checking\n- Store validated contracts alongside code changes in a canonical location\n- Reference: The extreme-software-optimization methodology (Section 5.1) mandates baseline/profile/prove/implement/verify for every optimization - this contract template is the enforcement mechanism\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:38:55.368693030Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:29.887993451Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["documentation","evidence","governance"]}
{"id":"bd-1401","title":"[14] Adversarial resilience (campaign success-rate suppression vs baseline engines).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Adversarial resilience (campaign success-rate suppression vs baseline engines).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:33.792382432Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:04.634571214Z","closed_at":"2026-02-20T07:41:19.377640744Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-1401","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:04.634530328Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-14da","title":"[14] Compute per-case speedup `r_i = throughput_franken_engine_i / throughput_B_i`.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Compute per-case speedup `r_i = throughput_franken_engine_i / throughput_B_i`.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:30.438475371Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:04.678378806Z","closed_at":"2026-02-20T07:41:20.824984602Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-14da","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:04.678334914Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1525","title":"[13] manual policy-authoring time for onboarded extensions is reduced by >= 70% while maintaining security gate compliance","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: manual policy-authoring time for onboarded extensions is reduced by >= 70% while maintaining security gate compliance\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:25.232809293Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:09.773360969Z","closed_at":"2026-02-20T07:39:58.086563560Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-1525","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:09.773313831Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-15g2","title":"[10.15] Add governance audit ledger capturing all automatic and human override promote/hold/kill decisions with signed rationale.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add governance audit ledger capturing all automatic and human override promote/hold/kill decisions with signed rationale.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:48.647418079Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:29.981905135Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-15g2","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:12.899737446Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-15vm","title":"[12] Reduce operational complexity via evidence-ledger tooling and deterministic fallback mode","description":"Plan Reference: section 12 (Risk Register).\nObjective: Operational complexity:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:18.176437649Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:08.819260832Z","closed_at":"2026-02-20T07:39:04.733555437Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"],"dependencies":[{"issue_id":"bd-15vm","depends_on_id":"bd-2rbm","type":"parent-child","created_at":"2026-02-20T07:45:08.819217331Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-161","title":"[10.2] Define proof-to-specialization linkage in IR contracts (`proof_input_ids`, `optimization_class`, `validity_epoch`, `rollback_token`) for IR3/IR4 artifacts.","description":"## Plan Reference\nSection 10.2, item 6. Cross-refs: 9I.8 (Security-Proof-Guided Specialization), 9F.1 (Verified Adaptive Compiler), 10.12 (proof schema for optimizer), 10.15 (specialization receipt schema).\n\n## What\nDefine the linkage between security proofs and optimizer specializations in IR3/IR4 artifacts. This enables security proofs to serve as optimizer inputs, so tighter verified constraints yield faster executable paths.\n\n## Detailed Requirements\n- IR3 artifacts must carry: proof_input_ids (which proofs justify this specialization), optimization_class (superinstruction, trace specialization, layout specialization, devirtualized hostcall fast paths), validity_epoch (when this specialization expires), rollback_token (how to revert to unspecialized path)\n- IR4 witness artifacts must record: which specializations were active during execution, what proofs were consumed, performance delta observed\n- Specializations must be invalidated deterministically on policy/proof epoch changes (per 9I.8)\n- Automatic fallback to unspecialized baseline paths when proofs expire or are invalidated\n\n## Rationale\nSection 9I.8: 'Make security proofs first-class optimizer inputs so tighter verified constraints yield faster executable paths instead of being treated as overhead.' This creates a structural flywheel: better security  better proofs  faster code  more security investment justified. This is described as 'a structural flywheel unavailable to generic runtimes without proof-bearing security planes.'\n\n## Testing Requirements\n- Unit tests: IR3 artifacts with proof linkage serialize/deserialize correctly\n- Unit tests: specialization invalidation on epoch change triggers rollback\n- Unit tests: fallback path produces semantically identical results to specialized path\n- Specialization-conformance suite (10.7): proof-specialized and unspecialized execution remain semantically equivalent\n\n## Dependencies\n- Blocked by: IR contract (bd-1wa), IFC flow-lattice (bd-1fm)\n- Blocks: optimizer activation (10.12), specialization receipt schema (10.15), specialization-conformance suite (10.7)","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.063014834Z","created_by":"ubuntu","updated_at":"2026-02-20T07:48:18.926032801Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"],"dependencies":[{"issue_id":"bd-161","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:45:17.716828868Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-16n","title":"[10.10] Add optional threshold-signing workflow for emergency revocation and key rotation operations.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Add optional threshold-signing workflow for emergency revocation and key rotation operations.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.817987466Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:30.157445657Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-16n","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.364885022Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-16u","title":"[10.10] Define trust-zone taxonomy and capability ceilings with deterministic inheritance semantics.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Define trust-zone taxonomy and capability ceilings with deterministic inheritance semantics.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.812601797Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:30.279996503Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-16u","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.428185841Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-16up","title":"[16] Reference proofs or proof sketches for key policy and protocol safety claims.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: Reference proofs or proof sketches for key policy and protocol safety claims.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:36.451806803Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:50.921687689Z","closed_at":"2026-02-20T07:46:50.921665748Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"],"dependencies":[{"issue_id":"bd-16up","depends_on_id":"bd-esst","type":"parent-child","created_at":"2026-02-20T07:45:17.372779583Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-16x","title":"[10.4] Implement module cache invalidation strategy.","description":"Plan Reference: section 10.4 (Module + Runtime Surface).\nObjective: Implement module cache invalidation strategy.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:23.634424Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:30.370351513Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-4"],"dependencies":[{"issue_id":"bd-16x","depends_on_id":"bd-3ch","type":"parent-child","created_at":"2026-02-20T07:45:11.458669948Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-17v2","title":"[10.15] Add mandatory receipt + replay linkage for every escrow, deny, or emergency grant decision.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add mandatory receipt + replay linkage for every escrow, deny, or emergency grant decision.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:50.968457919Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:30.461784581Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-17v2","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:12.945038450Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-181","title":"[10.9] Release gate: GA default lanes are fully native (`0` mandatory delegate cells), with complete signed replacement lineage for all formerly delegated core slots (implementation ownership: `10.15` + `10.2` + `10.7`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: GA default lanes are fully native (`0` mandatory delegate cells), with complete signed replacement lineage for all formerly delegated core slots (implementation ownership: `10.15` + `10.2` + `10.7`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.575933913Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:30.550791069Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"],"dependencies":[{"issue_id":"bd-181","depends_on_id":"bd-1xm","type":"parent-child","created_at":"2026-02-20T07:45:03.774112205Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-18fu","title":"[11] Require hotspot and threat-evidence bundle per subsystem proposal","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: hotspot/threat evidence\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:16.065176532Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:17.068290329Z","closed_at":"2026-02-20T07:38:23.401865613Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-18fu","depends_on_id":"bd-c1co","type":"parent-child","created_at":"2026-02-20T07:45:17.068241588Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-18m","title":"[10.11] Implement lease-backed remote liveness tracking with explicit timeout/escalation paths.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement lease-backed remote liveness tracking with explicit timeout/escalation paths.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.549170870Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:30.642165278Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-18m","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.101671877Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1999","title":"[10.15] Make matrix+fault conformance lab pass a release blocker for shared-boundary changes, complementing the baseline compatibility gates in `10.14`.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Make matrix+fault conformance lab pass a release blocker for shared-boundary changes, complementing the baseline compatibility gates in `10.14`.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:49.471732515Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:30.731884173Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-1999","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:12.987822626Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-19l0","title":"Define Extension-Heavy Benchmark Suite v1.0 specification and workload matrix","description":"## Plan Reference\nSection 14.1: Extension-Heavy Benchmark Suite v1.0 (Normative)\nSection 7.4-7.5: Benchmark Denominator Contract and Fairness Rules\nSection 9D: Extreme-Software-Optimization Enhancement Map\n\n## What\nDefine and publish the complete benchmark specification that will be used to validate the >= 3x throughput claim (a hard program success criterion from Section 3).\n\n## Suite Structure\nFive benchmark families, each REQUIRED:\n1. **boot-storm**: Extension cold-start and initialization under load\n2. **capability-churn**: Rapid capability grant/revoke cycles\n3. **mixed-cpu-io-agent-mesh**: Combined CPU and I/O workloads simulating agent mesh behavior\n4. **reload-revoke-churn**: Extension hot-reload and revocation under continuous traffic\n5. **adversarial-noise-under-load**: Normal workload with injected adversarial extension behavior\n\nEach family requires three scale profiles: S, M, L with fixed extension counts, event rates, dependency graph sizes, and policy complexity tiers.\n\n## Per-Case Publication Requirements\nEach benchmark case must publish: throughput, p50/p95/p99 latency, allocation/peak memory, correctness digest, and security-event envelope.\n\n## Behavior-Equivalence Requirements (Hard Gates)\n- Equivalent external outputs (canonical digest comparison)\n- Equivalent side-effect trace class (fs/network/process/policy actions normalized by contract schema)\n- Equivalent error-class semantics for negative/exceptional cases\n- No work dropping, relaxed durability, or disabled policy checks to inflate throughput\n\n## Scoring Formula (Binding)\nPrimary score is weighted geometric mean: score(engine, baseline) = exp(sum_i w_i * ln(throughput_engine_i / throughput_baseline_i)), with sum_i w_i = 1\nClaim acceptance requires BOTH: score vs Node >= 3.0 AND score vs Bun >= 3.0\n\n## Fairness Rules (Binding)\n- Baselines pinned to declared versions (Node LTS, Bun stable) with full CLI/env manifests\n- Identical hardware/OS envelopes, warmed/cold cache protocols, fixed dataset seeds\n- Report median + dispersion over repeated runs; publish raw per-run artifacts\n- Result ledgers stored via frankensqlite; operator consoles via frankentui\n- Every claim must include verifier scripts for third-party reruns\n\n## Required Metric Families\n1. Throughput/latency (p50, p95, p99) under extension-heavy workloads\n2. Containment quality (time-to-detect, time-to-contain, FP/FN envelopes)\n3. Replay correctness (determinism pass rate, artifact completeness)\n4. Revocation/quarantine propagation (freshness lag, convergence SLO attainment)\n5. Adversarial resilience (campaign success-rate suppression vs baselines)\n6. Information-flow security (unauthorized flow block rate, declassification envelopes)\n7. Security-proof specialization uplift (proof-specialized vs ambient-authority delta)\n\n## Testing Requirements\n- Unit tests for scoring formula implementation (golden test vectors for weighted geometric mean)\n- Unit tests for behavior-equivalence checker (known-equivalent and known-divergent cases)\n- Integration test running mini S-profile benchmark end-to-end\n- E2E test: full suite run produces valid result artifacts with all required fields\n\n## Rationale\nFrom Section 3: the >= 3x claim is the disruptive floor. From Section 14: FrankenEngine will define and own the reference benchmark standard. This bead defines the scoreboard that competitors must follow.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:41:53.952557303Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:30.822927445Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["benchmark","performance","specification"]}
{"id":"bd-1ad6","title":"[10.14] Define a `franken_engine` TUI adapter boundary for incident replay views, policy explanation cards, and control dashboards backed by `frankentui` components.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Define a `franken_engine` TUI adapter boundary for incident replay views, policy explanation cards, and control dashboards backed by `frankentui` components.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:44.898570137Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:30.919085493Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-1ad6","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:18.454009653Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1ai","title":"[10.10] Implement revocation freshness policy with explicit degraded-mode behavior and audit emission.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement revocation freshness policy with explicit degraded-mode behavior and audit emission.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.663094452Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:31.011702897Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-1ai","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.473315886Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1b2","title":"[10.10] Implement signature preimage contract using unsigned-view encoding and deterministic field ordering.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement signature preimage contract using unsigned-view encoding and deterministic field ordering.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.556632523Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:31.100493613Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-1b2","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.515708072Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1bi","title":"[10.10] Implement session-authenticated extension hostcall channel with per-message MAC.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement session-authenticated extension hostcall channel with per-message MAC.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.957371725Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:31.187669843Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-1bi","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.561034322Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1bl","title":"[10.11] Implement obligation-tracked channels for safety-critical two-phase internal protocols.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement obligation-tracked channels for safety-critical two-phase internal protocols.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.047346797Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:31.276429001Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-1bl","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.144152347Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1blo","title":"[12] Counter heuristic-security false confidence with Bayesian + sequential testing + calibration audits","description":"Plan Reference: section 12 (Risk Register).\nObjective: False confidence from heuristic security:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:17.760799368Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:08.885213719Z","closed_at":"2026-02-20T07:39:04.932159503Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"],"dependencies":[{"issue_id":"bd-1blo","depends_on_id":"bd-2rbm","type":"parent-child","created_at":"2026-02-20T07:45:08.885171761Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1bzp","title":"[10.12] Define and publish category benchmark specification with reproducible harness and transparent scoring methodology.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Define and publish category benchmark specification with reproducible harness and transparent scoring methodology.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:41.181176444Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:31.368821035Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-1bzp","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:07.767579819Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1c7","title":"[10.10] Define `PolicyCheckpoint` object with `prev_checkpoint`, `checkpoint_seq`, `epoch_id`, policy heads, and quorum signatures.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Define `PolicyCheckpoint` object with `prev_checkpoint`, `checkpoint_seq`, `epoch_id`, policy heads, and quorum signatures.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.838779423Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:31.457030869Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-1c7","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.603074723Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1coe","title":"[10.14] Add benchmark gates confirming sibling-repo integrations do not regress critical p95/p99 control-plane SLOs.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add benchmark gates confirming sibling-repo integrations do not regress critical p95/p99 control-plane SLOs.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:46.678758372Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:31.546204619Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-1coe","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:18.493899448Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1cu","title":"[10.0] Top-10 #6: Shadow-run + differential executor onboarding mode (strategy: `9A.6`; deep semantics: `9F.6`; execution owners: `10.7`, `10.12`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #6: Shadow-run + differential executor onboarding mode (strategy: `9A.6`; deep semantics: `9F.6`; execution owners: `10.7`, `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:19.897460064Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:31.637184854Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"],"dependencies":[{"issue_id":"bd-1cu","depends_on_id":"bd-1of","type":"parent-child","created_at":"2026-02-20T07:43:30.946411325Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1ddd","title":"[10.12] Build operator safety copilot surfaces with recommended actions, confidence bands, and deterministic rollback commands.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Build operator safety copilot surfaces with recommended actions, confidence bands, and deterministic rollback commands.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:41.025696575Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:31.727205852Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-1ddd","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:07.812696640Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1dp","title":"[10.10] Implement owner-signed key attestation objects with expiry and nonce freshness requirements.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement owner-signed key attestation objects with expiry and nonce freshness requirements.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.678161144Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:31.817610174Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-1dp","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.648537818Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1dxl","title":"[14] Containment quality (time-to-detect, time-to-contain, false-positive/false-negative envelopes).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Containment quality (time-to-detect, time-to-contain, false-positive/false-negative envelopes).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:33.082574256Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:04.721266224Z","closed_at":"2026-02-20T07:41:19.674683569Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-1dxl","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:04.721222463Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1edh","title":"[10.14] Add conformance tests proving deterministic replay/index behavior across `frankensqlite`-backed stores.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add conformance tests proving deterministic replay/index behavior across `frankensqlite`-backed stores.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:46.025767468Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:31.907004855Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-1edh","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:18.536806553Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1elf","title":"[13] 100% of activated proof-specializations carry signed receipts linking security-proof inputs to transformation and rollback artifacts","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: 100% of activated proof-specializations carry signed receipts linking security-proof inputs to transformation and rollback artifacts\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:26.875627360Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:09.816835561Z","closed_at":"2026-02-20T07:39:57.393735513Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-1elf","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:09.816777803Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1f45","title":"[13] at least 3 beyond-parity capabilities are in production with operator-facing evidence and documentation","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: at least 3 beyond-parity capabilities are in production with operator-facing evidence and documentation\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:22.599223591Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:09.861607338Z","closed_at":"2026-02-20T07:39:59.286557726Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-1f45","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:09.861558778Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1fa","title":"[10.0] Top-10 #8: Deterministic per-extension resource budget subsystem (strategy: `9A.8`; deep semantics: `9F.10`; execution owners: `10.11`, `10.12`, `10.13`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #8: Deterministic per-extension resource budget subsystem (strategy: `9A.8`; deep semantics: `9F.10`; execution owners: `10.11`, `10.12`, `10.13`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:20.147994640Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:31.996613765Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"],"dependencies":[{"issue_id":"bd-1fa","depends_on_id":"bd-1of","type":"parent-child","created_at":"2026-02-20T07:43:31.031320937Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1fm","title":"[10.2] Define IFC flow-lattice semantics (`label classes`, `clearance classes`, `declassification obligations`) in `IR2`.","description":"## Plan Reference\nSection 10.2, item 4. Cross-refs: 9I.7 (Runtime IFC + Deterministic Exfiltration Prevention), 9F.4 (Capability-Typed TS Execution), 10.15 (IFC artifacts and flow-label inference).\n\n## What\nDefine Information Flow Control (IFC) flow-lattice semantics within IR2 (CapabilityIR). This enables the runtime to constrain how data moves between sensitive sources and external sinks, blocking exfiltration by construction.\n\n## Detailed Requirements\n- Define label classes: categories of sensitive data (credentials, config secrets, key material, privileged environment state, policy-protected host artifacts)\n- Define clearance classes: authorized data destinations (network egress, subprocess/IPC, export/persistence channels)\n- Define declassification obligations: explicit paths for authorized cross-label data flow\n- Flow lattice must be composable: labels combine via join/meet operations\n- Labels must be representable in IR2 nodes alongside capability annotations\n- Flow-lattice semantics must support both static analysis (compile-time) and dynamic enforcement (runtime)\n- Must integrate with PLAS (9I.5) for automatic flow envelope synthesis\n\n## Rationale\nSection 9I.7 states: 'Capability gating alone cannot express source-to-sink data constraints. IFC closes this structural gap and enables a stronger category claim: deterministic exfiltration resistance with machine-verifiable provenance.' This is a category-defining feature: extensions that legitimately need both fs.read and net.connect can still be prevented from exfiltrating sensitive data unless an explicitly audited declassification path exists.\n\n## Testing Requirements\n- Unit tests: label join/meet operations produce correct lattice results\n- Unit tests: verify label assignment to IR2 nodes\n- Unit tests: verify declassification obligation representation\n- Property tests: lattice operations satisfy algebraic properties (associativity, commutativity, idempotency)\n- Conformance: IFC corpus tests from Section 10.7 (dual-capability benign, exfil-attempt, declassification-exception workloads)\n\n## Implementation Notes\n- Define label types as enum with lattice trait implementation\n- Labels attach to IR2 nodes as metadata, not as separate pass\n- Clearance checks are defined here but enforced in the flow-check pass (bd-3jg) and at runtime (10.5)\n- Must be extensible for new label categories without breaking existing flows\n\n## Dependencies\n- Blocked by: IR contract (bd-1wa) for IR2 type design\n- Blocks: flow-check pass (bd-3jg), PLAS flow envelope synthesis (10.15), runtime flow-label propagation (10.5)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.803200833Z","created_by":"ubuntu","updated_at":"2026-02-20T07:48:20.636106523Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"],"dependencies":[{"issue_id":"bd-1fm","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:45:17.772062370Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1fu7","title":"[10.15] Implement portfolio governor scoring engine and stage-gate automation for moonshot lifecycle transitions.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement portfolio governor scoring engine and stage-gate automation for moonshot lifecycle transitions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:48.484503060Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:32.183320445Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-1fu7","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.032608169Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1fx","title":"[10.10] Implement same-sequence divergent-checkpoint fork detection and incident pathway.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement same-sequence divergent-checkpoint fork detection and incident pathway.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.116455726Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:32.276113035Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-1fx","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.694039525Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1g5c","title":"[10.15] Add slot-level promotion gate runner (equivalence, capability-preservation, performance threshold, adversarial survival) with deterministic pass/fail artifact bundles.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add slot-level promotion gate runner (equivalence, capability-preservation, performance threshold, adversarial survival) with deterministic pass/fail artifact bundles.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:54.232937676Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:32.366245390Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-1g5c","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.075130026Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1gcu","title":"[10.15] Add deterministic fallback policy: when attestation validation fails or expires, high-impact autonomous actions degrade to conservative safe mode.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add deterministic fallback policy: when attestation validation fails or expires, high-impact autonomous actions degrade to conservative safe mode.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.492074612Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:32.457736236Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-1gcu","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.117254063Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1h7n","title":"[13] franken_node composes those lanes for practical runtime usage","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: franken_node composes those lanes for practical runtime usage\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:19.216302677Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:09.905471426Z","closed_at":"2026-02-20T07:40:00.916776963Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-1h7n","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:09.905421082Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1hh4","title":"[10.15] Add frankensqlite-backed provenance index supporting deterministic source-to-sink lineage queries and replay joins.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankensqlite-backed provenance index supporting deterministic source-to-sink lineage queries and replay joins.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:53.723022386Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:32.549626064Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-1hh4","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.163120118Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1hu","title":"[10.5] Port extension lifecycle manager into compile-active modules.","description":"Plan Reference: section 10.5 (Extension Host + Security).\nObjective: Port extension lifecycle manager into compile-active modules.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.021147784Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:32.642672297Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"],"dependencies":[{"issue_id":"bd-1hu","depends_on_id":"bd-1yq","type":"parent-child","created_at":"2026-02-20T07:45:04.213150847Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1hw","title":"[10.5] Implement runtime flow-label propagation at dynamic hostcall boundaries and enforce sink-clearance checks.","description":"Plan Reference: section 10.5 (Extension Host + Security).\nObjective: Implement runtime flow-label propagation at dynamic hostcall boundaries and enforce sink-clearance checks.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.948569696Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:32.736732739Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"],"dependencies":[{"issue_id":"bd-1hw","depends_on_id":"bd-1yq","type":"parent-child","created_at":"2026-02-20T07:45:04.255863790Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1i2","title":"[10.11] Define canonical runtime capability profiles (`FullCaps`, `EngineCoreCaps`, `PolicyCaps`, `RemoteCaps`, `ComputeOnlyCaps`) and enforce them at API boundaries.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Define canonical runtime capability profiles (`FullCaps`, `EngineCoreCaps`, `PolicyCaps`, `RemoteCaps`, `ComputeOnlyCaps`) and enforce them at API boundaries.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:33.274990242Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:32.837082835Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-1i2","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.183965980Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1if","title":"[10.11] Implement saga orchestrator for multi-step publish/evict/quarantine workflows with deterministic compensation.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement saga orchestrator for multi-step publish/evict/quarantine workflows with deterministic compensation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.695088308Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:32.938986625Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-1if","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.226570932Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1ilz","title":"[10.15] Add frankensqlite-backed lineage/evidence index for replacement receipts and deterministic replay joins.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankensqlite-backed lineage/evidence index for replacement receipts and deterministic replay joins.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:54.922121006Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:33.033358487Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-1ilz","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.203490408Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1jak","title":"[15] Ecosystem Capture Strategy - Comprehensive Execution Epic","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nPurpose: Operationalize this section's governance/validation/adoption requirements into enforceable engineering work.\nQuality requirements for all children:\n- explicit acceptance criteria and failure semantics\n- unit-test and e2e/integration verification expectations\n- detailed structured logging and reproducibility artifacts where applicable\n- traceability back to category-level goals (security, performance, explainability, adoption)","status":"closed","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:15.651360044Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:28.073814959Z","closed_at":"2026-02-20T07:45:28.073792137Z","close_reason":"Replaced by consolidated ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-15"],"dependencies":[{"issue_id":"bd-1jak","depends_on_id":"bd-1tsf","type":"blocks","created_at":"2026-02-20T07:34:38.106582763Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1jak","depends_on_id":"bd-21ds","type":"blocks","created_at":"2026-02-20T07:34:38.692410684Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1jak","depends_on_id":"bd-395m","type":"blocks","created_at":"2026-02-20T07:34:38.595172120Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1jak","depends_on_id":"bd-3t2d","type":"parent-child","created_at":"2026-02-20T07:45:15.023839783Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1jqt","title":"[10.15] Add frankentui operator surfaces for proof-specialization lineage (`proof ids`, `activated specializations`, `invalidations`, `fallback events`).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankentui operator surfaces for proof-specialization lineage (`proof ids`, `activated specializations`, `invalidations`, `fallback events`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:53.209298162Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:33.129669370Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-1jqt","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.246134804Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1k5f","title":"[13] proof-carrying optimization path is enabled by default for at least one high-impact optimization family","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: proof-carrying optimization path is enabled by default for at least one high-impact optimization family\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:23.232379459Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:09.949304846Z","closed_at":"2026-02-20T07:39:58.984722894Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-1k5f","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:09.949247409Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1k7","title":"[10.2] Implement closure and lexical scope model.","description":"Plan Reference: section 10.2 (VM Core).\nObjective: Implement closure and lexical scope model.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.711931209Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:33.224038957Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"],"dependencies":[{"issue_id":"bd-1k7","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:45:17.983473956Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1kd2","title":"[13] control-plane identifiers and capability context are canonicalized through asupersync-derived types (no competing local forks)","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: control-plane identifiers and capability context are canonicalized through asupersync-derived types (no competing local forks)\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:21.084427599Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:09.993395455Z","closed_at":"2026-02-20T07:40:00.000271547Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-1kd2","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:09.993345993Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1kdc","title":"[10.15] Implement deterministic shadow ablation engine that tests capability subtraction candidates against correctness and risk invariants.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement deterministic shadow ablation engine that tests capability subtraction candidates against correctness and risk invariants.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:50.135558141Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:33.315376036Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-1kdc","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.288119621Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1ko5","title":"[13] 100% of capability escrow/emergency-grant decisions emit receipt-linked replay artifacts with explicit expiry and operator rationale","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: 100% of capability escrow/emergency-grant decisions emit receipt-linked replay artifacts with explicit expiry and operator rationale\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:25.695732732Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.034995946Z","closed_at":"2026-02-20T07:39:57.888748945Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-1ko5","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.034947055Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1kzo","title":"[10.15] Add compiler policy that only proof-grounded specializations may bypass capability/flow dynamic checks in marked regions.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add compiler policy that only proof-grounded specializations may bypass capability/flow dynamic checks in marked regions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:53.032092674Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:33.407164727Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-1kzo","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.333242903Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1lp","title":"[10.10] Implement append-only hash-linked audit chain with `correlation_id` and optional full trace context.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement append-only hash-linked audit chain with `correlation_id` and optional full trace context.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.404729302Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:33.496423185Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-1lp","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.736996193Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1m9","title":"[10.2] Implement complete ES2020 object/prototype semantics (no permanent subset scope).","description":"Plan Reference: section 10.2 (VM Core).\nObjective: Implement complete ES2020 object/prototype semantics (no permanent subset scope).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.582533523Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:33.587262978Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"],"dependencies":[{"issue_id":"bd-1m9","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:45:18.026872567Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1md2","title":"[12] Prevent unsound specialization from stale proofs via epoch validity and fail-closed invalidation","description":"Plan Reference: section 12 (Risk Register).\nObjective: Stale/invalid security proofs causing unsound specialization:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:18.794629093Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:08.931223292Z","closed_at":"2026-02-20T07:39:04.430895137Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"],"dependencies":[{"issue_id":"bd-1md2","depends_on_id":"bd-2rbm","type":"parent-child","created_at":"2026-02-20T07:45:08.931178459Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1n78","title":"[10.15] Define advanced conformance-lab contract catalog (semantic version classes, failure taxonomy, replay obligations) extending `10.14` baseline boundary tests.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define advanced conformance-lab contract catalog (semantic version classes, failure taxonomy, replay obligations) extending `10.14` baseline boundary tests.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:48.809108898Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:33.684772894Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-1n78","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.374718943Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1nh","title":"[10.12] Build deterministic causal replay engine with counterfactual branching over policy/action parameters.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Build deterministic causal replay engine with counterfactual branching over policy/action parameters.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.177747192Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:33.776542539Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-1nh","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:07.856642629Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1nn","title":"[10.6] Add flamegraph pipeline and artifact storage.","description":"Plan Reference: section 10.6 (Performance Program).\nObjective: Add flamegraph pipeline and artifact storage.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:25.482572624Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:33.870824052Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-6"],"dependencies":[{"issue_id":"bd-1nn","depends_on_id":"bd-12m","type":"parent-child","created_at":"2026-02-20T07:43:29.754151291Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1npj","title":"[14] A public `>= 3x` claim is valid only if:","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: A public `>= 3x` claim is valid only if:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:30.918588910Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:04.761835735Z","closed_at":"2026-02-20T07:41:20.617789294Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-1npj","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:04.761794638Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1o2","title":"[10.12] Implement security-proof ingestion path for optimizer hypotheses (PLAS witnesses, IFC flow proofs, replay sequence motifs).","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement security-proof ingestion path for optimizer hypotheses (PLAS witnesses, IFC flow proofs, replay sequence motifs).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:38.537631360Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:33.962383265Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-1o2","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:07.901044919Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1o7u","title":"[10.13] Integrate `frankenlab` scenarios for extension lifecycle and containment paths (startup, normal shutdown, forced cancel, quarantine, revocation, degraded mode).","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Integrate `frankenlab` scenarios for extension lifecycle and containment paths (startup, normal shutdown, forced cancel, quarantine, revocation, degraded mode).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:43.435115096Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:34.055954385Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-1o7u","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:11.735263796Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1of","title":"[10.0] Top 10 Initiative Tracking (Canonical Implementation Index) - Comprehensive Execution Epic","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.172859330Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:42.187487731Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-0"],"dependencies":[{"issue_id":"bd-1of","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.100359117Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1of","depends_on_id":"bd-3vh","type":"blocks","created_at":"2026-02-20T07:32:55.259844237Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1ovk","title":"[10.15] Define IFC artifacts (`flow_policy`, `flow_proof`, `declassification_receipt`, `confinement_claim`) with deterministic encoding and signature requirements.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define IFC artifacts (`flow_policy`, `flow_proof`, `declassification_receipt`, `confinement_claim`) with deterministic encoding and signature requirements.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:52.166154216Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:34.149373993Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-1ovk","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.438077919Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1p4","title":"[10.10] Add activation/update/rollback contract: sandbox setup, ephemeral secret injection, staged rollout, crash-loop auto-rollback, known-good pinning.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Add activation/update/rollback contract: sandbox setup, ephemeral secret injection, staged rollout, crash-loop auto-rollback, known-good pinning.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.979638185Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:34.241110447Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-1p4","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.779412984Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1pqn","title":"[14] Each case must publish: throughput, `p50/p95/p99` latency, allocation/peak memory, correctness digest, and security-event envelope.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Each case must publish: throughput, `p50/p95/p99` latency, allocation/peak memory, correctness digest, and security-event envelope.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:29.214797229Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:04.807849305Z","closed_at":"2026-02-20T07:41:21.324671499Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-1pqn","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:04.807805173Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1ps3","title":"[10.14] Inventory every current/planned local persistence need (replay index, evidence index, benchmark ledger, policy artifact cache) and map each to a `frankensqlite` integration point.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Inventory every current/planned local persistence need (replay index, evidence index, benchmark ledger, policy artifact cache) and map each to a `frankensqlite` integration point.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:45.381757842Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:34.328566096Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-1ps3","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:18.579598534Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1qgn","title":"[10.14] Add CI/policy guard preventing new local interactive TUI frameworks in `franken_engine` without explicit ADR exception.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add CI/policy guard preventing new local interactive TUI frameworks in `franken_engine` without explicit ADR exception.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:45.058058734Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:34.419735874Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-1qgn","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:18.622306207Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1qj6","title":"[13] GA default lanes run with zero mandatory delegate cells for core runtime slots","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: GA default lanes run with zero mandatory delegate cells for core runtime slots\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:27.343725828Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.079019630Z","closed_at":"2026-02-20T07:39:57.192430577Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-1qj6","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.078962875Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1r25","title":"[10.15] Extend receipt schema to include attestation bindings (`quote_digest`, `measurement_id`, `attested_signer_key_id`, `nonce`, `validity_window`).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Extend receipt schema to include attestation bindings (`quote_digest`, `measurement_id`, `attested_signer_key_id`, `nonce`, `validity_window`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.170176448Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:34.511399031Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-1r25","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.480943517Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1rdj","title":"[10.13] Add benchmark split showing control-plane overhead remains bounded while VM hot-loop performance remains decoupled.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add benchmark split showing control-plane overhead remains bounded while VM hot-loop performance remains decoupled.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:44.251207526Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:34.600064464Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-1rdj","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:11.778159920Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1rju","title":"[13] privacy-preserving fleet learning operates continuously with zero budget-overrun incidents and measurable calibration/drift-improvement over local-only baselines","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: privacy-preserving fleet learning operates continuously with zero budget-overrun incidents and measurable calibration/drift-improvement over local-only baselines\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:24.095118828Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.120822298Z","closed_at":"2026-02-20T07:39:58.585156720Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-1rju","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.120769590Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1si","title":"[10.11] Implement `PolicyController` service for non-correctness knobs with explicit action sets and loss matrices.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement `PolicyController` service for non-correctness knobs with explicit action sets and loss matrices.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.080674328Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:34.697567157Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-1si","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.272152858Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1to","title":"[10.0] Top-10 #3: Deterministic evidence graph + replay tooling (strategy: `9A.3`; deep semantics: `9F.3`; execution owners: `10.5`, `10.11`, `10.12`, `10.13`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #3: Deterministic evidence graph + replay tooling (strategy: `9A.3`; deep semantics: `9F.3`; execution owners: `10.5`, `10.11`, `10.12`, `10.13`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:19.488373355Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:34.789601415Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"],"dependencies":[{"issue_id":"bd-1to","depends_on_id":"bd-1of","type":"parent-child","created_at":"2026-02-20T07:43:31.111883793Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1tsf","title":"[MASTER] Execute PLAN 10.x end-to-end with full dependency graph","description":"Master orchestration epic for the full program-level TODO decomposition.\nThis bead represents complete execution of sections 10.0-10.15 with explicit dependency graphing, quality gates, and verification obligations.\nProgram invariants:\n- Preserve ambition-first doctrine and category-defining capability goals.\n- No scope collapse, no hidden compatibility shims, no proof-free claims.\n- Every stream must include unit tests, e2e/integration tests, and high-fidelity logging.\n- Every high-impact capability must carry reproducible/evidence-backed outputs.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":2,"issue_type":"epic","created_at":"2026-02-20T07:32:58.319192260Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:50.778309422Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["master","plan","section-10"],"dependencies":[{"issue_id":"bd-1tsf","depends_on_id":"bd-3t2d","type":"parent-child","created_at":"2026-02-20T07:45:15.068836239Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1tw4","title":"[13] cross-repo conformance lab pass rate is a hard release gate for shared-boundary changes, with deterministic repro artifacts for every failure class","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: cross-repo conformance lab pass rate is a hard release gate for shared-boundary changes, with deterministic repro artifacts for every failure class\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:24.533929503Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.168701563Z","closed_at":"2026-02-20T07:39:58.383051082Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-1tw4","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.168649567Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1ukb","title":"[10.13] Integrate region-per-extension/session execution cells with quiescent close guarantees using primitives owned by `10.11`.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Integrate region-per-extension/session execution cells with quiescent close guarantees using primitives owned by `10.11`.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:42.479483918Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:34.881032349Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-1ukb","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:11.820080337Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1v5","title":"[10.11] Implement epoch transition barrier across core services to prevent mixed-epoch critical operations.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement epoch transition barrier across core services to prevent mixed-epoch critical operations.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.963158175Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:34.992461260Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-1v5","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.315829066Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1v90","title":"[10.15] Extend PLAS synthesis to emit minimal flow envelopes in addition to capability envelopes.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Extend PLAS synthesis to emit minimal flow envelopes in addition to capability envelopes.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:52.675050458Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:35.080880174Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-1v90","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.526058053Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1wa","title":"[10.2] Define multi-level IR contract (`IR0`/`IR1`/`IR2`/`IR3`/`IR4`) including canonical serialization/hash invariants.","description":"## Plan Reference\nSection 10.2, item 2. Cross-refs: 9A.1, 9B.1 (typestate/session types/algebraic effects), 9C.1 (proof-carrying compilation), 9F.4 (capability-typed TS execution), 9I.7 (IFC flow labels in IR2), 9I.8 (proof-to-specialization linkage in IR3/IR4).\n\n## What\nDefine the complete multi-level Intermediate Representation contract spanning five levels:\n- **IR0 (SyntaxIR)**: Direct AST output from parser, structurally canonical\n- **IR1 (SpecIR)**: Spec-level semantic representation, scope/binding resolved\n- **IR2 (CapabilityIR)**: Annotated with capability intent, effect boundaries, and IFC flow labels\n- **IR3 (ExecIR)**: Execution-ready form with proof-to-specialization linkage\n- **IR4 (WitnessIR)**: Post-execution witness artifacts for replay and audit\n\nEach level must define canonical serialization format and hash computation for deterministic replay and evidence linkage.\n\n## Detailed Requirements\n- Each IR level must have a defined Rust type hierarchy with serde support\n- Canonical serialization: deterministic byte output for identical semantic content (field ordering, normalization rules)\n- Hash invariants: content-addressed hashing at each level for evidence graph linkage\n- IR2 must carry: capability annotations per Section 9F.4, IFC flow labels per Section 9I.7 (label classes, clearance classes, declassification obligations)\n- IR3 must carry: proof-to-specialization linkage per Section 9I.8 (proof_input_ids, optimization_class, validity_epoch, rollback_token)\n- IR4 must carry: execution witness data for replay determinism and forensic audit\n- Version schema for IR formats to support migration (per Section 9E.10)\n\n## Rationale\nThe IR stack is the architectural spine of FrankenEngine. The plan explicitly requires that capability intent, effect boundaries, and host interaction metadata flow through compilation (9A.1). The proof-carrying compilation contract (9C.1) requires each lowering stage to emit invariants and machine-checkable witnesses. Without canonical serialization/hash invariants, evidence graph linkage (9A.3) and deterministic replay (9F.3) are impossible.\n\n## Testing Requirements\n- Unit tests: construct IR at each level, verify canonical serialization produces deterministic bytes\n- Unit tests: verify hash computation is stable across identical IR instances\n- Unit tests: verify IR2 capability annotations are preserved through serialization round-trip\n- Unit tests: verify IR3 proof linkage fields are present and correctly typed\n- Property tests: IR serialization round-trip preserves all semantic content\n- Migration tests: versioned IR can be deserialized by both current and next version\n\n## Implementation Notes\n- Define in crates/franken-engine as core IR types module\n- Use serde with deterministic field ordering (BTreeMap not HashMap for any map fields)\n- Consider content-addressed storage design from the start\n- IR0IR1IR2IR3 forms a lowering pipeline; IR4 is emitted post-execution\n- Each level should have a From/TryFrom relationship to the next lower level\n\n## Dependencies\n- Blocked by: parser trait (bd-crp) for IR0 design\n- Blocks: lowering pipelines (bd-ug9), IFC flow-lattice (bd-1fm), proof-to-specialization linkage (bd-161), flow-check pass (bd-3jg)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.542756438Z","created_by":"ubuntu","updated_at":"2026-02-20T07:48:05.196343414Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"],"dependencies":[{"issue_id":"bd-1wa","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:45:18.069760906Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1wqa","title":"[15] Partner program for early lighthouse adopters who validate category-shift outcomes in production.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Partner program for early lighthouse adopters who validate category-shift outcomes in production.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:35.214302597Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:44.082275799Z","closed_at":"2026-02-20T07:45:44.082252545Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"],"dependencies":[{"issue_id":"bd-1wqa","depends_on_id":"bd-1jak","type":"parent-child","created_at":"2026-02-20T07:43:30.261199044Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1xm","title":"[10.9] Moonshot Disruption Track - Comprehensive Execution Epic","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.753842457Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:42.431611619Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-9"],"dependencies":[{"issue_id":"bd-1xm","depends_on_id":"bd-12m","type":"blocks","created_at":"2026-02-20T07:32:56.483603902Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.146862750Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-2r6","type":"blocks","created_at":"2026-02-20T07:32:56.660166432Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-383","type":"blocks","created_at":"2026-02-20T07:32:56.573703198Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xm","depends_on_id":"bd-3q9","type":"blocks","created_at":"2026-02-20T07:32:56.746329536Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1xva","title":"[14] Maintain a neutral verifier mode so third parties can run and validate claims.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Maintain a neutral verifier mode so third parties can run and validate claims.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:28.276857375Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:04.853966509Z","closed_at":"2026-02-20T07:41:21.720302844Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-1xva","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:04.853925412Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1y5","title":"[10.5] Implement expected-loss action selector.","description":"Plan Reference: section 10.5 (Extension Host + Security).\nObjective: Implement expected-loss action selector.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.415330701Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:35.266960386Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"],"dependencies":[{"issue_id":"bd-1y5","depends_on_id":"bd-1yq","type":"parent-child","created_at":"2026-02-20T07:45:04.294968402Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1y63","title":"[14] Revocation/quarantine propagation (freshness lag distribution, convergence SLO attainment).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Revocation/quarantine propagation (freshness lag distribution, convergence SLO attainment).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:33.570962678Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:04.893582805Z","closed_at":"2026-02-20T07:41:19.476657150Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-1y63","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:04.893540406Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1yq","title":"[10.5] Extension Host + Security - Comprehensive Execution Epic","description":"Plan Reference: section 10.5 (Extension Host + Security).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-02-20T07:32:18.494764838Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:50.389705855Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-5"],"dependencies":[{"issue_id":"bd-1yq","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.192576983Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-3ch","type":"blocks","created_at":"2026-02-20T07:32:55.781092336Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-3vh","type":"blocks","created_at":"2026-02-20T07:32:55.608087994Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1yq","depends_on_id":"bd-ntq","type":"blocks","created_at":"2026-02-20T07:32:55.695053523Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1za","title":"[10.11] Add compile-time ambient-authority audit gate for forbidden direct calls in engine security-critical modules.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add compile-time ambient-authority audit gate for forbidden direct calls in engine security-critical modules.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:33.438713877Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:35.357836808Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-1za","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.359113233Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1ze","title":"[10.9] Release gate: official Node/Bun comparison harness is delivered with reproducible benchmark artifacts and publishable methodology (implementation ownership: `10.12` + section `14`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: official Node/Bun comparison harness is delivered with reproducible benchmark artifacts and publishable methodology (implementation ownership: `10.12` + section `14`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:27.698421336Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:35.449884310Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"],"dependencies":[{"issue_id":"bd-1ze","depends_on_id":"bd-1xm","type":"parent-child","created_at":"2026-02-20T07:45:03.819395936Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2031","title":"[13] fleet quarantine convergence meets published SLOs under partition/fault injection drills","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: fleet quarantine convergence meets published SLOs under partition/fault injection drills\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:23.024374212Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.212160416Z","closed_at":"2026-02-20T07:39:59.083570947Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-2031","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.212110553Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-20b","title":"[10.2] Define typed execution-slot registry and ABI contract for slot replacement (`slot_id`, semantic boundary, authority envelope, promotion status).","description":"## Plan Reference\nSection 10.2, item 7. Cross-refs: 9I.6 (Verified Self-Replacement Architecture), 10.15 (self-replacement schema, delegate-cell harness, promotion gates).\n\n## What\nDefine the typed execution-slot registry that enables the Verified Self-Replacement Architecture. Each slot is a replaceable runtime component that can run either native Rust cells or explicitly untrusted delegate cells.\n\n## Detailed Requirements\n- Define slot_id: unique identifier for each replaceable runtime component\n- Define semantic boundary: what each slot does (parser, IR lowering, optimizer, interpreter, hostcall dispatch, etc.)\n- Define authority envelope: what capabilities each slot requires and is permitted\n- Define promotion status: current state (delegate/native, promotion candidate, promoted, demoted)\n- ABI contract: deterministic interface between slot and runtime, so swapping implementations is seamless\n- Registry must track: current implementation digest, promotion lineage, rollback targets\n\n## Rationale\nSection 9I.6: 'Build the runtime as typed execution slots that can run either native Rust cells or explicitly untrusted delegate cells, then continuously replace delegates with native cells via cryptographically signed promotion gates until GA lanes are fully native.' This converts the hardest part of the program (full ES2020-native execution) into an incremental, evidence-backed convergence process. The slot registry is the foundation that makes this possible.\n\n## Testing Requirements\n- Unit tests: register slots, verify slot_id uniqueness\n- Unit tests: verify ABI contract compatibility between native and delegate implementations\n- Unit tests: verify promotion status transitions (delegate  candidate  promoted)\n- Unit tests: verify rollback from promoted back to previous implementation\n- Integration tests: swap slot implementation at runtime, verify behavior preservation\n\n## Dependencies\n- Blocked by: nothing (foundational design)\n- Blocks: interpreter skeleton (bd-2f8), delegate-cell harness (10.15), promotion gate runner (10.15)","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.203314107Z","created_by":"ubuntu","updated_at":"2026-02-20T07:48:25.609715766Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"],"dependencies":[{"issue_id":"bd-20b","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:45:18.116630201Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-20c","title":"[10.0] Top-10 #1: TS-first capability-typed IR execution (strategy: `9A.1`; deep semantics: `9F.4`; execution owners: `10.2`, `10.5`, `10.12`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #1: TS-first capability-typed IR execution (strategy: `9A.1`; deep semantics: `9F.4`; execution owners: `10.2`, `10.5`, `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:19.238167621Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:35.627342624Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"],"dependencies":[{"issue_id":"bd-20c","depends_on_id":"bd-1of","type":"parent-child","created_at":"2026-02-20T07:43:31.194470949Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-20xc","title":"Build benchmark reproducibility infrastructure and third-party verification pipeline","description":"## Plan Reference\nSection 14.3: Reproducibility + Neutral Verification\nSection 13: At least 2 independent third parties reproduce core benchmark claims\n\n## What\nBuild the infrastructure that enables external parties to independently verify benchmark claims. This includes manifest generation, artifact packaging, verification tooling, and publication workflow.\n\n## Components\n1. **Full run manifest generator**: Captures hardware, kernel, runtime versions, flags, dataset checksums, seed transcripts, harness commit IDs\n2. **Artifact packaging**: Creates self-contained verification bundles that can be shared externally\n3. **Verification pipeline**: Automated comparison of reproduced results against published claims\n4. **Publication workflow**: Gated pipeline requiring all prerequisites before claim can be published externally\n5. **frankensqlite integration**: Store result ledgers with versioned schemas\n6. **frankentui dashboards**: Operator triage and replay dashboards for benchmark results\n\n## Verification Requirements\n- Publish native-coverage progression alongside benchmark releases\n- Per-slot replacement lineage IDs tied to concrete replacement state\n- Version-stamped benchmark specification with migration notes for spec changes\n- Include both performance AND security co-metrics (not speed-only)\n\n## Testing Requirements\n- E2E test: generate manifest, package artifacts, run verification, confirm match\n- Test: tampered artifacts are detected by verification pipeline\n- Test: spec version mismatch is detected and reported\n- Test: incomplete manifests are rejected with clear error messages\n\n## Rationale\nCategory leadership requires defining the scoreboard (Section 14 preamble). External adoption requires trust, which requires rock-solid reproducibility.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:42:27.934805899Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:35.718679743Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["benchmark","reproducibility","verification"]}
{"id":"bd-21ds","title":"[14] Public Benchmark + Standardization Strategy - Comprehensive Execution Epic","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nPurpose: Operationalize this section's governance/validation/adoption requirements into enforceable engineering work.\nQuality requirements for all children:\n- explicit acceptance criteria and failure semantics\n- unit-test and e2e/integration verification expectations\n- detailed structured logging and reproducibility artifacts where applicable\n- traceability back to category-level goals (security, performance, explainability, adoption)\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:15.545871282Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:42.660672322Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-14"],"dependencies":[{"issue_id":"bd-21ds","depends_on_id":"bd-1tsf","type":"blocks","created_at":"2026-02-20T07:34:38.009455236Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-3t2d","type":"parent-child","created_at":"2026-02-20T07:45:15.110708677Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-21ds","depends_on_id":"bd-c1co","type":"blocks","created_at":"2026-02-20T07:34:38.497452660Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-21ul","title":"Maintain program risk register with active countermeasures and review cadence","description":"## Plan Reference\nSection 12: Risk Register\n\n## What\nMaintain a living risk register document tracking program-level risks with active countermeasures. This is a monitoring/governance artifact, not a one-time implementation task.\n\n## Identified Risks and Countermeasures\n\n### 1. Scope explosion\n- **Countermeasure**: Strict phase gates (A/B/C/D/E) and one-lever optimization discipline from Section 5.1\n- **Monitor**: Track scope additions vs. phase gate progress monthly\n\n### 2. False confidence from heuristic security\n- **Countermeasure**: Bayesian + sequential testing (e-process) + calibration audits (Section 6.4-6.5)\n- **Monitor**: Track calibration metrics, false-positive/negative rates on adversarial corpora\n\n### 3. Performance regressions from over-hardening\n- **Countermeasure**: Profile-driven optimization and tail-latency budgets (Section 7)\n- **Monitor**: p95/p99 regression CI gates, overhead budget per security subsystem\n\n### 4. Operational complexity\n- **Countermeasure**: Evidence-ledger tooling and deterministic fallback mode (Section 8.6)\n- **Monitor**: Operator burden metrics, fallback activation frequency\n\n### 5. Delegate-path entrenchment (temporary bridge becomes permanent)\n- **Countermeasure**: Hard GA 0-delegate gate for core slots (Section 8.8), signed replacement-lineage requirements, explicit closure obligations with ownership\n- **Monitor**: Native coverage percentage, time-since-last-promotion per slot\n\n### 6. IFC policy over-constraint causing false denies on benign integrations\n- **Countermeasure**: Static-first analysis, shadow-mode rollout, explicit declassification workflows, profile-guided label-granularity tuning (Section 6.9)\n- **Monitor**: False-deny rates on benign extension corpora, declassification request volume\n\n### 7. Stale/invalid security proofs causing unsound specialization\n- **Countermeasure**: Epoch-bound proof validity (Section 8.9), mandatory specialization invalidation on proof churn, fail-closed fallback to unspecialized paths\n- **Monitor**: Proof invalidation rate, specialization fallback frequency\n\n## Review Cadence\n- Weekly: check risk indicators against thresholds\n- Per-phase-gate: full risk register review with updated status\n- Per-incident: add new risks discovered during incidents\n\n## Testing Requirements\n- Validate risk register schema (all risks have countermeasure, monitor, owner)\n- CI check that risk register is updated when phase gates are crossed\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:39:24.951932623Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:35.811887477Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["governance","risk"]}
{"id":"bd-23br","title":"[14] Scale profiles per family (each required): `S`, `M`, `L` with fixed extension counts, event rates, dependency graph sizes, and policy complexity tiers.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Scale profiles per family (each required): `S`, `M`, `L` with fixed extension counts, event rates, dependency graph sizes, and policy complexity tiers.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:28.977678111Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:04.923753377Z","closed_at":"2026-02-20T07:41:21.424004164Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-23br","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:04.923710999Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-23om","title":"[10.13] Introduce a narrow control-plane adapter layer in `franken_engine` that imports `franken-kernel`/`franken_kernel`, `franken-decision`/`franken_decision`, and `franken-evidence`/`franken_evidence` without pulling broad runtime internals into VM hot paths.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Introduce a narrow control-plane adapter layer in `franken_engine` that imports `franken-kernel`/`franken_kernel`, `franken-decision`/`franken_decision`, and `franken-evidence`/`franken_evidence` without pulling broad runtime internals into VM hot paths.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:42.140285490Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:35.904796764Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-23om","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:11.862698754Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-24bu","title":"[10.13] Make `frankenlab replay` and deterministic scenario pass/fail outputs release blockers for security-critical paths.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Make `frankenlab replay` and deterministic scenario pass/fail outputs release blockers for security-critical paths.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:43.592729712Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:35.999011724Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-24bu","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:11.903950015Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-24ie","title":"[10.15] Add burn-in gate: no auto-enforcement promotion without shadow success rate, false-deny envelope, and rollback proof artifacts meeting threshold.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add burn-in gate: no auto-enforcement promotion without shadow success rate, false-deny envelope, and rollback proof artifacts meeting threshold.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:51.833560760Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:36.091836464Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-24ie","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.568476388Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-24rp","title":"[14] Publish native-coverage progression and per-slot replacement lineage IDs alongside benchmark releases so performance claims are tied to concrete replacement state.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Publish native-coverage progression and per-slot replacement lineage IDs alongside benchmark releases so performance claims are tied to concrete replacement state.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:32.602455317Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.080812100Z","closed_at":"2026-02-20T07:41:19.881879549Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-24rp","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.080773528Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2501","title":"Deliver scientific contribution targets and publishable research artifacts","description":"## Plan Reference\nSection 16: Scientific Contribution Targets\n\n## What\nFrankenEngine is also a research-producing engineering program. Each major novelty should produce reusable scientific/technical artifacts. This bead tracks all scientific contribution obligations.\n\n## Required Contributions\n1. **Open specifications**: Core trust/replay/policy primitives published as open specs for community adoption\n2. **Reproducible datasets**: Incident replay and adversarial campaign evaluation datasets with deterministic reproduction guarantees\n3. **Reference proofs**: Proof sketches or formal proofs for key policy and protocol safety claims (e.g., IFC confinement, capability monotonicity, revocation precedence)\n4. **External evaluations**: Red-team and academic-style evaluations with published methodology, not just internal validation\n5. **Technical reports**: Public reports documenting failures, fixes, and measured frontier movement (not just successes)\n\n## Output Contract (Hard Requirements)\n- At least 4 publishable technical reports with reproducible artifact bundles\n- At least 2 externally replicated high-impact claims (e.g., 3x performance, containment latency SLOs)\n- At least 1 open benchmark or verification tool release adopted outside the project\n\n## Rationale\nFrom the plan: 'FrankenEngine is also a research-producing engineering program.' This means the project must contribute to the broader security/runtime research community, not just ship product. External validation through independent replication and academic evaluation strengthens category claims and builds credibility. Public failure documentation demonstrates intellectual honesty and builds trust.\n\n## Dependencies\n- Requires benchmark suite (10.6, Section 14) for replicable performance claims\n- Requires adversarial corpus (10.7, 10.12) for reproducible security datasets\n- Requires IFC/PLAS proofs (10.15) for formal safety claim artifacts\n- Requires decision receipt infrastructure (10.12) for trust/replay specification publication\n\n## Testing Requirements\n- Validation that each technical report artifact bundle is self-contained and reproducible (run on clean environment)\n- Test that open specifications pass conformance vector suites from Section 10.10\n- Test that reproducible datasets produce deterministic outputs when replayed\n- Verification that external evaluation methodology documents include complete reproduction instructions\n\n## Implementation Notes\n- Technical reports should follow alien-artifact-coding discipline (Section 5.2): every claim ships with proof artifacts\n- Reports should cover both successes AND failures per plan requirement\n- External evaluations should be coordinated with the partner program from Section 15\n- Open benchmark tools should be packaged for independent installation and execution\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:47:20.310689800Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:36.186513133Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["artifacts","publications","research","scientific"]}
{"id":"bd-256n","title":"[12] Prevent delegate-path entrenchment with GA zero-delegate gate and signed replacement-lineage obligations","description":"Plan Reference: section 12 (Risk Register).\nObjective: Delegate-path entrenchment (temporary bridge becomes permanent):\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:18.382010256Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:08.973604848Z","closed_at":"2026-02-20T07:39:04.634752198Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"],"dependencies":[{"issue_id":"bd-256n","depends_on_id":"bd-2rbm","type":"parent-child","created_at":"2026-02-20T07:45:08.973557159Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-25b7","title":"[10.15] Publish PLAS benchmark bundle reporting over-privilege ratio, policy authoring-time reduction, false-deny rates, and escrow-event rates across representative extension cohorts.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Publish PLAS benchmark bundle reporting over-privilege ratio, policy authoring-time reduction, false-deny rates, and escrow-event rates across representative extension cohorts.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:51.999575373Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:36.284584906Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-25b7","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.611370067Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-25sh","title":"Track and validate program success criteria (Section 13 acceptance gates)","description":"## Plan Reference\nSection 13: Program Success Criteria\n\n## Purpose\nThis epic tracks ALL program-level success criteria from the plan. These are NOT implementation tasks - they are acceptance gates that must be satisfied by the implementation beads in sections 10.x. Each criterion should be linked to the implementation bead(s) that satisfy it.\n\n## Success Criteria Checklist\n\n### Core Runtime\n- [ ] Native execution lanes run without external engine bindings (10.2)\n- [ ] franken_node composes those lanes for practical runtime usage (Phase D)\n- [ ] ES2020 runtime conformance is demonstrably complete per test262 gate and waiver policy (10.7)\n\n### Security\n- [ ] Untrusted extension code is actively monitored and auto-contained under attack scenarios (10.5)\n- [ ] Red-team programs show >= 10x reduction in successful host compromise vs baseline Node/Bun (Phase B gate)\n- [ ] High-risk detections reach containment in <= 250ms median time (Phase B gate)\n- [ ] Unauthorized sensitive-source -> external-sink flows are deterministically blocked unless explicit declassification approved (10.15/IFC)\n- [ ] >= 99% of declassification decisions emit signed receipt-linked replay artifacts (10.15)\n- [ ] Data-confinement claims are machine-verifiable from evidence/provenance artifacts (10.15)\n\n### Determinism & Replay\n- [ ] Deterministic replay coverage is 100% for high-severity decisions (10.5, 10.11, 10.13)\n- [ ] All high-impact safety actions executed through decision contracts and emitted through canonical evidence ledgers (10.13)\n- [ ] Extension lifecycle transitions satisfy request -> drain -> finalize protocol invariants (10.11, 10.13)\n- [ ] Release gates include deterministic frankenlab scenario replay (10.13)\n\n### Performance\n- [ ] Extension-heavy benchmark suites show >= 3x weighted-geometric-mean throughput vs Node AND Bun (Section 14 denominator)\n- [ ] Security and performance claims are artifact-backed and reproducible (10.6, 10.8)\n- [ ] Proof-carrying optimization path enabled by default for >= 1 high-impact family (10.12)\n- [ ] Proof-specialized lanes show measurable improvement vs ambient-authority lanes (10.15)\n- [ ] 100% of activated proof-specializations carry signed receipts (10.15)\n\n### Control Plane & Integration\n- [ ] Control-plane identifiers canonicalized through asupersync-derived types (10.13)\n- [ ] All advanced operator TUI surfaces delivered through frankentui (10.14)\n- [ ] All SQLite-backed persistence delivered through frankensqlite (10.14)\n- [ ] Service/API surfaces leverage fastapi_rust where applicable (10.14)\n- [ ] Cross-repo conformance lab is a hard release gate (10.15)\n\n### Fleet & Ecosystem\n- [ ] Fleet quarantine convergence meets published SLOs under fault injection (10.12)\n- [ ] Secure extension reputation graph drives measurable reduction in first-time compromise windows (10.12)\n- [ ] At least 3 beyond-parity capabilities in production with evidence (Phase D)\n- [ ] At least 2 independent third parties reproduce core benchmark claims (Section 14)\n- [ ] Category benchmark standard adopted by external participants (Section 14)\n\n### Governance & Trust\n- [ ] >= 95% of high-impact decision receipts include valid attestation bindings (10.15)\n- [ ] Privacy-preserving fleet learning operates with zero budget-overrun incidents (10.15)\n- [ ] Moonshot portfolio governor enforces promote/hold/kill gates with 100% artifact completeness (10.15)\n- [ ] PLAS produces signed capability_witness for >= 90% of targeted extension cohorts (10.15)\n- [ ] Synthesized capability envelopes achieve <= 1.10 over-privilege ratio (10.15)\n- [ ] Manual policy-authoring time reduced by >= 70% (10.15)\n- [ ] Post-burn-in false-deny rate <= 0.5% on benign corpora (10.15)\n- [ ] 100% of capability escrow/emergency-grant decisions emit receipt-linked replay artifacts (10.15)\n- [ ] Every promoted delegate->native core slot has signed replacement receipt (10.15)\n- [ ] GA default lanes run with zero mandatory delegate cells (10.15)\n\n## Validation Process\nEach criterion gets checked off only when:\n1. The implementing bead(s) are complete\n2. Evidence artifacts exist proving the criterion\n3. Independent validation has been performed where specified","status":"open","priority":1,"issue_type":"epic","created_at":"2026-02-20T07:41:05.696299100Z","created_by":"ubuntu","updated_at":"2026-02-20T07:41:05.696299100Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["acceptance","governance","release-gate"]}
{"id":"bd-26f","title":"[10.10] Define revocation object chain (`revocation`, `revocation_event`, `revocation_head`) with monotonic head sequence.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Define revocation object chain (`revocation`, `revocation_event`, `revocation_head`) with monotonic head sequence.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.382960973Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:36.373216046Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-26f","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.821720863Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-26i","title":"[10.11] Require deterministic ordering/stability for evidence entries (candidate sort, witness ids, bounded size policy).","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Require deterministic ordering/stability for evidence entries (candidate sort, witness ids, bounded size policy).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.933341113Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:36.465031456Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-26i","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.406172410Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-26o","title":"[10.10] Add conformance suite for canonical serialization, ID derivation, signatures, revocation freshness, and epoch ordering.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Add conformance suite for canonical serialization, ID derivation, signatures, revocation freshness, and epoch ordering.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.547823652Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:36.549238445Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-26o","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.864716893Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-26qa","title":"[10.14] Add an ADR for `/dp/fastapi_rust` reuse scope across FrankenEngine service/API control surfaces.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add an ADR for `/dp/fastapi_rust` reuse scope across FrankenEngine service/API control surfaces.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:46.189371169Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:36.645617726Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-26qa","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:18.665026925Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-27i1","title":"[10.15] Add automatic demotion/rollback mechanism when post-promotion divergence or risk-threshold breaches are detected.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add automatic demotion/rollback mechanism when post-promotion divergence or risk-threshold breaches are detected.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:54.577647962Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:36.733828582Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-27i1","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.651679544Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-27ks","title":"[12] Prevent over-hardening performance regressions with profile-driven optimization and tail-latency budgets","description":"Plan Reference: section 12 (Risk Register).\nObjective: Performance regressions from over-hardening:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:17.965796863Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:09.020026168Z","closed_at":"2026-02-20T07:39:04.832961058Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"],"dependencies":[{"issue_id":"bd-27ks","depends_on_id":"bd-2rbm","type":"parent-child","created_at":"2026-02-20T07:45:09.019981044Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-27tk","title":"[14] Store benchmark artifacts and result ledgers via `/dp/frankensqlite` contracts; provide operator triage and replay dashboards through `/dp/frankentui`.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Store benchmark artifacts and result ledgers via `/dp/frankensqlite` contracts; provide operator triage and replay dashboards through `/dp/frankentui`.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:31.868363217Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.128696725Z","closed_at":"2026-02-20T07:41:20.198493760Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-27tk","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.128655168Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-289","title":"[10.11] Add global bulkheads for remote in-flight operations and background maintenance concurrency.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add global bulkheads for remote in-flight operations and background maintenance concurrency.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.993267561Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:36.822994027Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-289","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.448986302Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-28fe","title":"[13] all high-impact safety actions are executed through decision contracts and emitted through canonical evidence ledgers","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: all high-impact safety actions are executed through decision contracts and emitted through canonical evidence ledgers\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:21.295029573Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.259036733Z","closed_at":"2026-02-20T07:39:59.901373391Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-28fe","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.258950773Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-28m","title":"[10.10] Extend capability token format with audience, expiry/nbf, jti, checkpoint binding, and revocation freshness binding.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Extend capability token format with audience, expiry/nbf, jti, checkpoint binding, and revocation freshness binding.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.256356827Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:36.909805377Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-28m","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.907835162Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-29a1","title":"[10.15] Emit randomness transcript commitments and seed-hash evidence for stochastic learning phases so downstream replay remains audit-deterministic at snapshot boundaries.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Emit randomness transcript commitments and seed-hash evidence for stochastic learning phases so downstream replay remains audit-deterministic at snapshot boundaries.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.986252558Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:37.002115228Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-29a1","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.698167428Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-29r","title":"[10.10] Implement monotonic message sequence and replay-drop enforcement on session channels.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement monotonic message sequence and replay-drop enforcement on session channels.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.098004329Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:37.093128113Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-29r","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.950231335Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-29s","title":"[10.10] Add migration contract for explicit cutover boundaries on security-critical formats and policies.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Add migration contract for explicit cutover boundaries on security-critical formats and policies.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:33.128016647Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:37.183924125Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-29s","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:15.995466395Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-29yn","title":"[13] extension lifecycle transitions (`start`, `reload`, `suspend`, `terminate`, `quarantine`, `revoke`) satisfy `request -> drain -> finalize` protocol invariants","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: extension lifecycle transitions (`start`, `reload`, `suspend`, `terminate`, `quarantine`, `revoke`) satisfy `request -> drain -> finalize` protocol invariants\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:21.505227665Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.306708823Z","closed_at":"2026-02-20T07:39:59.802594878Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-29yn","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.306645775Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2ag6","title":"[13] compatibility and reliability meet release gates","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: compatibility and reliability meet release gates\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:19.836100523Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.351691453Z","closed_at":"2026-02-20T07:40:00.620773504Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-2ag6","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.351634187Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2amp","title":"[14] Throughput/latency (`p50`, `p95`, `p99`) under extension-heavy workloads.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Throughput/latency (`p50`, `p95`, `p99`) under extension-heavy workloads.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:32.839566229Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.174370373Z","closed_at":"2026-02-20T07:41:19.777047982Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-2amp","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.174328545Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2ao","title":"[10.11] Implement region-quiescence close protocol (`cancel -> drain -> finalize`) for engine and host subsystems.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement region-quiescence close protocol (`cancel -> drain -> finalize`) for engine and host subsystems.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:33.737314445Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:37.300902462Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-2ao","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.494712216Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2cc8","title":"[16] Public technical reports that document failures, fixes, and measured frontier movement.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: Public technical reports that document failures, fixes, and measured frontier movement.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:36.854316330Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:43.924272387Z","closed_at":"2026-02-20T07:46:43.924248041Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"],"dependencies":[{"issue_id":"bd-2cc8","depends_on_id":"bd-esst","type":"parent-child","created_at":"2026-02-20T07:45:17.412053781Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2che","title":"[13] at least 2 independent third parties reproduce core benchmark claims using published tooling","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: at least 2 independent third parties reproduce core benchmark claims using published tooling\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:22.808934326Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.393606901Z","closed_at":"2026-02-20T07:39:59.182490612Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-2che","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.393554153Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2cq","title":"[10.12] Implement measured attestation handshake between execution cells and runtime policy plane.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement measured attestation handshake between execution cells and runtime policy plane.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.632636997Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:37.390211494Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-2cq","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:07.941196622Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2d21","title":"[10.14] Define when `/dp/sqlmodel_rust` must be used: typed schema/model workflows with material correctness or migration advantages.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Define when `/dp/sqlmodel_rust` must be used: typed schema/model workflows with material correctness or migration advantages.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:45.705450068Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:37.479394301Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-2d21","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:18.708915478Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2eu","title":"[10.7] Add metamorphic tests for parser/IR/execution invariants.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add metamorphic tests for parser/IR/execution invariants.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.468393695Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:37.557972506Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"],"dependencies":[{"issue_id":"bd-2eu","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-02-20T07:45:09.351072364Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2f8","title":"[10.2] Implement baseline interpreter skeleton for both lanes.","description":"## Plan Reference\nSection 10.2, item 8. Cross-refs: existing code in crates/franken-engine/src/lib.rs (QuickJsInspiredNativeEngine, V8InspiredNativeEngine, HybridRouter), 9F.1 (Verified Adaptive Compiler baseline path), Phase A exit gate.\n\n## What\nImplement the baseline interpreter skeleton for both execution lanes (quickjs-inspired-native and v8-inspired-native). These are de novo Rust implementations, not FFI wrappers. The baseline interpreter is the canonical execution path that all optimizations must prove equivalence against.\n\n## Detailed Requirements\n- QuickJsInspiredNativeEngine: deterministic, low-overhead execution lane for simple workloads\n- V8InspiredNativeEngine: throughput-optimized lane for complex workloads (imports, async)\n- Both must implement the JsEngine trait (already defined in crate)\n- Both must consume IR3 (ExecIR) and produce IR4 (WitnessIR) artifacts\n- HybridRouter: policy-directed routing between lanes (already has basic routing logic)\n- Interpreter must support: variable lookup, function calls, object operations, control flow, error handling\n- Baseline interpreter remains canonical even after optimized paths are available (per 9F.1)\n\n## Rationale\nFrom Section 2: 'No dependency on external JS engine bindings for core runtime behavior.' The baseline interpreter is the foundation for Phase A exit gate (native execution lanes pass baseline conformance). Per 9F.1, this baseline path is never removed - it serves as the canonical reference against which all adaptive optimizations are validated.\n\n## Testing Requirements\n- Unit tests: evaluate simple arithmetic expressions\n- Unit tests: evaluate variable declarations and references\n- Unit tests: evaluate function definitions and calls\n- Unit tests: evaluate object property access\n- Unit tests: evaluate control flow (if/else, loops, try/catch)\n- Conformance: test262 ES2020 subset for baseline correctness\n- Determinism: same input produces identical output and witness across runs\n\n## Dependencies\n- Blocked by: parser trait (bd-crp), IR contract (bd-1wa), execution-slot registry (bd-20b)\n- Blocks: ES2020 object/prototype semantics, closure/scope model, Promise/async, error semantics","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.332198398Z","created_by":"ubuntu","updated_at":"2026-02-20T07:48:30.542893537Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"],"dependencies":[{"issue_id":"bd-2f8","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:45:18.161098083Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2fa1","title":"[10.13] Add dependency policy: no local forks of `TraceId`, `DecisionId`, `PolicyId`, `SchemaVersion`, `Budget`, or `Cx`.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add dependency policy: no local forks of `TraceId`, `DecisionId`, `PolicyId`, `SchemaVersion`, `Budget`, or `Cx`.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:41.981869972Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:37.773218722Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-2fa1","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:11.951820154Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2fqx","title":"[13] deterministic replay coverage is `100%` for high-severity decisions and incidents, with deterministic re-execution defined over fixed artifacts (`code`, `policy`, `model snapshot`, `randomness transcript`)","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: deterministic replay coverage is `100%` for high-severity decisions and incidents, with deterministic re-execution defined over fixed artifacts (`code`, `policy`, `model snapshot`, `randomness transcript`)\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:20.876810504Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.440578847Z","closed_at":"2026-02-20T07:40:00.105791687Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-2fqx","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.440510099Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2ftv","title":"[10.15] Implement IR2 flow-label inference + runtime label propagation with static-first optimization (runtime checks only on dynamic/ambiguous edges).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement IR2 flow-label inference + runtime label propagation with static-first optimization (runtime checks only on dynamic/ambiguous edges).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:52.332495317Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:37.865082332Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-2ftv","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.741385392Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2g9","title":"[10.11] FrankenSQLite-Inspired Runtime Systems Track - Comprehensive Execution Epic","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.881356235Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:42.749601706Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-11"],"dependencies":[{"issue_id":"bd-2g9","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.237655492Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-1yq","type":"blocks","created_at":"2026-02-20T07:32:56.914287078Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2g9","depends_on_id":"bd-3vh","type":"blocks","created_at":"2026-02-20T07:32:56.999733537Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2gej","title":"[10.15] Add frankentui operator surfaces for capability-delta reviews (`current`, `proposed minimal`, `escrow events`, `override rationale`) with deterministic drill playback.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankentui operator surfaces for capability-delta reviews (`current`, `proposed minimal`, `escrow events`, `override rationale`) with deterministic drill playback.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:51.136955426Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:37.957018847Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-2gej","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.784946845Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2gg","title":"[10.11] Define supervision tree for long-lived services with restart budgets, escalation, and monotone severity outcomes.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Define supervision tree for long-lived services with restart budgets, escalation, and monotone severity outcomes.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.355157581Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:38.047618754Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-2gg","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.533353536Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2gl","title":"[10.5] Implement containment actions (`sandbox`, `suspend`, `terminate`, `quarantine`).","description":"Plan Reference: section 10.5 (Extension Host + Security).\nObjective: Implement containment actions (`sandbox`, `suspend`, `terminate`, `quarantine`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.548856097Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:38.137592955Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"],"dependencies":[{"issue_id":"bd-2gl","depends_on_id":"bd-1yq","type":"parent-child","created_at":"2026-02-20T07:45:04.332448399Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2h2","title":"[10.11] Add optional MMR-style compact proof support for marker-stream inclusion/prefix verification.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add optional MMR-style compact proof support for marker-stream inclusion/prefix verification.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:37.470488011Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:38.229689378Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-2h2","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.581098772Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2h70","title":"[11] Publish benchmark and correctness artifact bundle for each proposal","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: benchmark and correctness artifacts\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:17.346294237Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:17.114340277Z","closed_at":"2026-02-20T07:38:22.802113797Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-2h70","depends_on_id":"bd-18fu","type":"blocks","created_at":"2026-02-20T07:38:26.738320312Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2h70","depends_on_id":"bd-3tjn","type":"blocks","created_at":"2026-02-20T07:38:26.620876031Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2h70","depends_on_id":"bd-c1co","type":"parent-child","created_at":"2026-02-20T07:45:17.114289052Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2ic","title":"[10.10] Enforce revocation checks before token acceptance, risky operation execution, and extension activation.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Enforce revocation checks before token acceptance, risky operation execution, and extension activation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.522998007Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:38.320037736Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-2ic","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.040229768Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2j0k","title":"[13] red-team programs show `>= 10x` reduction in successful host compromise versus baseline Node/Bun default posture","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: red-team programs show `>= 10x` reduction in successful host compromise versus baseline Node/Bun default posture\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:20.463421562Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.482769968Z","closed_at":"2026-02-20T07:40:00.305988279Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-2j0k","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.482717761Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2j3","title":"[10.11] Emit proof-carrying recovery artifacts for degraded-mode repairs and rejected trust transitions.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Emit proof-carrying recovery artifacts for degraded-mode repairs and rejected trust transitions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:37.918993715Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:38.408723447Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-2j3","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.624283814Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2k6v","title":"[14] Equivalent external outputs (canonical digest).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Equivalent external outputs (canonical digest).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:29.452790735Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.221779563Z","closed_at":"2026-02-20T07:41:21.225463527Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-2k6v","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.221739378Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2knu","title":"[14] Benchmark families (each required): `boot-storm`, `capability-churn`, `mixed-cpu-io-agent-mesh`, `reload-revoke-churn`, `adversarial-noise-under-load`.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Benchmark families (each required): `boot-storm`, `capability-churn`, `mixed-cpu-io-agent-mesh`, `reload-revoke-churn`, `adversarial-noise-under-load`.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:28.746782737Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.268010608Z","closed_at":"2026-02-20T07:41:21.522710122Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-2knu","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.267966837Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2l0x","title":"[10.14] Add an ADR declaring `/dp/frankentui` as the required substrate for advanced operator console/TUI surfaces in FrankenEngine.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add an ADR declaring `/dp/frankentui` as the required substrate for advanced operator console/TUI surfaces in FrankenEngine.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:44.731663363Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:38.496645626Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-2l0x","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:18.754079796Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2l6","title":"[10.6] Enforce one-lever-per-change performance policy.","description":"Plan Reference: section 10.6 (Performance Program).\nObjective: Enforce one-lever-per-change performance policy.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:25.750262716Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:38.589131215Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-6"],"dependencies":[{"issue_id":"bd-2l6","depends_on_id":"bd-12m","type":"parent-child","created_at":"2026-02-20T07:43:29.837969159Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2lr7","title":"[10.15] Implement static upper-bound authority analyzer from capability-typed IR + manifest intents.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement static upper-bound authority analyzer from capability-typed IR + manifest intents.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:49.968133192Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:38.686212623Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-2lr7","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.833939675Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2lt9","title":"[10.15] Define privacy-learning contract for fleet calibration (`feature schema`, update policy, clipping strategy, DP budget semantics, secure-aggregation requirements).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define privacy-learning contract for fleet calibration (`feature schema`, update policy, clipping strategy, DP budget semantics, secure-aggregation requirements).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.659304528Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:38.776743150Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-2lt9","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.888174898Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2mf","title":"[10.1] Charter + Governance - Comprehensive Execution Epic","description":"Plan Reference: section 10.1 (Charter + Governance).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.238038859Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:42.837854810Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-1"],"dependencies":[{"issue_id":"bd-2mf","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.281544906Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2mm","title":"[10.8] Add runtime diagnostics and evidence export CLI.","description":"Plan Reference: section 10.8 (Operational Readiness).\nObjective: Add runtime diagnostics and evidence export CLI.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:27.282300916Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:38.868361102Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-8"],"dependencies":[{"issue_id":"bd-2mm","depends_on_id":"bd-32r","type":"parent-child","created_at":"2026-02-20T07:45:09.159633187Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2n3","title":"[10.9] Release gate: PLAS is active for prioritized extension cohorts with signed `capability_witness` artifacts and escrow-path replay evidence (implementation ownership: `10.15`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: PLAS is active for prioritized extension cohorts with signed `capability_witness` artifacts and escrow-path replay evidence (implementation ownership: `10.15`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.422306795Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:38.966143186Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"],"dependencies":[{"issue_id":"bd-2n3","depends_on_id":"bd-1xm","type":"parent-child","created_at":"2026-02-20T07:45:03.864493381Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2n6","title":"[10.11] Implement O(Delta) anti-entropy reconciliation for distributed revocation/checkpoint/evidence object sets.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement O(Delta) anti-entropy reconciliation for distributed revocation/checkpoint/evidence object sets.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:37.620001617Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:39.058685029Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-2n6","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.664973058Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2n9","title":"[10.6] Implement benchmark denominator calculator (`weighted geometric mean`) and publication gate for Node/Bun comparisons.","description":"Plan Reference: section 10.6 (Performance Program).\nObjective: Implement benchmark denominator calculator (`weighted geometric mean`) and publication gate for Node/Bun comparisons.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:25.351481353Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:39.151381641Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-6"],"dependencies":[{"issue_id":"bd-2n9","depends_on_id":"bd-12m","type":"parent-child","created_at":"2026-02-20T07:43:29.925952486Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2ntw","title":"[11] Require standardized change-summary contract for major subsystem proposals","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: change summary\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:15.858259181Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:17.154627302Z","closed_at":"2026-02-20T07:38:23.501220128Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-2ntw","depends_on_id":"bd-c1co","type":"parent-child","created_at":"2026-02-20T07:45:17.154577349Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2nxj","title":"[10.15] Add shadow-evaluation gate that blocks global model/policy promotion unless privacy-preserving updates improve safety metrics without exceeding privacy budgets.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add shadow-evaluation gate that blocks global model/policy promotion unless privacy-preserving updates improve safety metrics without exceeding privacy budgets.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:48.149688287Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:39.239966273Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-2nxj","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.930939498Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2onl","title":"[10.12] Build continuous adversarial campaign generator with mutation grammars and exploit objective scoring.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Build continuous adversarial campaign generator with mutation grammars and exploit objective scoring.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:40.089188127Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:39.329154621Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-2onl","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:07.981744472Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2pv","title":"[10.7] Add specialization-conformance suite ensuring proof-specialized and unspecialized execution remain semantically equivalent across policy/proof epoch transitions.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add specialization-conformance suite ensuring proof-specialized and unspecialized execution remain semantically equivalent across policy/proof epoch transitions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:27.144406733Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:39.420181162Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"],"dependencies":[{"issue_id":"bd-2pv","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-02-20T07:45:09.393842954Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2pwr","title":"[16] Reproducible datasets for incident replay and adversarial campaign evaluation.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: Reproducible datasets for incident replay and adversarial campaign evaluation.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:36.246858840Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:54.315596848Z","closed_at":"2026-02-20T07:46:54.315573395Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"],"dependencies":[{"issue_id":"bd-2pwr","depends_on_id":"bd-esst","type":"parent-child","created_at":"2026-02-20T07:45:17.457177294Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2py0","title":"[10.13] Add interference tests for multiple controllers touching same metrics with required timescale-separation statements.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add interference tests for multiple controllers touching same metrics with required timescale-separation statements.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:43.753657799Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:39.511060879Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-2py0","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:11.997191047Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2qj","title":"[10.12] Implement translation-validation gate on adaptive optimization paths with fail-closed rollback.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement translation-validation gate on adaptive optimization paths with fail-closed rollback.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:38.374222211Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:39.599053810Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-2qj","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.026950789Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2ql","title":"[10.6] Define and publish Extension-Heavy Benchmark Suite v1.0 (workload matrix, profiles, datasets, golden outputs).","description":"Plan Reference: section 10.6 (Performance Program).\nObjective: Define and publish Extension-Heavy Benchmark Suite v1.0 (workload matrix, profiles, datasets, golden outputs).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:25.217563396Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:39.688679031Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-6"],"dependencies":[{"issue_id":"bd-2ql","depends_on_id":"bd-12m","type":"parent-child","created_at":"2026-02-20T07:43:30.010876936Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2qqv","title":"[14] Security-proof specialization uplift (performance delta between proof-specialized and ambient-authority modes, invalidation/fallback correctness rate).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Security-proof specialization uplift (performance delta between proof-specialized and ambient-authority modes, invalidation/fallback correctness rate).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:34.195377123Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.311340741Z","closed_at":"2026-02-20T07:41:19.177590053Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-2qqv","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.311296789Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2qx","title":"[10.8] Add deterministic safe-mode startup flag.","description":"Plan Reference: section 10.8 (Operational Readiness).\nObjective: Add deterministic safe-mode startup flag.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:27.415482892Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:39.776464926Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-8"],"dependencies":[{"issue_id":"bd-2qx","depends_on_id":"bd-32r","type":"parent-child","created_at":"2026-02-20T07:45:09.215032639Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2r0c","title":"[15] Enterprise governance hooks (policy-as-code pipelines, audit export, compliance evidence contracts).","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Enterprise governance hooks (policy-as-code pipelines, audit export, compliance evidence contracts).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:34.799999532Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:50.118803804Z","closed_at":"2026-02-20T07:45:50.118780110Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"],"dependencies":[{"issue_id":"bd-2r0c","depends_on_id":"bd-1jak","type":"parent-child","created_at":"2026-02-20T07:43:30.345184896Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2r6","title":"[10.12] Frontier Programs Execution Track (9H Canonical Owners) - Comprehensive Execution Epic","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.946742810Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:42.932022079Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-12"],"dependencies":[{"issue_id":"bd-2r6","depends_on_id":"bd-12m","type":"blocks","created_at":"2026-02-20T07:32:57.174530148Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.321435152Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-1yq","type":"blocks","created_at":"2026-02-20T07:32:57.087391637Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-2g9","type":"blocks","created_at":"2026-02-20T07:32:57.452351892Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-383","type":"blocks","created_at":"2026-02-20T07:32:57.259276974Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2r6","depends_on_id":"bd-3vh","type":"blocks","created_at":"2026-02-20T07:32:57.365641207Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2rbm","title":"[12] Risk Register - Comprehensive Execution Epic","description":"Plan Reference: section 12 (Risk Register).\nPurpose: Operationalize this section's governance/validation/adoption requirements into enforceable engineering work.\nQuality requirements for all children:\n- explicit acceptance criteria and failure semantics\n- unit-test and e2e/integration verification expectations\n- detailed structured logging and reproducibility artifacts where applicable\n- traceability back to category-level goals (security, performance, explainability, adoption)\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:15.336762088Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:43.022553968Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-12"],"dependencies":[{"issue_id":"bd-2rbm","depends_on_id":"bd-1tsf","type":"blocks","created_at":"2026-02-20T07:34:37.814888700Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2rbm","depends_on_id":"bd-3t2d","type":"parent-child","created_at":"2026-02-20T07:45:15.152717629Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2rbm","depends_on_id":"bd-c1co","type":"blocks","created_at":"2026-02-20T07:34:38.301934511Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2rk","title":"[10.7] Add probabilistic security conformance tests (benign vs malicious corpora).","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add probabilistic security conformance tests (benign vs malicious corpora).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.335202783Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:39.865575699Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"],"dependencies":[{"issue_id":"bd-2rk","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-02-20T07:45:09.435544965Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2rx","title":"[10.9] Release gate: proof-carrying optimization pipeline is enabled with replayable validation artifacts (implementation ownership: `10.12`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: proof-carrying optimization pipeline is enabled with replayable validation artifacts (implementation ownership: `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.139535732Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:39.955659223Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"],"dependencies":[{"issue_id":"bd-2rx","depends_on_id":"bd-1xm","type":"parent-child","created_at":"2026-02-20T07:45:03.909404107Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2s1","title":"[10.11] Map work classes to scheduler lanes (`cancel`, `timed`, `ready`) and require task-type labeling for observability.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Map work classes to scheduler lanes (`cancel`, `timed`, `ready`) and require task-type labeling for observability.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.842779780Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:40.048759607Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-2s1","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.709985795Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2s6b","title":"[13] data-confinement claims are machine-verifiable from evidence/provenance artifacts for published incident and benchmark corpora","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: data-confinement claims are machine-verifiable from evidence/provenance artifacts for published incident and benchmark corpora\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:26.404544393Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.528450508Z","closed_at":"2026-02-20T07:39:57.591553575Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-2s6b","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.528390887Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2s7","title":"[10.10] Define stable, versioned error-code namespace and compatibility policy.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Define stable, versioned error-code namespace and compatibility policy.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.260998047Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:40.140541124Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-2s7","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.082985991Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2sbb","title":"[10.13] Add deterministic evidence replay checks ensuring decision/evidence linkage replays identically across machines.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add deterministic evidence replay checks ensuring decision/evidence linkage replays identically across machines.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:43.276406602Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:40.230197403Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-2sbb","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:12.043257877Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2t3","title":"[10.10] Implement deterministic serialization module with schema-hash prefix validation.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement deterministic serialization module with schema-hash prefix validation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.418156697Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:40.322044743Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-2t3","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.126045059Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2t97","title":"[13] ES2020 runtime conformance is demonstrably complete per the declared `test262` normative gate and waiver policy","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: ES2020 runtime conformance is demonstrably complete per the declared `test262` normative gate and waiver policy\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:20.041315774Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.571855260Z","closed_at":"2026-02-20T07:40:00.518893834Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-2t97","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.571803844Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2ta","title":"[10.11] Implement epoch-scoped derivation for symbol/session/authentication keys with domain separation.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement epoch-scoped derivation for symbol/session/authentication keys with domain separation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.817283657Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:40.410062479Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-2ta","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.757089095Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2th8","title":"[10.12] Add frontier demo gates requiring externally auditable breakthrough artifacts before frontier-track promotion.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Add frontier demo gates requiring externally auditable breakthrough artifacts before frontier-track promotion.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:41.494277732Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:40.514991715Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-2th8","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.067445832Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2tx","title":"Implement deterministic eval error contract and routing reason metadata","description":"Implements PLAN 10.2 deterministic error semantics milestone for the current native-lane scaffold. Replace ad-hoc anyhow string errors with a stable typed error contract and expose deterministic routing metadata (why HybridRouter selected a lane). Add focused unit tests covering empty-source rejection and route-selection reason invariants.","status":"in_progress","priority":1,"issue_type":"task","assignee":"BrightForge","created_at":"2026-02-20T07:24:05.905124184Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:18.201429070Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["determinism","engine","plan","section-10-2","testing"],"dependencies":[{"issue_id":"bd-2tx","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:45:18.201379327Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2tzx","title":"[10.15] Integrate policy theorem checks so witness promotion requires merge legality, attenuation legality, and non-interference constraints.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Integrate policy theorem checks so witness promotion requires merge legality, attenuation legality, and non-interference constraints.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:50.468229572Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:40.612500950Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-2tzx","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:13.973853515Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2u0","title":"Add reproducibility contract templates (env/manifest/repro-lock)","description":"Implements PLAN section 10.1 third TODO by adding a reproducibility contract template for env.json, manifest.json, and repro.lock with deterministic field requirements and usage guidance.","status":"in_progress","priority":1,"issue_type":"task","created_at":"2026-02-20T07:26:28.252895583Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:16.172199282Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["governance","plan","reproducibility","section-10-1"],"dependencies":[{"issue_id":"bd-2u0","depends_on_id":"bd-2mf","type":"parent-child","created_at":"2026-02-20T07:45:07.444257009Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2u0","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.172145031Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2u5e","title":"[14] Replay correctness (determinism pass rate, artifact completeness).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Replay correctness (determinism pass rate, artifact completeness).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:33.332670275Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.350576347Z","closed_at":"2026-02-20T07:41:19.575159067Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-2u5e","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.350534980Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2vnj","title":"[10.15] Add adversarial tests for capability-escalation attempts that try to exploit synthesis uncertainty or emergency-grant pathways.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add adversarial tests for capability-escalation attempts that try to exploit synthesis uncertainty or emergency-grant pathways.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:51.666451198Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:40.708765126Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-2vnj","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.024560197Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2vu","title":"[10.7] Add differential lockstep suite against Node/Bun for benchmark and semantic parity cases with deterministic failure classification.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add differential lockstep suite against Node/Bun for benchmark and semantic parity cases with deterministic failure classification.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.738270700Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:40.798735781Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"],"dependencies":[{"issue_id":"bd-2vu","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-02-20T07:45:09.478624831Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2w2g","title":"[10.15] Implement signed witness publication pipeline with transparency-log inclusion and consistency proofs.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement signed witness publication pipeline with transparency-log inclusion and consistency proofs.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:50.633439456Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:40.893504872Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-2w2g","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.078582805Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2w9w","title":"[10.15] Define PLAS artifact schema (`capability_witness`) with canonical fields for minimal envelope, proof obligations, confidence bounds, and replay/rollback linkage.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define PLAS artifact schema (`capability_witness`) with canonical fields for minimal envelope, proof obligations, confidence bounds, and replay/rollback linkage.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:49.802319233Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:40.983920085Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-2w9w","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.118963614Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2wft","title":"[15] Migration of representative Node/Bun extension packs with deterministic behavior validation artifacts.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Migration of representative Node/Bun extension packs with deterministic behavior validation artifacts.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:35.617252704Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:37.040256341Z","closed_at":"2026-02-20T07:45:36.986807953Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"],"dependencies":[{"issue_id":"bd-2wft","depends_on_id":"bd-1jak","type":"parent-child","created_at":"2026-02-20T07:43:30.428762577Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2wpo","title":"[14] Publish full run manifest: hardware, kernel, runtime versions, flags, dataset checksums, seed transcripts, and harness commit IDs.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Publish full run manifest: hardware, kernel, runtime versions, flags, dataset checksums, seed transcripts, and harness commit IDs.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:31.627651448Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.392716233Z","closed_at":"2026-02-20T07:41:20.299664980Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-2wpo","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.392671670Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2wz9","title":"[10.13] Integrate and verify cancellation lifecycle compliance (`request -> drain -> finalize`) for unload, quarantine, suspend, terminate, and revocation events using `10.11` primitives.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Integrate and verify cancellation lifecycle compliance (`request -> drain -> finalize`) for unload, quarantine, suspend, terminate, and revocation events using `10.11` primitives.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:42.638122091Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:41.078528217Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-2wz9","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:12.087944536Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2x4b","title":"[15] Reputation graph APIs for ecosystem-wide trust sharing and rapid incident response.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Reputation graph APIs for ecosystem-wide trust sharing and rapid incident response.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:35.011111687Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:47.124851706Z","closed_at":"2026-02-20T07:45:47.124828112Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"],"dependencies":[{"issue_id":"bd-2x4b","depends_on_id":"bd-1jak","type":"parent-child","created_at":"2026-02-20T07:43:30.513713085Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2xbp","title":"[13] release gates include deterministic `frankenlab` scenario replay for security-critical lifecycle and containment paths","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: release gates include deterministic `frankenlab` scenario replay for security-critical lifecycle and containment paths\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:21.731428315Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.616079177Z","closed_at":"2026-02-20T07:39:59.703972226Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-2xbp","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.616022411Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2xe","title":"[10.1] Add FrankenEngine-native architecture synthesis document derived from donor spec (no donor-architecture mirroring).","description":"Plan Reference: section 10.1 (Charter + Governance).\nObjective: Add FrankenEngine-native architecture synthesis document derived from donor spec (no donor-architecture mirroring).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.153093730Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:41.166253379Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-1"],"dependencies":[{"issue_id":"bd-2xe","depends_on_id":"bd-2mf","type":"parent-child","created_at":"2026-02-20T07:45:07.494838868Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2xe","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.214928676Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2xs8","title":"[13] >= 99% of declassification decisions emit signed receipt-linked replay artifacts with source/sink label provenance","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: >= 99% of declassification decisions emit signed receipt-linked replay artifacts with source/sink label provenance\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:26.166577606Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.660782778Z","closed_at":"2026-02-20T07:39:57.690544854Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-2xs8","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.660725381Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2xu5","title":"[10.15] Define TEE attestation policy for decision-receipt emitters (`approved measurements`, `attestation freshness window`, `revocation sources`, `platform trust roots`).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define TEE attestation policy for decision-receipt emitters (`approved measurements`, `attestation freshness window`, `revocation sources`, `platform trust roots`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.007786026Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:41.255286968Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-2xu5","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.161343176Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2y5d","title":"[10.15] Add policy guard forbidding GA releases when any core slot depends on delegate cells.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add policy guard forbidding GA releases when any core slot depends on delegate cells.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:55.092049218Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:41.344871222Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-2y5d","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.203566478Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2y7","title":"[10.10] Define `EngineObjectId` derivation (`domain_sep || zone_or_scope || schema_id || canonical_bytes`) for all signed security-critical objects.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Define `EngineObjectId` derivation (`domain_sep || zone_or_scope || schema_id || canonical_bytes`) for all signed security-critical objects.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.139149044Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:41.441130089Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-2y7","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.257882337Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2ygl","title":"[10.13] Thread `Cx` through all effectful extension-host APIs (hostcall gateways, policy checks, lifecycle transitions, telemetry emitters).","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Thread `Cx` through all effectful extension-host APIs (hostcall gateways, policy checks, lifecycle transitions, telemetry emitters).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:42.316309546Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:41.534782Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-2ygl","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:12.132257690Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2ytn","title":"[14] Equivalent error-class semantics for negative/exceptional cases.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Equivalent error-class semantics for negative/exceptional cases.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:29.934286468Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.432896739Z","closed_at":"2026-02-20T07:41:21.023895780Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-2ytn","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.432851295Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2zjv","title":"[13] >= 95% of high-impact decision receipts include valid non-expired attestation bindings verifiable by independent tooling","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: >= 95% of high-impact decision receipts include valid non-expired attestation bindings verifiable by independent tooling\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:23.864992957Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.708663486Z","closed_at":"2026-02-20T07:39:58.686758722Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-2zjv","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.708612621Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2zk0","title":"[16] At least 4 publishable technical reports with reproducible artifact bundles.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: At least 4 publishable technical reports with reproducible artifact bundles.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:37.061838187Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:40.958700096Z","closed_at":"2026-02-20T07:46:40.958674729Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"],"dependencies":[{"issue_id":"bd-2zk0","depends_on_id":"bd-esst","type":"parent-child","created_at":"2026-02-20T07:45:17.503325516Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3044","title":"[13] native execution lanes run without external engine bindings","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: native execution lanes run without external engine bindings\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:19.005704610Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.749868811Z","closed_at":"2026-02-20T07:40:01.015299379Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-3044","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.749818738Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-309","title":"[10.2] Implement TS-front-end normalization contract proving TS authoring lowers to ES2020-equivalent behavior before runtime.","description":"Plan Reference: section 10.2 (VM Core).\nObjective: Implement TS-front-end normalization contract proving TS authoring lowers to ES2020-equivalent behavior before runtime.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.973117526Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:41.624358209Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"],"dependencies":[{"issue_id":"bd-309","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:45:18.247583162Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-30g","title":"[10.11] Add VOI-budgeted monitor scheduler for high-cost diagnostic probes.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add VOI-budgeted monitor scheduler for high-cost diagnostic probes.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.519690796Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:41.710042490Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-30g","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.801435640Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-30vf","title":"[10.14] Add migration policy prohibiting ad-hoc local SQLite wrappers once `frankensqlite` adapter coverage exists.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add migration policy prohibiting ad-hoc local SQLite wrappers once `frankensqlite` adapter coverage exists.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:45.865261867Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:41.803878153Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-30vf","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:18.796997952Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-32d3","title":"[10.15] Add lockstep integration checks proving synthesized minimal policies preserve intended runtime behavior across FrankenEngine/Node/Bun comparison harnesses.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add lockstep integration checks proving synthesized minimal policies preserve intended runtime behavior across FrankenEngine/Node/Bun comparison harnesses.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:51.474286116Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:41.888115559Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-32d3","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.248741426Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-32pl","title":"[10.12] Define trust-economics model inputs (`loss_matrix`, `attacker_cost`, `containment_cost`, `blast_radius`).","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Define trust-economics model inputs (`loss_matrix`, `attacker_cost`, `containment_cost`, `blast_radius`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:40.397225012Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:41.980095947Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-32pl","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.108913736Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-32r","title":"[10.8] Operational Readiness - Comprehensive Execution Epic","description":"Plan Reference: section 10.8 (Operational Readiness).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.689545523Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:43.112163999Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-8"],"dependencies":[{"issue_id":"bd-32r","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.363221039Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-32r","depends_on_id":"bd-1yq","type":"blocks","created_at":"2026-02-20T07:32:56.310471121Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-32r","depends_on_id":"bd-383","type":"blocks","created_at":"2026-02-20T07:32:56.397421973Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-33ce","title":"[10.12] Integrate red/blue loop outputs into guardplane calibration and policy regression suites.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Integrate red/blue loop outputs into guardplane calibration and policy regression suites.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:40.244244207Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:42.069473717Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-33ce","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.148824840Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-33h","title":"[10.11] Define mandatory evidence-ledger schema for all controller/security decisions (candidates, constraints, chosen action, witnesses).","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Define mandatory evidence-ledger schema for all controller/security decisions (candidates, constraints, chosen action, witnesses).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.788764733Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:42.160770662Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-33h","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.844433544Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-33z","title":"[10.7] Add native-vs-delegate differential gate per execution slot with minimized repro artifacts and deterministic divergence taxonomy.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add native-vs-delegate differential gate per execution slot with minimized repro artifacts and deterministic divergence taxonomy.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.874494833Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:42.254055288Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"],"dependencies":[{"issue_id":"bd-33z","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-02-20T07:45:09.525316214Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-34l","title":"[10.12] Implement deterministic convergence + degraded partition policy for fleet containment actions.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement deterministic convergence + degraded partition policy for fleet containment actions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.017220192Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:42.344400500Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-34l","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.192244219Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-34vj","title":"[13] all advanced operator terminal UX surfaces are delivered through `/dp/frankentui` integration rather than parallel local TUI frameworks","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: all advanced operator terminal UX surfaces are delivered through `/dp/frankentui` integration rather than parallel local TUI frameworks\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:21.960249206Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.798022578Z","closed_at":"2026-02-20T07:39:59.597924162Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-34vj","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.797963718Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-352c","title":"[10.15] Add minimized repro artifact format for conformance failures with deterministic replay and machine-readable delta classification.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add minimized repro artifact format for conformance failures with deterministic replay and machine-readable delta classification.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:49.304135826Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:42.435905643Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-352c","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.288120801Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-359","title":"[10.11] Implement idempotency-key derivation and dedup semantics for retryable remote actions.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement idempotency-key derivation and dedup semantics for retryable remote actions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.403488089Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:42.525085454Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-359","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.888085396Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-36of","title":"[10.13] Publish an operator-facing control-plane invariants dashboard sourced from evidence ledgers and replay artifacts.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Publish an operator-facing control-plane invariants dashboard sourced from evidence ledgers and replay artifacts.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:44.571246918Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:42.614974246Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-36of","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:12.175209668Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-375","title":"[10.5] Apply full extension-host security policy path to delegate cells (same capability checks, decision contracts, and evidence obligations as untrusted extensions).","description":"Plan Reference: section 10.5 (Extension Host + Security).\nObjective: Apply full extension-host security policy path to delegate cells (same capability checks, decision contracts, and evidence obligations as untrusted extensions).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.818352242Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:42.705937790Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"],"dependencies":[{"issue_id":"bd-375","depends_on_id":"bd-1yq","type":"parent-child","created_at":"2026-02-20T07:45:04.376154532Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-37cc","title":"[16] At least 1 open benchmark or verification tool release adopted outside the project.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: At least 1 open benchmark or verification tool release adopted outside the project.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:37.469454326Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:34.755191605Z","closed_at":"2026-02-20T07:46:34.755166158Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"],"dependencies":[{"issue_id":"bd-37cc","depends_on_id":"bd-esst","type":"parent-child","created_at":"2026-02-20T07:45:17.545674271Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-37go","title":"[12] Prevent IFC over-constraint false denies with static-first analysis, shadow rollout, and guided label tuning","description":"Plan Reference: section 12 (Risk Register).\nObjective: IFC policy over-constraint causing false denies on benign integrations:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:18.588610065Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:09.064383925Z","closed_at":"2026-02-20T07:39:04.531888375Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"],"dependencies":[{"issue_id":"bd-37go","depends_on_id":"bd-2rbm","type":"parent-child","created_at":"2026-02-20T07:45:09.064338130Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-37zd","title":"[14] Information-flow security (unauthorized source->sink block rate, declassification false-allow/false-deny envelopes, confinement-proof completeness).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Information-flow security (unauthorized source->sink block rate, declassification false-allow/false-deny envelopes, confinement-proof completeness).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:33.992455835Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.472959907Z","closed_at":"2026-02-20T07:41:19.277944011Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-37zd","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.472918089Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-383","title":"[10.7] Conformance + Verification - Comprehensive Execution Epic","description":"Plan Reference: section 10.7 (Conformance + Verification).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.626241177Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:43.200032407Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-7"],"dependencies":[{"issue_id":"bd-383","depends_on_id":"bd-12m","type":"blocks","created_at":"2026-02-20T07:32:56.222490451Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.402430556Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-1yq","type":"blocks","created_at":"2026-02-20T07:32:56.133863056Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-383","depends_on_id":"bd-ntq","type":"blocks","created_at":"2026-02-20T07:32:56.047365819Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-395m","title":"[13] Program Success Criteria - Comprehensive Execution Epic","description":"Plan Reference: section 13 (Program Success Criteria).\nPurpose: Operationalize this section's governance/validation/adoption requirements into enforceable engineering work.\nQuality requirements for all children:\n- explicit acceptance criteria and failure semantics\n- unit-test and e2e/integration verification expectations\n- detailed structured logging and reproducibility artifacts where applicable\n- traceability back to category-level goals (security, performance, explainability, adoption)","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:15.440835033Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:15.194782175Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-13"],"dependencies":[{"issue_id":"bd-395m","depends_on_id":"bd-1tsf","type":"blocks","created_at":"2026-02-20T07:34:37.912339690Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-3t2d","type":"parent-child","created_at":"2026-02-20T07:45:15.194713176Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-395m","depends_on_id":"bd-c1co","type":"blocks","created_at":"2026-02-20T07:34:38.400218754Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-39f0","title":"[10.12] Define secure extension reputation graph schema with provenance, behavior evidence, revocation edges, and trust transitions.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Define secure extension reputation graph schema with provenance, behavior evidence, revocation edges, and trust transitions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:40.716047938Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:42.794912279Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-39f0","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.233218765Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3a5e","title":"[10.13] Route all high-impact safety actions through `franken-decision` decision contracts with explicit loss matrices and fallback policies.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Route all high-impact safety actions through `franken-decision` decision contracts with explicit loss matrices and fallback policies.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:42.954526812Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:42.885900549Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-3a5e","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:12.221805904Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ab3","title":"[10.15] Build verifier pipeline that validates signature chain, transparency log proofs, and attestation chain in one deterministic command.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Build verifier pipeline that validates signature chain, transparency log proofs, and attestation chain in one deterministic command.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.330897951Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:42.972491248Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-3ab3","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.329838510Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ai","title":"[10.10] Split principal key roles into signing/encryption/issuance and enforce independent revocation.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Split principal key roles into signing/encryption/issuance and enforce independent revocation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.538665659Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:43.066481899Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-3ai","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.300566136Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3azm","title":"[10.14] Add an ADR declaring `/dp/frankensqlite` as the required substrate for SQLite-backed control-plane persistence in FrankenEngine.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add an ADR declaring `/dp/frankensqlite` as the required substrate for SQLite-backed control-plane persistence in FrankenEngine.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:45.221039936Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:43.157901953Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-3azm","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:18.842800109Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3b5m","title":"[10.12] Implement runtime decision scoring with explicit expected-loss and attacker-ROI outputs.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement runtime decision scoring with explicit expected-loss and attacker-ROI outputs.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:40.555565450Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:43.252206840Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-3b5m","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.276429285Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3bc","title":"[10.10] Reject non-canonical encodings for security-critical object classes (no silent normalization).","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Reject non-canonical encodings for security-critical object classes (no silent normalization).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.279236382Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:43.337474575Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-3bc","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.343124822Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3bz4","title":"Implement ecosystem capture strategy for platform adoption and migration","description":"## Plan Reference\nSection 15: Ecosystem Capture Strategy\n\n## What\nFrankenEngine should not only outperform incumbents; it should become the default platform for high-trust extension ecosystems. This bead covers the full ecosystem capture strategy.\n\n## Execution Pillars\n1. **Signed extension registry**: Enforceable provenance, attestation, and revocation policies for all published extensions\n2. **Migration kits**: Convert existing Node/Bun extension workflows into capability-typed FrankenEngine workflows with deterministic behavior validation\n3. **Enterprise governance hooks**: Policy-as-code pipelines, audit export, and compliance evidence contracts for enterprise adoption\n4. **Reputation graph APIs**: Ecosystem-wide trust sharing and rapid incident response across the extension ecosystem\n5. **Partner program**: Early lighthouse adopters who validate category-shift outcomes in production environments\n\n## Adoption Targets\n- **Greenfield onboarding**: Minimal-friction deterministic safe-extension setup workflow for new users\n- **Migration validation**: Representative Node/Bun extension packs migrated with deterministic behavior validation artifacts proving equivalence\n- **Public case studies**: Documented real-world deployments showing materially improved security and operational outcomes\n\n## Rationale\nThe plan states: 'FrankenEngine should not only outperform incumbents; it should become the default platform for high-trust extension ecosystems.' This means the technical advantages (3x performance, deterministic security, proof-carrying decisions) must be coupled with practical adoption infrastructure. Without migration kits, enterprise hooks, and ecosystem trust mechanisms, technical superiority alone will not drive adoption.\n\n## Dependencies\n- Requires signed extension registry from 10.10 (FCP-Inspired Hardening)\n- Requires reputation graph from 10.12 (Frontier Programs)\n- Requires capability-typed IR from 10.2 (VM Core) for migration kits\n- Requires benchmark suite from 10.6/14 for case study evidence\n- Requires franken_node compatibility from Phase D for migration targets\n\n## Testing Requirements\n- Integration tests for migration kit: convert sample Node extension, verify capability-typed output, validate behavioral equivalence via lockstep\n- E2E test for greenfield onboarding workflow: new user can create, validate, and deploy a capability-typed extension with deterministic setup\n- Test for enterprise governance hook: policy-as-code pipeline validates extension, exports audit trail, produces compliance evidence\n- Test for reputation graph API: trust queries return correct scores, revocation events propagate to trust scores\n\n## Implementation Notes\n- Migration kits should leverage the tri-runtime lockstep oracle (9F.6) for behavior validation\n- Enterprise governance hooks should consume decision contracts and evidence ledgers from asupersync integration (10.13)\n- Signed registry should use FCP-inspired identity and revocation primitives from 10.10\n- Partner program should produce the case studies required by Section 16 (Scientific Contributions)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:46:21.021289385Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:43.427089427Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["adoption","ecosystem","migration","strategy"]}
{"id":"bd-3c1","title":"[10.7] Add stress tests for high-concurrency extension workloads.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add stress tests for high-concurrency extension workloads.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.603186612Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:43.516823902Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"],"dependencies":[{"issue_id":"bd-3c1","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-02-20T07:45:09.567646895Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3c8n","title":"[16] At least 2 externally replicated high-impact claims.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: At least 2 externally replicated high-impact claims.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:37.267143165Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:37.785861838Z","closed_at":"2026-02-20T07:46:37.785839076Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"],"dependencies":[{"issue_id":"bd-3c8n","depends_on_id":"bd-esst","type":"parent-child","created_at":"2026-02-20T07:45:17.588264966Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ch","title":"[10.4] Module + Runtime Surface - Comprehensive Execution Epic","description":"Plan Reference: section 10.4 (Module + Runtime Surface).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.430649522Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:43.286418574Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-4"],"dependencies":[{"issue_id":"bd-3ch","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.451259581Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ch","depends_on_id":"bd-ntq","type":"blocks","created_at":"2026-02-20T07:32:55.522152454Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ciq","title":"[10.15] Implement delegate-cell runtime harness for not-yet-native slots with explicit capability envelopes, sandbox controls, and replay hooks.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement delegate-cell runtime harness for not-yet-native slots with explicit capability envelopes, sandbox controls, and replay hooks.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:54.063910753Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:43.608506414Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-3ciq","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.374027342Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3db2","title":"[14] No work dropping, relaxed durability, or disabled policy checks to inflate throughput.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: No work dropping, relaxed durability, or disabled policy checks to inflate throughput.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:30.185215499Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.512473261Z","closed_at":"2026-02-20T07:41:20.924285308Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-3db2","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.512431964Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3de4","title":"[14] Include both performance and security co-metrics (not speed-only benchmarks).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Include both performance and security co-metrics (not speed-only benchmarks).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:27.810159997Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.554378079Z","closed_at":"2026-02-20T07:41:21.924584896Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-3de4","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.554334899Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3e7","title":"[10.11] Add append-only hash-linked decision marker stream for high-impact security/policy transitions.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add append-only hash-linked decision marker stream for high-impact security/policy transitions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:37.318303109Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:43.698316780Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-3e7","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.929077945Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ebk","title":"[16] Open specifications for core trust/replay/policy primitives.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: Open specifications for core trust/replay/policy primitives.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:36.038965842Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:58.631079393Z","closed_at":"2026-02-20T07:46:58.631056580Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"],"dependencies":[{"issue_id":"bd-3ebk","depends_on_id":"bd-esst","type":"parent-child","created_at":"2026-02-20T07:45:17.627866013Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3fon","title":"[13] high-risk detections reach containment in `<= 250ms` median time under defined load envelopes","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: high-risk detections reach containment in `<= 250ms` median time under defined load envelopes\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:20.672412706Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.841721898Z","closed_at":"2026-02-20T07:40:00.207375906Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-3fon","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.841671424Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3fr","title":"Add runtime charter codifying native-only engine policy","description":"Implements PLAN section 10.1 first TODO: add a runtime charter document that formalizes FrankenEngine's native-only execution doctrine and non-negotiable boundaries. Include explicit prohibition of binding-led execution cores and define acceptance criteria for architectural changes.","status":"closed","priority":1,"issue_type":"task","assignee":"StormyPond","created_at":"2026-02-20T07:23:21.056176395Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:16.386099603Z","closed_at":"2026-02-20T07:24:14.801246681Z","close_reason":"Added docs/RUNTIME_CHARTER.md and linked it from README to codify native-only runtime governance contract","source_repo":".","compaction_level":0,"original_size":0,"labels":["architecture","governance","plan","section-10-1"],"dependencies":[{"issue_id":"bd-3fr","depends_on_id":"bd-2mf","type":"parent-child","created_at":"2026-02-20T07:45:07.539429699Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3fr","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.386045322Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3g4","title":"[10.0] Top-10 #4: Alien-performance profile discipline and hotpath program gates (strategy: `9A.4`; deep semantics: `9F.1`, `9F.12`, `9F.14`; execution owners: `10.6`, `10.12`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #4: Alien-performance profile discipline and hotpath program gates (strategy: `9A.4`; deep semantics: `9F.1`, `9F.12`, `9F.14`; execution owners: `10.6`, `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:19.640070759Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:43.789642038Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"],"dependencies":[{"issue_id":"bd-3g4","depends_on_id":"bd-1of","type":"parent-child","created_at":"2026-02-20T07:43:31.276914639Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3gsv","title":"[10.12] Implement third-party verifier toolkit that can independently validate benchmark, replay, and containment claims.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement third-party verifier toolkit that can independently validate benchmark, replay, and containment claims.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:41.339396718Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:43.878239224Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-3gsv","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.321113088Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3h31","title":"[14] Compute suite score `S_B = exp(sum_i w_i * ln(r_i))`, with non-zero weights summing to `1` and equal weighting across family/profile cells by default.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Compute suite score `S_B = exp(sum_i w_i * ln(r_i))`, with non-zero weights summing to `1` and equal weighting across family/profile cells by default.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:30.676909298Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.595606277Z","closed_at":"2026-02-20T07:41:20.725587397Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-3h31","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.595560882Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3h61","title":"[14] Require reproducibility artifacts for every published result.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Require reproducibility artifacts for every published result.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:28.043791177Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.637469557Z","closed_at":"2026-02-20T07:41:21.819283503Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-3h61","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.637426207Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3hj","title":"[10.0] Top-10 #5: Supply-chain trust fabric integrated with containment policy (strategy: `9A.5`; deep semantics: `9F.11`, `9F.9`; execution owners: `10.10`, `10.12`, `10.13`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #5: Supply-chain trust fabric integrated with containment policy (strategy: `9A.5`; deep semantics: `9F.11`, `9F.9`; execution owners: `10.10`, `10.12`, `10.13`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:19.764889026Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:43.966756321Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"],"dependencies":[{"issue_id":"bd-3hj","depends_on_id":"bd-1of","type":"parent-child","created_at":"2026-02-20T07:43:31.359171199Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3hkk","title":"[10.15] Implement declassification decision pipeline (`request -> policy/loss evaluation -> allow/deny -> signed receipt`) with deterministic replay.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement declassification decision pipeline (`request -> policy/loss evaluation -> allow/deny -> signed receipt`) with deterministic replay.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:52.505599946Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:44.057431548Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-3hkk","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.419749530Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ix","title":"[10.11] Add systematic interleaving explorer coverage for checkpoint/revocation/policy-update race surfaces.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add systematic interleaving explorer coverage for checkpoint/revocation/policy-update race surfaces.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.644665211Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:44.148290406Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-3ix","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:06.975272623Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3j5s","title":"[15] Public case studies showing materially improved security and operational outcomes.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Public case studies showing materially improved security and operational outcomes.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:35.820092460Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:33.991357886Z","closed_at":"2026-02-20T07:45:33.991333421Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"],"dependencies":[{"issue_id":"bd-3j5s","depends_on_id":"bd-1jak","type":"parent-child","created_at":"2026-02-20T07:43:30.602338197Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3jg","title":"[10.2] Implement static flow-check pass proving source/sink legality and emitting flow-proof witness artifacts.","description":"## Plan Reference\nSection 10.2, item 5. Cross-refs: 9I.7 (IFC), 9C.1 (proof-carrying compilation), 10.15 (IFC artifacts).\n\n## What\nImplement a static analysis pass over IR2 that proves source-to-sink data flow legality using the IFC flow-lattice, and emits flow-proof witness artifacts for audit and replay.\n\n## Detailed Requirements\n- Analyze IR2 data flow paths to verify all sourcesink flows comply with flow-lattice constraints\n- Emit flow-proof witness artifact for each analyzed extension/module containing: proved flows, denied flows, required declassifications\n- Reject compilation when unauthorized flows are detected (fail-closed)\n- Handle dynamic/late-bound paths by inserting runtime check points (runtime enforcement for paths that cannot be statically proven)\n- Witness artifacts must be deterministically serializable for evidence graph linkage\n\n## Rationale\nPer 9I.7: static compiler checks prove allowed flows where possible; runtime checks cover dynamic/late-bound paths. The flow-check pass is the static half of this design. It feeds into the evidence graph (9A.3) and enables the proof-guided specialization flywheel (9I.8) - regions with proven-safe IFC can have flow checks elided at runtime.\n\n## Testing Requirements\n- Unit tests: pass accepts code with only authorized flows\n- Unit tests: pass rejects code with unauthorized sourcesink flows\n- Unit tests: pass correctly identifies flows requiring declassification\n- Unit tests: witness artifact contains correct flow analysis results\n- IFC conformance corpus tests (10.7): benign dual-capability, exfil-attempt, declassification-exception workloads\n\n## Dependencies\n- Blocked by: IFC flow-lattice semantics (bd-1fm), lowering pipelines (bd-ug9)\n- Blocks: runtime flow-label propagation (10.5), PLAS flow envelope synthesis (10.15), proof-guided specialization (10.15)","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.933103541Z","created_by":"ubuntu","updated_at":"2026-02-20T07:48:12.812717835Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"],"dependencies":[{"issue_id":"bd-3jg","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:45:18.290379280Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3jy","title":"[10.5] Route all declassification requests through decision contracts with mandatory signed receipt + evidence linkage.","description":"Plan Reference: section 10.5 (Extension Host + Security).\nObjective: Route all declassification requests through decision contracts with mandatory signed receipt + evidence linkage.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:25.084975407Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:44.337572333Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"],"dependencies":[{"issue_id":"bd-3jy","depends_on_id":"bd-1yq","type":"parent-child","created_at":"2026-02-20T07:45:04.416278723Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3jz8","title":"[10.15] Implement budget accountant for differential privacy with epoch-scoped burn tracking and hard fail-closed budget exhaustion behavior.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement budget accountant for differential privacy with epoch-scoped burn tracking and hard fail-closed budget exhaustion behavior.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:47.823976890Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:44.432758702Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-3jz8","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.459334978Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3kch","title":"[13] post-burn-in false-deny rate for PLAS-enforced policies remains <= 0.5% on defined benign extension corpora","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: post-burn-in false-deny rate for PLAS-enforced policies remains <= 0.5% on defined benign extension corpora\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:25.462814610Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.885750622Z","closed_at":"2026-02-20T07:39:57.987420819Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-3kch","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.885693135Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3kd","title":"[10.10] Add golden vectors for critical binary encodings and verification paths.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Add golden vectors for critical binary encodings and verification paths.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.691915950Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:44.529826264Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-3kd","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.429530664Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3kks","title":"[10.15] Implement runtime capability escrow pathway for out-of-envelope requests (`challenge`/`sandbox` default), including explicit emergency-grant artifact format and expiry semantics.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement runtime capability escrow pathway for out-of-envelope requests (`challenge`/`sandbox` default), including explicit emergency-grant artifact format and expiry semantics.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:50.801745266Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:44.626185227Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-3kks","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.498741664Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ksg","title":"[13] category benchmark standard is adopted by external runtime/security research participants","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: category benchmark standard is adopted by external runtime/security research participants\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:23.650704726Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.930146509Z","closed_at":"2026-02-20T07:39:58.788546781Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-3ksg","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.930098340Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3lt3","title":"[10.15] Add frankentui operator surfaces for flow decisions (`label map`, `blocked flows`, `declassification history`, `confinement proofs`).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankentui operator surfaces for flow decisions (`label map`, `blocked flows`, `declassification history`, `confinement proofs`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:53.550205413Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:44.719346615Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-3lt3","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.540435479Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3md","title":"[10.5] Implement Bayesian posterior updater API.","description":"Plan Reference: section 10.5 (Extension Host + Security).\nObjective: Implement Bayesian posterior updater API.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.283640895Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:44.810654009Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"],"dependencies":[{"issue_id":"bd-3md","depends_on_id":"bd-1yq","type":"parent-child","created_at":"2026-02-20T07:45:04.461096196Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3mu","title":"[10.10] Add fuzz/adversarial targets for decode DoS, replay/splice handshake attacks, and token verification edge cases.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Add fuzz/adversarial targets for decode DoS, replay/splice handshake attacks, and token verification edge cases.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.834784649Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:44.902124807Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-3mu","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.472251351Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3mx","title":"[10.0] Top-10 #10: Provenance + revocation fabric and recall workflow (strategy: `9A.10`; deep semantics: `9F.9`; execution owners: `10.10`, `10.11`, `10.12`, `10.13`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #10: Provenance + revocation fabric and recall workflow (strategy: `9A.10`; deep semantics: `9F.9`; execution owners: `10.10`, `10.11`, `10.12`, `10.13`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:20.401176718Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:44.999364250Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"],"dependencies":[{"issue_id":"bd-3mx","depends_on_id":"bd-1of","type":"parent-child","created_at":"2026-02-20T07:43:31.442866810Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3n0","title":"[10.10] Enforce cross-zone reference constraints (provenance/audit allowed, authority leakage forbidden).","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Enforce cross-zone reference constraints (provenance/audit allowed, authority leakage forbidden).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.956701459Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:45.091787442Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-3n0","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.513541935Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3nc","title":"[10.11] Implement e-process guardrail integration that can hard-block unsafe automatic retunes.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement e-process guardrail integration that can hard-block unsafe automatic retunes.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.225966982Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:45.184184636Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-3nc","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:07.017904755Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ncx","title":"[10.15] Define moonshot contract schema (`hypothesis`, `target metrics`, `EV model`, `risk budget`, `artifact obligations`, `kill criteria`, `rollback plan`).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define moonshot contract schema (`hypothesis`, `target metrics`, `EV model`, `risk budget`, `artifact obligations`, `kill criteria`, `rollback plan`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:48.311102630Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:45.274057669Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-3ncx","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.582441555Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3nr","title":"[10.13] Asupersync Constitutional Integration Track - Comprehensive Execution Epic","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:19.008944962Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:43.373108216Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-13"],"dependencies":[{"issue_id":"bd-3nr","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.505926157Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-2g9","type":"blocks","created_at":"2026-02-20T07:32:57.630221276Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3nr","depends_on_id":"bd-3vh","type":"blocks","created_at":"2026-02-20T07:32:57.541284936Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3o95","title":"[10.14] Build a thin integration template for service endpoints (health, control actions, evidence export, replay control) using `fastapi_rust` conventions/components where relevant.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Build a thin integration template for service endpoints (health, control actions, evidence export, replay control) using `fastapi_rust` conventions/components where relevant.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:46.353647664Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:45.368464947Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-3o95","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:18.887024858Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3oc","title":"[10.12] Build policy theorem compiler passes and machine-check hooks for non-interference and merge determinism.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Build policy theorem compiler passes and machine-check hooks for non-interference and merge determinism.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.785361094Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:45.458282957Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-3oc","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.363111290Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ovc","title":"[10.12] Implement low-latency reputation updates and explainable trust-card generation for operators.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement low-latency reputation updates and explainable trust-card generation for operators.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:40.869149197Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:45.551509175Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-3ovc","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.404890845Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3pl","title":"[10.10] Enforce deterministic ordering for multi-signature arrays before verification.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Enforce deterministic ordering for multi-signature arrays before verification.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.695572103Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:45.641941189Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-3pl","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.555938449Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3q36","title":"[10.13] Add migration compatibility tests ensuring control-plane schema evolution preserves replay compatibility or fails with explicit machine-readable migration errors.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add migration compatibility tests ensuring control-plane schema evolution preserves replay compatibility or fails with explicit machine-readable migration errors.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:44.092670713Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:45.736477497Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-3q36","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:12.558346323Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3q9","title":"[10.15] Delta Moonshots Execution Track (9I) - Comprehensive Execution Epic","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:19.166766614Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:43.461737812Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-15"],"dependencies":[{"issue_id":"bd-3q9","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.553834597Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-1yq","type":"blocks","created_at":"2026-02-20T07:32:58.147892723Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-2r6","type":"blocks","created_at":"2026-02-20T07:32:57.803135730Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-383","type":"blocks","created_at":"2026-02-20T07:32:58.234088558Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-3nr","type":"blocks","created_at":"2026-02-20T07:32:57.889983660Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-ntq","type":"blocks","created_at":"2026-02-20T07:32:58.060658013Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3q9","depends_on_id":"bd-zvn","type":"blocks","created_at":"2026-02-20T07:32:57.975537360Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3qh2","title":"[13] every promoted `delegate -> native` core slot has a signed replacement receipt with reproducible differential/security/performance artifacts","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: every promoted `delegate -> native` core slot has a signed replacement receipt with reproducible differential/security/performance artifacts\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:27.109383954Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:10.972392363Z","closed_at":"2026-02-20T07:39:57.294852766Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-3qh2","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:10.972335998Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3qhv","title":"[15] Greenfield onboarding uses a minimal-friction deterministic safe-extension setup workflow.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Greenfield onboarding uses a minimal-friction deterministic safe-extension setup workflow.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:35.415623153Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:41.075920074Z","closed_at":"2026-02-20T07:45:41.075897502Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"],"dependencies":[{"issue_id":"bd-3qhv","depends_on_id":"bd-1jak","type":"parent-child","created_at":"2026-02-20T07:43:30.688108182Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3qm1","title":"[11] Require EV scoring output and tier classification","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: EV score and tier\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:16.275442400Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:17.199820635Z","closed_at":"2026-02-20T07:38:23.302829750Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-3qm1","depends_on_id":"bd-18fu","type":"blocks","created_at":"2026-02-20T07:38:26.041084965Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3qm1","depends_on_id":"bd-2ntw","type":"blocks","created_at":"2026-02-20T07:38:25.921720016Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3qm1","depends_on_id":"bd-c1co","type":"parent-child","created_at":"2026-02-20T07:45:17.199773307Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3qt4","title":"[13] unauthorized sensitive-source -> external-sink flows are deterministically blocked unless explicit declassification is approved by policy","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: unauthorized sensitive-source -> external-sink flows are deterministically blocked unless explicit declassification is approved by policy\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:25.932500234Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:11.016096512Z","closed_at":"2026-02-20T07:39:57.789509804Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-3qt4","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:11.016047911Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3qv","title":"[10.6] Add constrained-vs-ambient benchmark lanes quantifying specialization uplift from PLAS/IFC proof tightening under equivalent behavior.","description":"Plan Reference: section 10.6 (Performance Program).\nObjective: Add constrained-vs-ambient benchmark lanes quantifying specialization uplift from PLAS/IFC proof tightening under equivalent behavior.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:25.886536901Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:45.825444392Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-6"],"dependencies":[{"issue_id":"bd-3qv","depends_on_id":"bd-12m","type":"parent-child","created_at":"2026-02-20T07:43:30.090557769Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3rd","title":"[10.9] Release gate: continuous adversarial campaign runner demonstrates measurable compromise-rate suppression versus baseline engines (implementation ownership: `10.12`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: continuous adversarial campaign runner demonstrates measurable compromise-rate suppression versus baseline engines (implementation ownership: `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.284422049Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:45.915417952Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"],"dependencies":[{"issue_id":"bd-3rd","depends_on_id":"bd-1xm","type":"parent-child","created_at":"2026-02-20T07:45:03.948829106Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3rgq","title":"[10.15] Build conformance-vector generator and property/fuzz harness for cross-repo boundary invariants, including degraded/fault-mode scenarios.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Build conformance-vector generator and property/fuzz harness for cross-repo boundary invariants, including degraded/fault-mode scenarios.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:48.971309556Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:46.005331660Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-3rgq","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.625896961Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3s3","title":"[10.11] Implement named remote computation registry with deterministic input encoding and schema validation.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement named remote computation registry with deterministic input encoding and schema validation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.257470024Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:46.099765327Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-3s3","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:07.061285572Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3s6","title":"[10.10] Define mandatory runtime metrics and structured logs for auth/capability/replay/revocation/checkpoint failures.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Define mandatory runtime metrics and structured logs for auth/capability/replay/revocation/checkpoint failures.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:32.116293518Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:46.195979380Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-3s6","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.598975306Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3set","title":"[13] extension-heavy benchmark suites show `>= 3x` weighted-geometric-mean throughput versus Node baseline and `>= 3x` versus Bun baseline under Section `14` denominator and equivalence rules","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: extension-heavy benchmark suites show `>= 3x` weighted-geometric-mean throughput versus Node baseline and `>= 3x` versus Bun baseline under Section `14` denominator and equivalence rules\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:20.256995867Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:11.058909962Z","closed_at":"2026-02-20T07:40:00.419810734Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-3set","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:11.058852325Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3sq4","title":"[10.15] Add frankentui operator dashboard for replacement progress (`slot status`, `native coverage`, `blocked promotions`, `rollback events`, `next-best-EV replacements`).","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankentui operator dashboard for replacement progress (`slot status`, `native coverage`, `blocked promotions`, `rollback events`, `next-best-EV replacements`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:54.750417096Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:46.288201558Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-3sq4","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.660093232Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3t2d","title":"[MASTER] Execute PLAN 1-16 as self-contained bead graph","description":"Full-program orchestration epic spanning PLAN sections 1-16.\nThis includes architecture doctrine, execution tracks, evidence contracts, risk controls, success-criteria verification, benchmarking/standardization, ecosystem strategy, and scientific output obligations.\nCompletion requires:\n- all section epics complete\n- dependency graph remains acyclic and actionable\n- benchmark/security/replay claims supported by reproducible artifacts\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:38.990452762Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:43.554135565Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["full-program","master","plan"]}
{"id":"bd-3tjn","title":"[11] Define rollout wedge with progressive exposure guardrails","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: rollout wedge\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:16.937810451Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:17.241909206Z","closed_at":"2026-02-20T07:38:22.997619181Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-3tjn","depends_on_id":"bd-11ni","type":"blocks","created_at":"2026-02-20T07:38:26.389490704Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3tjn","depends_on_id":"bd-c1co","type":"parent-child","created_at":"2026-02-20T07:45:17.241866586Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3tt2","title":"[13] synthesized capability envelopes achieve <= 1.10 over-privilege ratio versus empirically required capability sets on benchmark cohorts","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: synthesized capability envelopes achieve <= 1.10 over-privilege ratio versus empirically required capability sets on benchmark cohorts\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:25.001151288Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:11.103579650Z","closed_at":"2026-02-20T07:39:58.185460504Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-3tt2","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:11.103530308Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3u0","title":"[10.7] Add IFC conformance corpus: dual-capability benign workloads, exfil-attempt workloads, and declassification-exception workloads with deterministic expected outcomes.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Add IFC conformance corpus: dual-capability benign workloads, exfil-attempt workloads, and declassification-exception workloads with deterministic expected outcomes.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:27.009147518Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:46.386161223Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"],"dependencies":[{"issue_id":"bd-3u0","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-02-20T07:45:09.615536290Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3u5","title":"[10.1] Add semantic donor spec document (observable behavior, edge cases, compatibility-critical semantics) as implementation source of truth.","description":"Plan Reference: section 10.1 (Charter + Governance).\nObjective: Add semantic donor spec document (observable behavior, edge cases, compatibility-critical semantics) as implementation source of truth.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.024917569Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:46.635735726Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-1"],"dependencies":[{"issue_id":"bd-3u5","depends_on_id":"bd-2mf","type":"parent-child","created_at":"2026-02-20T07:45:07.584497127Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3u5","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.644858363Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3u7","title":"[10.10] Implement delegated capability attenuation chain verification (no ambient authority path).","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement delegated capability attenuation chain verification (no ambient authority path).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:30.397976479Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:46.721822126Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-3u7","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.686355161Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ub","title":"[10.3] Implement initial GC with deterministic test mode.","description":"## Plan Reference\nSection 10.3, item 2. Cross-refs: 9B.4 (modern allocator strategy), 9D.4 (allocation profiling), Phase A exit gate.\n\n## What\nImplement the initial garbage collector with a deterministic test mode. The GC must support per-extension collection, domain-aware scanning, and fully deterministic behavior when running under test/replay conditions.\n\n## Detailed Requirements\n- GC must be domain-aware: collect per-extension independently, never scan across extension boundaries\n- Deterministic test mode: GC collection points, ordering, and outcomes are fully reproducible for replay\n- Support explicit GC triggers for testing (force collection at specific points)\n- GC must respect allocation domain budgets: trigger collection before OOM, report pressure\n- Safe mode: GC must never crash or corrupt on malformed object graphs (extensions are untrusted)\n- Incremental/generational design preferred but not required for initial implementation\n- GC pause metrics must be recorded for pause-time instrumentation (bd-50o)\n\n## Rationale\nDeterministic GC is critical for replay (9A.3/9F.3): if GC timing differs between record and replay, execution diverges. Per-extension collection is required for resource budget enforcement (9A.8) and security isolation. The plan requires that extensions cannot cause denial-of-service through memory exhaustion affecting other extensions.\n\n## Testing Requirements\n- Unit tests: allocate objects, trigger GC, verify dead objects collected\n- Unit tests: verify per-extension collection isolation (collecting ext A does not affect ext B)\n- Unit tests: deterministic mode produces identical collection sequence across runs\n- Unit tests: GC handles malformed/circular references safely (no crash, no infinite loop)\n- Stress tests: high allocation rate with concurrent extensions, verify no corruption\n- Regression tests: GC pause times stay within budget thresholds\n\n## Implementation Notes\n- Implement in crates/franken-engine memory module\n- Must work with #![forbid(unsafe_code)] - use safe abstractions for object graph traversal\n- Consider mark-sweep as initial strategy with upgrade path to generational\n- Deterministic mode: fix collection ordering, disable concurrent/parallel collection\n- Record GC events for evidence ledger integration\n\n## Dependencies\n- Blocked by: allocation domains (bd-3w2)\n- Blocks: pause-time instrumentation (bd-50o), interpreter correctness under GC pressure","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:23.238420251Z","created_by":"ubuntu","updated_at":"2026-02-20T07:48:31.753623849Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-3"],"dependencies":[{"issue_id":"bd-3ub","depends_on_id":"bd-3vk","type":"parent-child","created_at":"2026-02-20T07:45:16.899489005Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3uiy","title":"[13] moonshot portfolio governor enforces documented promote/hold/kill gates with 100% governance decision artifact completeness","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: moonshot portfolio governor enforces documented promote/hold/kill gates with 100% governance decision artifact completeness\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:24.310746694Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:11.144085893Z","closed_at":"2026-02-20T07:39:58.483056530Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-3uiy","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:11.144035589Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3uk","title":"[10.0] Top-10 #2: Probabilistic Guardplane runtime subsystem (strategy: `9A.2`; deep semantics: `9F.15`; execution owners: `10.5`, `10.11`, `10.12`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #2: Probabilistic Guardplane runtime subsystem (strategy: `9A.2`; deep semantics: `9F.15`; execution owners: `10.5`, `10.11`, `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:19.363943722Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:46.893316222Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"],"dependencies":[{"issue_id":"bd-3uk","depends_on_id":"bd-1of","type":"parent-child","created_at":"2026-02-20T07:43:31.529410456Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3vg","title":"[10.11] Add explicit checkpoint-placement contract for long-running loops (dispatch, scanning, policy iteration, replay, decode/verify paths).","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add explicit checkpoint-placement contract for long-running loops (dispatch, scanning, policy iteration, replay, decode/verify paths).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:33.592338932Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:46.976718022Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-3vg","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:07.104129409Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3vh","title":"[10.10] FCP-Inspired Hardening + Interop Track - Comprehensive Execution Epic","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-02-20T07:32:18.818455160Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:50.517135667Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-10"],"dependencies":[{"issue_id":"bd-3vh","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.598298431Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3vk","title":"[10.3] Memory + GC - Comprehensive Execution Epic","description":"Plan Reference: section 10.3 (Memory + GC).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:18.367735864Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:43.759127489Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-3"],"dependencies":[{"issue_id":"bd-3vk","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.641229190Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3vk","depends_on_id":"bd-ntq","type":"blocks","created_at":"2026-02-20T07:32:55.435834240Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3vlb","title":"[10.13] Define a formal control-plane adoption ADR naming `/dp/asupersync` crates as canonical sources for `Cx`, decision contracts, and evidence schema.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Define a formal control-plane adoption ADR naming `/dp/asupersync` crates as canonical sources for `Cx`, decision contracts, and evidence schema.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:41.647466885Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:47.061672604Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-3vlb","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:12.601370315Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3vp","title":"[10.4] Add explicit compatibility mode matrix for Node/Bun module edge cases (no hidden shims).","description":"Plan Reference: section 10.4 (Module + Runtime Surface).\nObjective: Add explicit compatibility mode matrix for Node/Bun module edge cases (no hidden shims).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:23.766540351Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:47.143979404Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-4"],"dependencies":[{"issue_id":"bd-3vp","depends_on_id":"bd-3ch","type":"parent-child","created_at":"2026-02-20T07:45:11.502022172Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3w2","title":"[10.3] Define allocation domains and lifetime classes.","description":"## Plan Reference\nSection 10.3, item 1. Cross-refs: 9B.4 (allocator strategy), 9D.4 (allocation profiling), 9B.1 (arena allocation for IR nodes).\n\n## What\nDefine the allocation domain taxonomy and lifetime class hierarchy for FrankenEngine's memory management. This is the foundational design for how memory is organized, tracked, and reclaimed across the runtime.\n\n## Detailed Requirements\n- Define allocation domains: per-extension heaps, shared runtime heap, IR arena, evidence/witness arena, temporary/scratch buffers\n- Define lifetime classes: request-scoped (single hostcall), session-scoped (extension session), global (runtime lifetime), arena (compilation unit)\n- Each domain must have explicit size limits for per-extension resource budget enforcement (9A.8)\n- Allocation tracking must be deterministic for replay: same allocation sequence under same inputs\n- Domain isolation: one extension's allocation cannot corrupt another's (security requirement)\n- Integration point with GC: lifetime classes inform GC root scanning and collection strategy\n\n## Rationale\nPer-extension resource budgets (9A.8) require fine-grained allocation control. The plan requires deterministic behavior for replay (9A.3), which means memory allocation patterns must be reproducible. Domain isolation is a security requirement - extensions are untrusted code that must not be able to corrupt runtime or other extension memory. Arena allocation (recommended in 9B.1) provides both performance and determinism benefits.\n\n## Testing Requirements\n- Unit tests: allocate from each domain, verify isolation (writes in one domain cannot read from another)\n- Unit tests: verify lifetime class scoping (request-scoped allocation freed after hostcall completes)\n- Unit tests: verify domain size limits are enforced (allocation fails when budget exceeded)\n- Property tests: allocation/deallocation sequences are deterministic given same inputs\n- Stress tests: high allocation rates across multiple domains do not corrupt or leak\n\n## Implementation Notes\n- Define domain/lifetime types in crates/franken-engine as core memory module\n- Consider typed arenas (one per IR level) for compilation pipeline\n- Must work with #![forbid(unsafe_code)] constraint from AGENTS.md - use safe abstractions\n- Arena designs should be compatible with the existing serde-based serialization approach\n\n## Dependencies\n- Blocks: GC implementation (bd-3ub), interpreter skeleton (bd-2f8 in 10.2)\n- Blocked by: nothing (foundational design)","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:23.104967561Z","created_by":"ubuntu","updated_at":"2026-02-20T07:48:18.345156228Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-3"],"dependencies":[{"issue_id":"bd-3w2","depends_on_id":"bd-3vk","type":"parent-child","created_at":"2026-02-20T07:45:16.942452184Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3zj","title":"[10.0] Top-10 #9: Adversarial security corpus + continuous fuzzing harness (strategy: `9A.9`; deep semantics: `9F.7`; execution owners: `10.7`, `10.12`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #9: Adversarial security corpus + continuous fuzzing harness (strategy: `9A.9`; deep semantics: `9F.7`; execution owners: `10.7`, `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:20.276166263Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:47.315830174Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"],"dependencies":[{"issue_id":"bd-3zj","depends_on_id":"bd-1of","type":"parent-child","created_at":"2026-02-20T07:43:31.613617018Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-4hf","title":"[10.11] Implement three-tier hash strategy contract (hot integrity, content identity, trust authenticity) with explicit scope boundaries.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Implement three-tier hash strategy contract (hot integrity, content identity, trust authenticity) with explicit scope boundaries.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:37.149605579Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:47.399640264Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-4hf","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:07.149716806Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-50o","title":"[10.3] Add pause-time instrumentation and regression budgets.","description":"Plan Reference: section 10.3 (Memory + GC).\nObjective: Add pause-time instrumentation and regression budgets.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:23.372225999Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:47.491501119Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-3"],"dependencies":[{"issue_id":"bd-50o","depends_on_id":"bd-3vk","type":"parent-child","created_at":"2026-02-20T07:45:16.982875002Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-51gj","title":"[12] Mitigate scope explosion via strict phase gates and one-lever optimization discipline","description":"Plan Reference: section 12 (Risk Register).\nObjective: Scope explosion:\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:17.552939631Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:09.105564824Z","closed_at":"2026-02-20T07:39:05.031472511Z","close_reason":"Consolidated into single risk register tracking bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-12"],"dependencies":[{"issue_id":"bd-51gj","depends_on_id":"bd-2rbm","type":"parent-child","created_at":"2026-02-20T07:45:09.105508630Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-52ko","title":"[16] External red-team and academic-style evaluations with published methodology.","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nObjective: External red-team and academic-style evaluations with published methodology.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:36.653405607Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:47.843776278Z","closed_at":"2026-02-20T07:46:47.843750720Z","close_reason":"Consolidated into single scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-16"],"dependencies":[{"issue_id":"bd-52ko","depends_on_id":"bd-esst","type":"parent-child","created_at":"2026-02-20T07:45:17.672857801Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-5pk","title":"[10.5] Implement hostcall telemetry schema and recorder.","description":"Plan Reference: section 10.5 (Extension Host + Security).\nObjective: Implement hostcall telemetry schema and recorder.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.153140274Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:47.576920507Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"],"dependencies":[{"issue_id":"bd-5pk","depends_on_id":"bd-1yq","type":"parent-child","created_at":"2026-02-20T07:45:04.505524975Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-62mo","title":"[14] Any failed-equivalence case invalidates claim publication until fixed or explicitly excluded via versioned benchmark-spec revision.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Any failed-equivalence case invalidates claim publication until fixed or explicitly excluded via versioned benchmark-spec revision.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:31.158639217Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.680750649Z","closed_at":"2026-02-20T07:41:20.501707210Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-62mo","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.680705635Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-6pk","title":"[10.9] Define and enforce disruption scorecard (`performance_delta`, `security_delta`, `autonomy_delta`) as release blockers.","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Define and enforce disruption scorecard (`performance_delta`, `security_delta`, `autonomy_delta`) as release blockers.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:27.852223090Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:47.662233045Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"],"dependencies":[{"issue_id":"bd-6pk","depends_on_id":"bd-1xm","type":"parent-child","created_at":"2026-02-20T07:45:03.990994920Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-6qsi","title":"[10.15] Define specialization receipt schema (`proof_specialization_receipt`) linking security-proof inputs to activated optimization classes and rollback lineage.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define specialization receipt schema (`proof_specialization_receipt`) linking security-proof inputs to activated optimization classes and rollback lineage.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:52.844002772Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:47.749871095Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-6qsi","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.687683038Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-70bx","title":"[14] Publish benchmark specification, harness code, datasets, and scoring formulas.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Publish benchmark specification, harness code, datasets, and scoring formulas.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:27.571404471Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.719048719Z","closed_at":"2026-02-20T07:41:22.023074751Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-70bx","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.719008133Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-74l","title":"Formalize evidence-bound claim language policy","description":"Implements PLAN section 10.1 second TODO. Extend runtime governance with explicit claim-language rules that gate performance/security/compatibility claims on reproducible artifacts, denominator disclosure, and bounded wording requirements.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:25:04.896000733Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:16.732310073Z","closed_at":"2026-02-20T07:26:12.419622162Z","close_reason":"Extended docs/RUNTIME_CHARTER.md with binding claim-language policy and updated README charter summary","source_repo":".","compaction_level":0,"original_size":0,"labels":["evidence","governance","plan","section-10-1"],"dependencies":[{"issue_id":"bd-74l","depends_on_id":"bd-2mf","type":"parent-child","created_at":"2026-02-20T07:45:07.629406431Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-74l","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.732253247Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-7rwi","title":"[10.15] Define verified self-replacement schema (`slot_registry`, `delegate_cell_manifest`, `replacement_receipt`, `promotion_decision`) with deterministic encoding and signature requirements.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Define verified self-replacement schema (`slot_registry`, `delegate_cell_manifest`, `replacement_receipt`, `promotion_decision`) with deterministic encoding and signature requirements.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:53.891031464Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:47.834479823Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-7rwi","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.726058723Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-83jh","title":"[10.15] Add synthesis search-budget contract (time/compute/depth caps) with fail-closed conservative fallback behavior on budget exhaustion.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add synthesis search-budget contract (time/compute/depth caps) with fail-closed conservative fallback behavior on budget exhaustion.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:50.303431746Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:47.917593576Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-83jh","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.849996459Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-89l2","title":"[10.14] Create a `franken_engine` storage adapter layer that binds runtime persistence contracts to `frankensqlite` APIs.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Create a `franken_engine` storage adapter layer that binds runtime persistence contracts to `frankensqlite` APIs.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:45.545669748Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:48.000598566Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-89l2","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:18.928571218Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-8az","title":"[10.10] Implement deterministic nonce derivation for any AEAD-protected data-plane envelope.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Implement deterministic nonce derivation for any AEAD-protected data-plane envelope.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:31.240856597Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:48.082929401Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-8az","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.772693036Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-8guj","title":"[13] service/API control surfaces relevant to runtime operations leverage `/dp/fastapi_rust` patterns/components where they provide equal or better capability","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: service/API control surfaces relevant to runtime operations leverage `/dp/fastapi_rust` patterns/components where they provide equal or better capability\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:22.385059452Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:11.184292809Z","closed_at":"2026-02-20T07:39:59.385562019Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-8guj","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:11.184242956Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-a5xc","title":"[14] Require at least two independent third-party reruns before category-level claims are treated as externally validated.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Require at least two independent third-party reruns before category-level claims are treated as externally validated.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:32.364545016Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.763817812Z","closed_at":"2026-02-20T07:41:19.994875004Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-a5xc","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.763774842Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-ag4","title":"[10.8] Add release checklist requiring security and performance artifact bundles.","description":"Plan Reference: section 10.8 (Operational Readiness).\nObjective: Add release checklist requiring security and performance artifact bundles.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:27.547431330Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:48.166955855Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-8"],"dependencies":[{"issue_id":"bd-ag4","depends_on_id":"bd-32r","type":"parent-child","created_at":"2026-02-20T07:45:09.258634207Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-ami3","title":"[10.15] Add frankensqlite-backed witness/index stores and conformance tests for deterministic witness retrieval and replay joins.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add frankensqlite-backed witness/index stores and conformance tests for deterministic witness retrieval and replay joins.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:51.303479086Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:48.248112703Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-ami3","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.893475859Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-anuw","title":"[14] Provide one-command neutral verifier mode that replays official runs and validates scoring + equivalence checks independently.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Provide one-command neutral verifier mode that replays official runs and validates scoring + equivalence checks independently.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:32.125965809Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.806971075Z","closed_at":"2026-02-20T07:41:20.099462276Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-anuw","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.806930078Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-c1co","title":"[11] Evidence And Decision Contracts (Mandatory) - Comprehensive Execution Epic","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nPurpose: Operationalize this section's governance/validation/adoption requirements into enforceable engineering work.\nQuality requirements for all children:\n- explicit acceptance criteria and failure semantics\n- unit-test and e2e/integration verification expectations\n- detailed structured logging and reproducibility artifacts where applicable\n- traceability back to category-level goals (security, performance, explainability, adoption)\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:15.233637630Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:43.845313684Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-11"],"dependencies":[{"issue_id":"bd-c1co","depends_on_id":"bd-1tsf","type":"blocks","created_at":"2026-02-20T07:34:37.717812047Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-c1co","depends_on_id":"bd-3t2d","type":"parent-child","created_at":"2026-02-20T07:45:15.236446885Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-crp","title":"[10.2] Define parser trait + canonical AST invariants for ES2020 script/module goals.","description":"## Plan Reference\nSection 10.2, item 1. Cross-refs: 9A.1, 9B.1, 9F.4, Phase A exit gate.\n\n## What\nDefine the parser trait interface and canonical AST type hierarchy for ES2020 script and module goal symbols. This is the foundation of the entire compilation pipeline - IR0 (SyntaxIR) is produced by this layer.\n\n## Detailed Requirements\n- Parser trait must be generic over input source (string, stream, file) with deterministic error reporting\n- AST nodes must be canonical: structurally identical source produces identical AST (no parse-order-dependent metadata)\n- Must support both Script and Module goal symbols per ES2020 spec\n- AST must carry source location spans for error reporting and debugging\n- AST serialization must be deterministic for replay/hash purposes (canonical serialization invariant from plan)\n- Must NOT mirror V8 or QuickJS internal AST structures - this is a de novo design informed by observable ES2020 semantics (per Section 10.1 donor-extraction policy)\n\n## Rationale\nThe plan's multi-level IR stack (IR0IR4) starts here. Without a well-defined parser trait and canonical AST, nothing downstream can be deterministic. The 9F.4 Capability-Typed TS Execution Contract requires that capability intent be traceable from source through all IR levels. This means the AST must be designed to support downstream capability annotation, not retrofitted later.\n\n## Testing Requirements\n- Unit tests: parse valid ES2020 script/module sources, verify AST structure matches expected canonical form\n- Unit tests: parse invalid sources, verify deterministic error with source location\n- Unit tests: verify canonical serialization (same source  same serialized AST bytes)\n- Property tests: round-trip parse  serialize  parse produces identical AST\n- Conformance: test262 parse-only subset as baseline validation\n- Edge cases: empty source, unicode identifiers, nested template literals, destructuring patterns\n\n## Implementation Notes\n- Define in crates/franken-engine as core parser trait\n- Consider arena allocation for AST nodes (9B.1 recommends arena allocation for IR nodes)\n- AST node types should be exhaustive enum, not trait objects, for determinism and performance\n- Hash invariant: define canonical hash over AST for use in IR0 witness artifacts\n\n## Dependencies\n- Blocks: IR contract (bd-1wa), lowering pipelines (bd-ug9), interpreter skeleton (bd-2f8)\n- Blocked by: nothing (foundational)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.404986697Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:48.339061269Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"],"dependencies":[{"issue_id":"bd-crp","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:45:18.332879938Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-d6h","title":"[10.12] Add counterexample synthesizer for conflicting policy controllers and ambiguous merges.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Add counterexample synthesizer for conflicting policy controllers and ambiguous merges.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.936839901Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:48.422124378Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-d6h","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.444926842Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-d93","title":"[10.7] Integrate transplanted extension conformance assets into runnable suites.","description":"Plan Reference: section 10.7 (Conformance + Verification).\nObjective: Integrate transplanted extension conformance assets into runnable suites.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:26.052376658Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:48.512774407Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-7"],"dependencies":[{"issue_id":"bd-d93","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-02-20T07:45:09.661314602Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-dkh","title":"[10.9] Release gate: proof-specialized lanes demonstrate positive performance delta versus ambient-authority lanes with 100% specialization-receipt coverage and deterministic fallback correctness (implementation ownership: `10.12` + `10.15` + `10.6` + `10.7`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: proof-specialized lanes demonstrate positive performance delta versus ambient-authority lanes with 100% specialization-receipt coverage and deterministic fallback correctness (implementation ownership: `10.12` + `10.15` + `10.6` + `10.7`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.858616381Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:48.605538515Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"],"dependencies":[{"issue_id":"bd-dkh","depends_on_id":"bd-1xm","type":"parent-child","created_at":"2026-02-20T07:45:04.036355344Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-du2","title":"[10.12] Define fleet immune-system message protocol for signed evidence, local confidence, and containment intent propagation.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Define fleet immune-system message protocol for signed evidence, local confidence, and containment intent propagation.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:38.863421634Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:48.661369503Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-du2","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.489342126Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-eke","title":"[10.9] Release gate: deterministic IFC protections block unauthorized sensitive-source exfiltration across the published exfil corpus, with receipt-backed declassification audit for approved exceptions (implementation ownership: `10.15` + `10.5` + `10.7`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: deterministic IFC protections block unauthorized sensitive-source exfiltration across the published exfil corpus, with receipt-backed declassification audit for approved exceptions (implementation ownership: `10.15` + `10.5` + `10.7`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.716828695Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:48.715147347Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"],"dependencies":[{"issue_id":"bd-eke","depends_on_id":"bd-1xm","type":"parent-child","created_at":"2026-02-20T07:45:04.083812964Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-esst","title":"[16] Scientific Contribution Targets - Comprehensive Execution Epic","description":"Plan Reference: section 16 (Scientific Contribution Targets).\nPurpose: Operationalize this section's governance/validation/adoption requirements into enforceable engineering work.\nQuality requirements for all children:\n- explicit acceptance criteria and failure semantics\n- unit-test and e2e/integration verification expectations\n- detailed structured logging and reproducibility artifacts where applicable\n- traceability back to category-level goals (security, performance, explainability, adoption)\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"closed","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:34:15.754049481Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:43.945084049Z","closed_at":"2026-02-20T07:46:28.422584014Z","close_reason":"Replaced by consolidated scientific contribution bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-16"],"dependencies":[{"issue_id":"bd-esst","depends_on_id":"bd-1jak","type":"blocks","created_at":"2026-02-20T07:34:38.887370442Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-esst","depends_on_id":"bd-1tsf","type":"blocks","created_at":"2026-02-20T07:34:38.203687358Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-esst","depends_on_id":"bd-21ds","type":"blocks","created_at":"2026-02-20T07:34:38.790126648Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-esst","depends_on_id":"bd-3t2d","type":"parent-child","created_at":"2026-02-20T07:45:15.280800194Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-ewy","title":"[10.12] Define attested execution-cell architecture and trust-root interface contract.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Define attested execution-cell architecture and trust-root interface contract.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:39.482664196Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:48.771481391Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-ewy","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.534039996Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-f7n","title":"[10.9] Publish first category-shift report demonstrating beyond-parity capabilities with evidence bundles.","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Publish first category-shift report demonstrating beyond-parity capabilities with evidence bundles.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.996358340Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:48.865136308Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"],"dependencies":[{"issue_id":"bd-f7n","depends_on_id":"bd-1xm","type":"parent-child","created_at":"2026-02-20T07:45:04.125994608Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-fp53","title":"[14] Equivalent side-effect trace class (filesystem/network/process/policy actions normalized by contract schema).","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Equivalent side-effect trace class (filesystem/network/process/policy actions normalized by contract schema).\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:29.692115611Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.850275419Z","closed_at":"2026-02-20T07:41:21.126076460Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-fp53","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.850234092Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-gr1","title":"[10.11] Add BOCPD-based regime detector for workload/health stream shifts feeding policy decisions.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add BOCPD-based regime detector for workload/health stream shifts feeding policy decisions.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.371586294Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:48.967218611Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-gr1","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:07.188493438Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-hli","title":"[10.11] Gate all remote operations behind explicit runtime capability (no implicit network side effects).","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Gate all remote operations behind explicit runtime capability (no implicit network side effects).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:36.110278994Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:49.051420461Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-hli","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:07.230524541Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-iqrn","title":"[15] Migration kits that convert existing Node/Bun extension workflows into capability-typed FrankenEngine workflows.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Migration kits that convert existing Node/Bun extension workflows into capability-typed FrankenEngine workflows.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:34.599613006Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:53.787453240Z","closed_at":"2026-02-20T07:45:53.787429606Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"],"dependencies":[{"issue_id":"bd-iqrn","depends_on_id":"bd-1jak","type":"parent-child","created_at":"2026-02-20T07:43:30.777129582Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-j7z","title":"[10.1] Add feature-parity tracker wired to `test262`, lockstep corpora, and waiver governance.","description":"Plan Reference: section 10.1 (Charter + Governance).\nObjective: Add feature-parity tracker wired to `test262`, lockstep corpora, and waiver governance.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.280072732Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:49.166213007Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-1"],"dependencies":[{"issue_id":"bd-j7z","depends_on_id":"bd-2mf","type":"parent-child","created_at":"2026-02-20T07:45:07.678960616Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-j7z","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.813051695Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-jaqy","title":"[10.13] Add fallback validation proving control-plane failure degrades to deterministic safe mode rather than undefined behavior.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add fallback validation proving control-plane failure degrades to deterministic safe mode rather than undefined behavior.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:44.412727627Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:49.254199666Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-jaqy","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:12.643191888Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-js4","title":"[10.6] Add opportunity matrix scoring to optimization workflow.","description":"Plan Reference: section 10.6 (Performance Program).\nObjective: Add opportunity matrix scoring to optimization workflow.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:25.615583411Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:49.340595512Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-6"],"dependencies":[{"issue_id":"bd-js4","depends_on_id":"bd-12m","type":"parent-child","created_at":"2026-02-20T07:43:30.175771858Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-kfe4","title":"[10.15] Add version-matrix CI lane (N/N-1/N+1 where applicable) for contract compatibility checks across supported repo/version combinations.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Add version-matrix CI lane (N/N-1/N+1 where applicable) for contract compatibility checks across supported repo/version combinations.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:49.135710723Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:49.431336592Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-kfe4","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.933577218Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-kr99","title":"[10.15] Implement signed replacement-lineage log with transparency-verifiable append semantics and independent verifier CLI integration.","description":"Plan Reference: section 10.15 (Delta Moonshots Execution Track (9I)).\nObjective: Implement signed replacement-lineage log with transparency-verifiable append semantics and independent verifier CLI integration.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:54.408624545Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:49.519933568Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-15"],"dependencies":[{"issue_id":"bd-kr99","depends_on_id":"bd-3q9","type":"parent-child","created_at":"2026-02-20T07:45:14.975866703Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-lpl","title":"[10.10] Persist highest accepted checkpoint frontier and reject rollback/regression attempts.","description":"Plan Reference: section 10.10 (FCP-Inspired Hardening + Interop Track).\nObjective: Persist highest accepted checkpoint frontier and reject rollback/regression attempts.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:29.977331511Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:49.601738463Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-10"],"dependencies":[{"issue_id":"bd-lpl","depends_on_id":"bd-3vh","type":"parent-child","created_at":"2026-02-20T07:45:16.856452379Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-m9pa","title":"[10.13] Integrate obligation-tracking for two-phase safety-critical operations on extension-host paths and fail lab runs on unresolved obligations.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Integrate obligation-tracking for two-phase safety-critical operations on extension-host paths and fail lab runs on unresolved obligations.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:42.795493644Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:49.688836788Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-m9pa","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:12.687580673Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-mhz4","title":"Implement benchmark harness, scoring calculator, and neutral verifier mode","description":"## Plan Reference\nSection 14.2-14.3: Claim Denominator and Reproducibility\nSection 10.6: Performance Program TODOs\n\n## What\nBuild the executable benchmark infrastructure: harness runner, weighted-geometric-mean scoring calculator, equivalence checker, neutral verifier mode, and artifact storage integration.\n\n## Components\n1. **Benchmark harness runner**: Orchestrates workload execution across FrankenEngine/Node/Bun with deterministic seeding, warm/cold cache control, and artifact capture\n2. **Weighted geometric mean calculator**: Implements the exact scoring formula from Section 14.2\n3. **Behavior-equivalence checker**: Validates output canonical digests, side-effect trace equivalence, and error-class semantics\n4. **Neutral verifier mode**: One-command mode for third parties to replay and validate scoring independently\n5. **Artifact storage**: Integration with frankensqlite for result ledgers and frankentui for operator dashboards\n6. **Publication gate**: Automated check that all prerequisites are met before allowing claim publication\n\n## Implementation Details\n- CLI: frankenctl benchmark run --suite extension-heavy --profile S/M/L\n- CLI: frankenctl benchmark score --baseline node --compare ./results/\n- CLI: frankenctl benchmark verify --manifest ./results/manifest.json\n- Run manifests include: hardware, kernel, runtime versions, flags, dataset checksums, seed transcripts, harness commit IDs\n- Store raw per-run data, not just aggregates\n- Native-coverage progression published alongside benchmark releases\n\n## Testing Requirements\n- Unit tests for scoring formula with known inputs/outputs\n- Unit tests for equivalence checker (matching and non-matching cases)\n- Integration tests for full harness lifecycle (setup, run, score, verify)\n- E2E test with mini workload producing complete artifact set\n- Regression test ensuring scoring formula changes require version bump\n\n## Rationale\nSection 14.3 requires at least two independent third-party reruns. The neutral verifier mode must be robust enough for external use. From Section 7.5: every published claim must include verifier scripts and deterministic repro commands.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:42:12.677337908Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:49.776053393Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["benchmark","performance","tooling"]}
{"id":"bd-mrf8","title":"[15] Signed extension registry with enforceable provenance, attestation, and revocation policies.","description":"Plan Reference: section 15 (Ecosystem Capture Strategy).\nObjective: Signed extension registry with enforceable provenance, attestation, and revocation policies.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-20T07:34:34.395892910Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:56.851198724Z","closed_at":"2026-02-20T07:45:56.851175521Z","close_reason":"Consolidated into single ecosystem capture bead with full plan context","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-15"],"dependencies":[{"issue_id":"bd-mrf8","depends_on_id":"bd-1jak","type":"parent-child","created_at":"2026-02-20T07:43:30.863635176Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-nhp","title":"[10.12] Implement epoch-bound specialization invalidation and deterministic fallback to baseline paths on proof/policy churn.","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Implement epoch-bound specialization invalidation and deterministic fallback to baseline paths on proof/policy churn.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:38.688630984Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:49.866123663Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-nhp","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.735919017Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-ntq","title":"[10.2] VM Core - Comprehensive Execution Epic","description":"Plan Reference: section 10.2 (VM Core).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":2,"issue_type":"epic","created_at":"2026-02-20T07:32:18.302155218Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:50.648754141Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-2"],"dependencies":[{"issue_id":"bd-ntq","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.685731957Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ntq","depends_on_id":"bd-3vh","type":"blocks","created_at":"2026-02-20T07:32:55.347873177Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-o8v","title":"[10.2] Implement deterministic Promise jobs/microtask ordering and async semantics.","description":"Plan Reference: section 10.2 (VM Core).\nObjective: Implement deterministic Promise jobs/microtask ordering and async semantics.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:22.839997827Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:49.953791899Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"],"dependencies":[{"issue_id":"bd-o8v","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:45:18.372859120Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-pace","title":"[13] all SQLite-backed control-plane persistence in FrankenEngine is delivered through `/dp/frankensqlite` integration, with `/dp/sqlmodel_rust` used where typed model layers materially improve safety","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: all SQLite-backed control-plane persistence in FrankenEngine is delivered through `/dp/frankensqlite` integration, with `/dp/sqlmodel_rust` used where typed model layers materially improve safety\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:22.173603817Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:11.237913868Z","closed_at":"2026-02-20T07:39:59.484477117Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-pace","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:11.237864005Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-qozg","title":"[13] security and performance claims are artifact-backed and reproducible","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: security and performance claims are artifact-backed and reproducible\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:19.631811548Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:11.286649499Z","closed_at":"2026-02-20T07:40:00.719193158Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-qozg","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:11.286603463Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-qse","title":"[10.11] Add obligation leak response policy split (`lab=fatal`, `prod=diagnostic + scoped failover`).","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add obligation leak response policy split (`lab=fatal`, `prod=diagnostic + scoped failover`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:34.207033523Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:50.043478805Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-qse","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:07.274817857Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-rr94","title":"[10.14] Add cross-repo contract tests validating schema/API compatibility for integration boundaries (`frankentui`, `frankensqlite`, `sqlmodel_rust`, `fastapi_rust`).","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add cross-repo contract tests validating schema/API compatibility for integration boundaries (`frankentui`, `frankensqlite`, `sqlmodel_rust`, `fastapi_rust`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:46.516678118Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:50.127626464Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-rr94","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:18.972269266Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-skw6","title":"[13] untrusted extension code is actively monitored and auto-contained under attack scenarios","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: untrusted extension code is actively monitored and auto-contained under attack scenarios\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:19.423294387Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:11.326091059Z","closed_at":"2026-02-20T07:40:00.817580432Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-skw6","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:11.326041326Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-t2m","title":"[10.5] Implement forensic replay tooling for incident traces.","description":"Plan Reference: section 10.5 (Extension Host + Security).\nObjective: Implement forensic replay tooling for incident traces.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:24.687661517Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:50.211001714Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-5"],"dependencies":[{"issue_id":"bd-t2m","depends_on_id":"bd-1yq","type":"parent-child","created_at":"2026-02-20T07:45:04.547362808Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-tgv","title":"[10.4] Implement module resolver trait with policy hooks.","description":"Plan Reference: section 10.4 (Module + Runtime Surface).\nObjective: Implement module resolver trait with policy hooks.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:23.504206677Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:50.298142668Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-4"],"dependencies":[{"issue_id":"bd-tgv","depends_on_id":"bd-3ch","type":"parent-child","created_at":"2026-02-20T07:45:11.556723093Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-ttd","title":"[10.0] Top-10 #7: Capability lattice + typed policy DSL (strategy: `9A.7`; deep semantics: `9F.8`; execution owners: `10.5`, `10.10`, `10.12`, `10.13`).","description":"Plan Reference: section 10.0 (Top 10 Initiative Tracking (Canonical Implementation Index)).\nObjective: Top-10 #7: Capability lattice + typed policy DSL (strategy: `9A.7`; deep semantics: `9F.8`; execution owners: `10.5`, `10.10`, `10.12`, `10.13`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:20.022177843Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:50.383960037Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-0"],"dependencies":[{"issue_id":"bd-ttd","depends_on_id":"bd-1of","type":"parent-child","created_at":"2026-02-20T07:43:31.698892933Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-twz2","title":"[13] secure extension reputation graph drives measurable reduction in first-time compromise windows","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: secure extension reputation graph drives measurable reduction in first-time compromise windows\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:23.441037994Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:11.368392415Z","closed_at":"2026-02-20T07:39:58.886875205Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-twz2","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:11.368343204Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-ug9","title":"[10.2] Implement lowering pipelines with per-pass verification and witness emission.","description":"## Plan Reference\nSection 10.2, item 3. Cross-refs: 9B.1 (incremental/self-adjusting compilation), 9C.1 (proof-carrying compilation with isomorphism ledger), 9D.1 (compilation benchmark suite).\n\n## What\nImplement the lowering pipelines that transform code through the IR stack: IR0IR1IR2IR3. Each pass must emit verification witnesses proving the transformation preserves semantics.\n\n## Detailed Requirements\n- IR0IR1 lowering: resolve scopes, bindings, and spec-level semantics\n- IR1IR2 lowering: annotate capability intent, effect boundaries, and IFC flow labels\n- IR2IR3 lowering: produce execution-ready form with proof linkage metadata\n- Each pass must emit a witness artifact proving semantic preservation (per 9C.1 proof-carrying compilation contract)\n- Isomorphism ledger: record ordering/tie-break semantics and verify behavioral equivalence on golden corpora (per 9C.1)\n- Passes must be independently testable and composable\n- Support per-pass verification: each lowering step can be validated in isolation\n- Consider incremental/self-adjusting compilation (per 9B.1) for low-latency rebuilds under rapid extension edits\n\n## Rationale\nThe plan requires proof-carrying compilation (9C.1): 'each lowering stage emits invariants and a machine-checkable witness that capability annotations are preserved end-to-end.' This means lowering is not just a transformation but a verified transformation pipeline. The witness artifacts feed into the deterministic evidence graph (9A.3) and are required for replay/audit.\n\n## Testing Requirements\n- Unit tests: lower valid IR0 through each stage, verify output IR type and content\n- Unit tests: verify witness artifacts are emitted for each pass\n- Unit tests: verify lowering rejects invalid IR (missing required annotations)\n- Golden corpus tests: lower known inputs, compare output IR hashes against golden values\n- Isomorphism tests: verify lowered IR produces identical behavior to source\n- Performance: benchmark each lowering pass separately (per 9D.1)\n\n## Implementation Notes\n- Each pass should be a separate function/module for testability\n- Witness format should be defined in the IR contract (bd-1wa)\n- Consider arena allocation for intermediate IR nodes\n- Passes should be pure functions (no side effects) for determinism\n\n## Dependencies\n- Blocked by: parser trait (bd-crp), IR contract (bd-1wa)\n- Blocks: interpreter skeleton (bd-2f8), IFC flow-check (bd-3jg), proof-to-specialization (bd-161)\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:21.672487055Z","created_by":"ubuntu","updated_at":"2026-02-20T07:48:20.829858847Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-2"],"dependencies":[{"issue_id":"bd-ug9","depends_on_id":"bd-ntq","type":"parent-child","created_at":"2026-02-20T07:45:18.413473574Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-ulle","title":"[11] Define deterministic rollback command and known-good recovery path","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: rollback command\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:17.140889042Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:17.286748890Z","closed_at":"2026-02-20T07:38:22.899595123Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-ulle","depends_on_id":"bd-3tjn","type":"blocks","created_at":"2026-02-20T07:38:26.506754839Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-ulle","depends_on_id":"bd-c1co","type":"parent-child","created_at":"2026-02-20T07:45:17.286684480Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-uvmm","title":"[10.13] Emit canonical evidence entries via `franken-evidence` for all high-impact actions, linked to `trace_id`, `decision_id`, `policy_id`, and artifact hashes.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Emit canonical evidence entries via `franken-evidence` for all high-impact actions, linked to `trace_id`, `decision_id`, `policy_id`, and artifact hashes.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:43.116221318Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:50.555445958Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-uvmm","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:12.730107099Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-uwc","title":"[10.9] Release gate: autonomous quarantine mesh is implemented and validated under fault injection (implementation ownership: `10.12`).","description":"Plan Reference: section 10.9 (Moonshot Disruption Track).\nObjective: Release gate: autonomous quarantine mesh is implemented and validated under fault injection (implementation ownership: `10.12`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:28.000188653Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:50.637857934Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-9"],"dependencies":[{"issue_id":"bd-uwc","depends_on_id":"bd-1xm","type":"parent-child","created_at":"2026-02-20T07:45:04.171128921Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-von8","title":"[11] Require explicit expected-loss model with asymmetric risk costs","description":"Plan Reference: section 11 (Evidence And Decision Contracts (Mandatory)).\nObjective: expected-loss model\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:16.487226497Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:17.330359014Z","closed_at":"2026-02-20T07:38:23.204039826Z","close_reason":"Consolidated into single evidence-contract template bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-11"],"dependencies":[{"issue_id":"bd-von8","depends_on_id":"bd-3qm1","type":"blocks","created_at":"2026-02-20T07:38:26.156742107Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-von8","depends_on_id":"bd-c1co","type":"parent-child","created_at":"2026-02-20T07:45:17.330305585Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-xga","title":"[10.11] Define monotonic `security_epoch` model and validity-window checks across signed trust artifacts.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Define monotonic `security_epoch` model and validity-window checks across signed trust artifacts.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:35.669967173Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:50.723898538Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-xga","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:07.313787979Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-xq7","title":"Port extension manifest validation scaffold into franken-extension-host","description":"Implements PLAN 10.5: port extension manifest validation into compile-active modules. Add deterministic manifest schema + validation API in crates/franken-extension-host, with typed validation errors and focused unit tests for required fields, capability declaration checks, and deterministic failure messages.","status":"in_progress","priority":1,"issue_type":"task","assignee":"AzureMountain","created_at":"2026-02-20T07:24:27.192973464Z","created_by":"AzureMountain","updated_at":"2026-02-20T07:45:04.590503318Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["extension-host","plan","section-10-5","security","validation"],"dependencies":[{"issue_id":"bd-xq7","depends_on_id":"bd-1yq","type":"parent-child","created_at":"2026-02-20T07:45:04.590462512Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-ye6k","title":"[14] Update standards with explicit versioning and migration notes.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Update standards with explicit versioning and migration notes.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:28.509746083Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.892056447Z","closed_at":"2026-02-20T07:41:21.621584293Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-ye6k","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.892016542Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-yi6","title":"[10.11] Add phase gates for this track: deterministic replay pass, interleaving suite pass, conformance vectors pass, and fuzz/adversarial pass.","description":"Plan Reference: section 10.11 (FrankenSQLite-Inspired Runtime Systems Track).\nObjective: Add phase gates for this track: deterministic replay pass, interleaving suite pass, conformance vectors pass, and fuzz/adversarial pass.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:38.071605272Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:50.840454199Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-11"],"dependencies":[{"issue_id":"bd-yi6","depends_on_id":"bd-2g9","type":"parent-child","created_at":"2026-02-20T07:45:07.356142625Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-ypl4","title":"[10.13] Add naming guidance to the ADR: Cargo package names (`franken-kernel`, `franken-decision`, `franken-evidence`) and Rust crate paths (`franken_kernel`, `franken_decision`, `franken_evidence`) are both normative references.","description":"Plan Reference: section 10.13 (Asupersync Constitutional Integration Track).\nObjective: Add naming guidance to the ADR: Cargo package names (`franken-kernel`, `franken-decision`, `franken-evidence`) and Rust crate paths (`franken_kernel`, `franken_decision`, `franken_evidence`) are both normative references.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-20T07:32:41.801377101Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:50.925159967Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-13"],"dependencies":[{"issue_id":"bd-ypl4","depends_on_id":"bd-3nr","type":"parent-child","created_at":"2026-02-20T07:45:12.772697263Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-yqe","title":"[10.12] Define proof schema and signer model for optimizer activation witnesses (`opt_receipt`, `rollback_token`, `invariance_digest`).","description":"Plan Reference: section 10.12 (Frontier Programs Execution Track (9H Canonical Owners)).\nObjective: Define proof schema and signer model for optimizer activation witnesses (`opt_receipt`, `rollback_token`, `invariance_digest`).\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:38.223290222Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:51.008629213Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-12"],"dependencies":[{"issue_id":"bd-yqe","depends_on_id":"bd-2r6","type":"parent-child","created_at":"2026-02-20T07:45:08.779549649Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-yqg5","title":"[10.14] Add release checklist item requiring explicit reuse vs reimplement justification for any new console, SQLite, or service layer work.","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nObjective: Add release checklist item requiring explicit reuse vs reimplement justification for any new console, SQLite, or service layer work.\nRationale:\n- This work item is required to preserve the full architectural and security/performance intent of the FrankenEngine charter.\n- Implementation must preserve deterministic behavior, replayability, and explicit evidence surfaces where the feature touches runtime decisions.\nImplementation expectations:\n1. Produce concrete code/docs/artifacts for the objective with no hidden compatibility shims.\n2. Document constraints, assumptions, and non-goals in commit/PR notes.\n3. Keep interfaces explicit and testable; avoid ambient authority patterns.\nVerification requirements (mandatory):\n- Unit tests: nominal path, edge conditions, and failure-path invariants for this item.\n- E2E/integration tests: realistic scenario coverage with deterministic setup/teardown.\n- Logging/observability: emit structured logs with stable fields; include trace/policy/decision identifiers when applicable.\n- Reproducibility: outputs must support env/manifest/repro-lock artifact capture.\nDone definition:\n- Implementation merged with tests passing.\n- Failure modes and rollback semantics documented.\n- Any new artifacts wired into evidence/replay pathways where applicable.\n\n## Acceptance Criteria\n1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","acceptance_criteria":"1. Implement the full objective with explicit deterministic behavior, failure semantics, and rollback constraints where applicable.\n2. Add focused unit tests covering normal paths, boundary conditions, invalid/adversarial inputs, and invariant enforcement.\n3. Add end-to-end/integration test scripts that exercise lifecycle transitions and failure recovery paths using deterministic seeds/fixtures and CI-ready command lines.\n4. Emit structured logs with stable fields (`trace_id`, `decision_id`, `policy_id`, `component`, `event`, `outcome`, `error_code`) and add assertions for critical log events in tests.\n5. Produce reproducibility artifacts (run manifest, replay/evidence pointers, benchmark/check outputs) and document operator verification steps.\n6. For Rust build/test workflows introduced by this bead, document/execute via `rch`-wrapped commands for heavy compilation/test workloads.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-20T07:32:46.843784864Z","created_by":"ubuntu","updated_at":"2026-02-20T07:47:51.098066874Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-10-14"],"dependencies":[{"issue_id":"bd-yqg5","depends_on_id":"bd-zvn","type":"parent-child","created_at":"2026-02-20T07:45:19.013110043Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-zvn","title":"[10.14] FrankenSuite Sibling Integration Track - Comprehensive Execution Epic","description":"Plan Reference: section 10.14 (FrankenSuite Sibling Integration Track).\nPurpose: Convert the plan's intent into an executable, dependency-aware workstream without losing scope, ambition, or proof rigor.\nWhy this exists:\n- Keeps implementation aligned to the ambition-first charter and impossible-by-default capability goals.\n- Prevents drift between strategic language and engineering execution.\n- Ensures every deliverable carries deterministic verification, evidence artifacts, and replay-ready observability.\nRequired quality bar for all child beads:\n1. Include concrete implementation detail, not vague intent.\n2. Require focused unit tests for logic/invariant boundaries.\n3. Require end-to-end/integration scenarios with detailed structured logging (trace/policy/decision identifiers where relevant).\n4. Require artifact publication suitable for reproducibility contracts.\n\n## Success Criteria\n1. All child beads are complete with artifact-backed acceptance evidence (including unit tests, deterministic e2e/integration scripts, and structured logging validation).\n2. Section-level dependencies remain acyclic and executable in dependency order with no unresolved critical blockers.\n3. Reproducibility/evidence expectations are satisfied (replayability, benchmark/correctness artifacts, and operator verification instructions).\n4. Deliverables preserve full PLAN scope and capability intent with no silent feature/functionality reduction.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-02-20T07:32:19.072342452Z","created_by":"ubuntu","updated_at":"2026-02-20T07:46:44.176534092Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["execution-epic","plan","section-10-14"],"dependencies":[{"issue_id":"bd-zvn","depends_on_id":"bd-1tsf","type":"parent-child","created_at":"2026-02-20T07:45:03.725532886Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-zvn","depends_on_id":"bd-3nr","type":"blocks","created_at":"2026-02-20T07:32:57.715391711Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-zze6","title":"[14] Throughput claims must be accompanied by latency/error envelopes so speedups cannot hide tail-collapse or correctness loss.","description":"Plan Reference: section 14 (Public Benchmark + Standardization Strategy).\nObjective: Throughput claims must be accompanied by latency/error envelopes so speedups cannot hide tail-collapse or correctness loss.\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:31.392914698Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:05.934992616Z","closed_at":"2026-02-20T07:41:20.401677447Z","close_reason":"Consolidated into coherent benchmark implementation beads","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-14"],"dependencies":[{"issue_id":"bd-zze6","depends_on_id":"bd-21ds","type":"parent-child","created_at":"2026-02-20T07:45:05.934949565Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-zzgz","title":"[13] proof-specialized execution lanes show measurable throughput or tail-latency improvement versus ambient-authority lanes at equivalent semantics","description":"Plan Reference: section 13 (Program Success Criteria).\nObjective: proof-specialized execution lanes show measurable throughput or tail-latency improvement versus ambient-authority lanes at equivalent semantics\nContext and rationale:\n- This item is part of the project's non-optional governance, verification, or adoption contract.\n- It exists to ensure technical claims remain auditable, reproducible, and externally defensible.\nImplementation requirements:\n1. Define precise interfaces/artifacts/checks needed for this objective.\n2. Integrate with existing evidence/replay/benchmark/control surfaces where relevant.\n3. Document operator/developer workflows and rollback/failure behavior.\nValidation requirements:\n- Unit tests for parsing/rules/logic where code is introduced.\n- End-to-end or system-level scenarios with detailed logging and deterministic assertions.\n- Artifact outputs compatible with reproducibility and independent verification workflows.\nDone definition:\n- Objective implemented with tests and observability.\n- Dependencies and operational runbooks updated.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-20T07:34:26.640725162Z","created_by":"ubuntu","updated_at":"2026-02-20T07:45:11.414175056Z","closed_at":"2026-02-20T07:39:57.492950760Z","close_reason":"Consolidated into comprehensive program success criteria bead","source_repo":".","compaction_level":0,"original_size":0,"labels":["detailed","plan","section-13"],"dependencies":[{"issue_id":"bd-zzgz","depends_on_id":"bd-395m","type":"parent-child","created_at":"2026-02-20T07:45:11.414127728Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
